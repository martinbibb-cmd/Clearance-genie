<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Clearance Genie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
        }

        input[type="file"] {
            display: none;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            background: #f7fafc;
            display: none;
        }

        .canvas-container.active {
            display: block;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: crosshair;
        }

        .instructions {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .calibration-points {
            background: #fff5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f56565;
        }

        .calibration-points p {
            margin: 5px 0;
            font-weight: 600;
        }

        .status {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.warning {
            background: #feebc8;
            color: #7c2d12;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
        }

        .calibration-info {
            background: #e6fffa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #38b2ac;
            display: none;
        }

        .calibration-info.active {
            display: block;
        }

        .calibration-info h4 {
            color: #38b2ac;
            margin-bottom: 10px;
        }

        .calibration-info p {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        /* iPad-specific layout */
        @media (min-width: 768px) and (max-width: 1024px) {
            .ipad-layout {
                display: flex;
                gap: 20px;
                align-items: flex-start;
            }

            .ipad-layout .canvas-container {
                flex: 0 0 60%;
                margin: 0;
            }

            .ipad-layout .controls-panel {
                flex: 1;
                background: white;
                border-radius: 15px;
                padding: 20px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                max-height: 80vh;
                overflow-y: auto;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .button-group {
                grid-template-columns: 1fr;
            }

            #outputImagesSection > div {
                grid-template-columns: 1fr !important;
            }
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-panel {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
        }

        .results-panel.active {
            display: block;
        }

        .results-panel h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .detection-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
        }

        .detection-item strong {
            color: #667eea;
        }

        .zone-legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .zone-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zone-color-box {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #333;
        }

        .zone-red {
            background: rgba(245, 101, 101, 0.5);
        }

        .zone-green {
            background: rgba(72, 187, 120, 0.5);
        }

        .zone-blue {
            background: rgba(66, 153, 225, 0.5);
        }

        .obstacle-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .obstacle-item strong {
            color: #667eea;
        }

        .obstacle-delete-btn {
            background: #f56565;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .obstacle-delete-btn:hover {
            background: #e53e3e;
        }

        .compliance-pass {
            background: #c6f6d5;
            color: #22543d;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 18px;
            text-align: center;
        }

        .compliance-fail {
            background: #fed7d7;
            color: #742a2a;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 18px;
            text-align: center;
        }

        /* Bug Report Button */
        .bug-report-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #f56565;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(245, 101, 101, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .bug-report-btn:hover {
            background: #e53e3e;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 101, 101, 0.6);
        }

        /* Bug Report Modal */
        .bug-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            overflow-y: auto;
        }

        .bug-modal-content {
            background: white;
            max-width: 600px;
            margin: 50px auto;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .bug-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .bug-modal-header h2 {
            color: #667eea;
            margin: 0;
        }

        .bug-modal-close {
            background: none;
            border: none;
            font-size: 30px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            line-height: 30px;
        }

        .bug-modal-close:hover {
            color: #333;
        }

        .bug-form-group {
            margin-bottom: 20px;
        }

        .bug-form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        .bug-form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 120px;
        }

        .bug-form-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .bug-screenshot-upload {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bug-screenshot-upload:hover {
            border-color: #667eea;
            background: #f7f9ff;
        }

        .bug-screenshot-preview {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .bug-screenshot-item {
            position: relative;
            width: 100px;
            height: 100px;
        }

        .bug-screenshot-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .bug-screenshot-remove {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #f56565;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            line-height: 20px;
        }

        .bug-submit-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
        }

        .bug-submit-btn:hover {
            background: #5568d3;
        }

        .bug-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
    </style>

</head>
<body>
    <div class="container">
        <h1>üî• Clearance Genie</h1>

        <div style="text-align: center; margin-bottom: 20px;">
            <button type="button" class="btn btn-secondary" onclick="window.location.reload()" style="background: #48bb78; padding: 10px 20px; font-size: 14px;">
                üîÑ Force Refresh
            </button>
        </div>

        <div class="card">
            <h2>Step 1: Load Photo</h2>
            <p style="margin: 10px 0; color: #666;">Take or upload a photo with a calibration reference (blue card or standard brick)</p>
            
            <input type="file" id="photoInput" accept="image/*">
            <div class="button-group">
                <button class="btn" onclick="document.getElementById('photoInput').click()">
                    üìÅ Choose Photo
                </button>
                <button class="btn" onclick="openCamera()">
                    üì∑ Take Photo
                </button>
            </div>

            <div class="instructions">
                <h3>üìã How to take the photo:</h3>
                <ol>
                    <li>Place your blue calibration card <strong>OR</strong> a standard brick on the wall at the proposed flue/boiler height</li>
                    <li>Stand back and take a clear photo that includes the reference object and surrounding area</li>
                    <li>Make sure the reference object is clearly visible and not blurry</li>
                    <li>Include any windows, vents, corners, or obstacles in the frame</li>
                </ol>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="photoCanvas"></canvas>
            <div id="zoomControls" style="display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 100;">
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 5px; text-align: center;">Zoom</div>
                    <button onclick="zoomIn()" style="display: block; width: 40px; height: 40px; margin-bottom: 5px; font-size: 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">+</button>
                    <button onclick="resetZoom()" style="display: block; width: 40px; height: 40px; margin-bottom: 5px; font-size: 14px; background: #48bb78; color: white; border: none; border-radius: 5px; cursor: pointer;">1:1</button>
                    <button onclick="zoomOut()" style="display: block; width: 40px; height: 40px; font-size: 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">-</button>
                </div>
                <div>
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 5px; text-align: center;">Pan</div>
                    <button onclick="panUp()" style="display: block; width: 40px; height: 40px; margin: 0 auto 5px; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üë</button>
                    <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                        <button onclick="panLeft()" style="width: 40px; height: 40px; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üê</button>
                        <button onclick="panRight()" style="width: 40px; height: 40px; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üí</button>
                    </div>
                    <button onclick="panDown()" style="display: block; width: 40px; height: 40px; margin: 0 auto; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üì</button>
                </div>
            </div>
        </div>

        <div class="card" id="calibrationCard" style="display: none;">
            <h2>Step 2: Calibrate Scale</h2>

            <div style="margin-bottom: 15px;">
                <h3 style="margin-bottom: 10px;">Calibration Reference Object:</h3>
                <div class="button-group">
                    <button class="btn" id="cardModeBtn" onclick="setCalibrationMode('card')" style="background: #667eea;">
                        üí≥ Blue Card
                    </button>
                    <button class="btn btn-secondary" id="brickModeBtn" onclick="setCalibrationMode('brick')">
                        üß± Standard Brick
                    </button>
                </div>
            </div>

            <div id="brickOrientationSelector" style="display: none; margin-bottom: 15px;">
                <h4 style="margin-bottom: 8px;">Brick Face Visible:</h4>
                <select id="brickOrientationSelect" onchange="setBrickOrientation(this.value)" style="width: 100%; padding: 10px; font-size: 14px; border: 2px solid #e2e8f0; border-radius: 8px;">
                    <option value="length">Stretcher (215mm √ó 65mm)</option>
                    <option value="width">Header (102.5mm √ó 65mm)</option>
                    <option value="height">Bed (215mm √ó 102.5mm)</option>
                </select>
                <p style="margin-top: 5px; font-size: 12px; color: #666;">Select which face of the brick is visible in the photo</p>
            </div>

            <div class="status" id="tapStatus">
                Choose calibration method below
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" id="autoDetectBtn" onclick="autoDetectReference()">
                    ü§ñ Auto-Detect <span id="autoDetectLabel">Card</span>
                </button>
                <button class="btn" onclick="startManualCalibration()">
                    üëÜ Manual 4-Point
                </button>
            </div>

            <div class="calibration-points" id="pointsDisplay" style="display: none;">
                <p>Points tapped: <span id="pointCount">0</span>/4</p>
                <button class="btn btn-danger" onclick="resetCalibration()" style="margin-top: 10px;">
                    ‚Ü∫ Reset Points
                </button>
            </div>

            <div class="calibration-info" id="calibrationInfo">
                <h4>‚úÖ Calibration Complete!</h4>
                <p>Scale: <span id="scaleDisplay">-</span> pixels/mm</p>
                <p id="refDim1Label">Width: <span id="refDim1Display">-</span> pixels</p>
                <p id="refDim2Label">Height: <span id="refDim2Display">-</span> pixels</p>
                <p>Accuracy: <span id="accuracyDisplay">-</span></p>
                <p>Plumb Line: <span id="plumbDisplay">-</span></p>
                <button class="btn" onclick="resetCalibration()" style="margin-top: 10px;">
                    üîÑ Recalibrate
                </button>
            </div>
        </div>

        <div class="card" id="analysisCard" style="display: none;">
            <h2>Step 3: Choose Analysis Type</h2>
            
            <div class="instructions">
                <h3>What do you want to check?</h3>
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="startFlueMode()">
                    üî• Horizontal Flue Clearances
                </button>
                <button class="btn btn-secondary" onclick="startVerticalFlueMode()">
                    ‚¨ÜÔ∏è Vertical Flue Clearances
                </button>
                <button class="btn btn-secondary" onclick="startBoilerMode()">
                    üîß Boiler Clearances
                </button>
                <button class="btn btn-secondary" onclick="startRadiatorMode()">
                    üå°Ô∏è Radiator Clearances
                </button>
                <button class="btn btn-secondary" onclick="startCylinderMode()">
                    üóúÔ∏è Cylinder Placement
                </button>
            </div>

            <button class="btn" onclick="testClick()">üß™ Test Click</button>

            <div id="positionInstructions" style="display: none;">
                <div class="status active" id="positionStatus">
                    üëÜ Tap on the image to mark the position
                </div>
            </div>

            <div id="boilerEditingSection" style="display: none;">
                <div class="instructions">
                    <h3>Select Boiler Brand & Model</h3>
                    <p>Choose your boiler to load manufacturer specifications:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="brandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="modelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model/Range:</strong>
                        <select id="modelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateBoilerClearancesFromCSV()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>
                </div>

                <div id="clearanceNotesSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                    <h4 style="color: #856404; margin-bottom: 10px;">‚ö†Ô∏è Special Requirements</h4>
                    <div id="clearanceNotesContent" style="color: #856404;"></div>
                </div>

                <div class="instructions" style="margin-top: 20px;">
                    <h3>Edit Boiler Dimensions & Clearances</h3>
                    <p>Adjust the dimensions and clearances as needed:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="color: #667eea; margin-bottom: 15px;">Boiler Dimensions (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Height:</label>
                            <input type="number" id="boilerHeight" value="600" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Width:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button onclick="adjustBoilerWidth(-10)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚óÄ</button>
                                <input type="number" id="boilerWidth" value="390" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc; text-align: center;">
                                <button onclick="adjustBoilerWidth(10)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚ñ∂</button>
                            </div>
                        </div>
                    </div>

                    <h4 style="color: #667eea; margin-bottom: 15px; margin-top: 20px;">Service Clearances (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Top:</label>
                            <input type="number" id="clearanceTop" value="170" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Bottom:</label>
                            <input type="number" id="clearanceBottom" value="200" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Left:</label>
                            <input type="number" id="clearanceLeft" value="5" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Right:</label>
                            <input type="number" id="clearanceRight" value="5" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                    </div>

                    <button class="btn btn-secondary" onclick="updateBoilerDisplay()" style="margin-top: 15px;">
                        üîÑ Update Display
                    </button>

                    <button class="btn btn-secondary" id="downloadBoilerMarkupBtn" onclick="downloadCurrentCanvas('boiler-markup.png')" style="margin-top: 10px; display: none;">
                        üíæ Download Image with Boiler Markup
                    </button>
                </div>
            </div>

            <div id="radiatorEditingSection" style="display: none;">
                <div class="instructions">
                    <h3>Edit Radiator Dimensions & Clearances</h3>
                    <p>Adjust the dimensions and clearances as needed:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="color: #667eea; margin-bottom: 15px;">Radiator Dimensions (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Height:</label>
                            <select id="radiatorHeight" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                                <option value="300">300mm</option>
                                <option value="450">450mm</option>
                                <option value="600" selected>600mm</option>
                                <option value="700">700mm</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Width:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button onclick="adjustRadiatorWidth(-200)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚óÄ</button>
                                <input type="number" id="radiatorWidth" value="400" readonly style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc; text-align: center;">
                                <button onclick="adjustRadiatorWidth(200)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚ñ∂</button>
                            </div>
                        </div>
                    </div>

                    <h4 style="color: #667eea; margin-bottom: 15px; margin-top: 20px;">Service Clearances (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Top:</label>
                            <input type="number" id="radiatorClearanceTop" value="0" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Bottom:</label>
                            <input type="number" id="radiatorClearanceBottom" value="150" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Left:</label>
                            <input type="number" id="radiatorClearanceLeft" value="150" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Right:</label>
                            <input type="number" id="radiatorClearanceRight" value="150" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                    </div>

                    <button class="btn btn-secondary" onclick="updateRadiatorDisplay()" style="margin-top: 15px;">
                        üîÑ Update Display
                    </button>

                    <button class="btn btn-secondary" id="downloadRadiatorMarkupBtn" onclick="downloadCurrentCanvas('radiator-markup.png')" style="margin-top: 10px; display: none;">
                        üíæ Download Image with Radiator Markup
                    </button>
                </div>
            </div>

            <div id="cylinderEditingSection" style="display: none;">
                <div class="instructions">
                    <h3>Select Cylinder</h3>
                    <p>Choose the cylinder brand and model:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="cylinderBrandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateCylinderModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="cylinderModelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model:</strong>
                        <select id="cylinderModelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="displayCylinderDetails()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>

                    <div id="cylinderDetailsDisplay" style="display: none; margin-top: 20px; background: white; padding: 15px; border-radius: 8px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">Cylinder Details</h4>
                        <div id="cylinderDetailsList"></div>
                    </div>
                </div>

                <button class="btn" id="placeCylinderBtn" onclick="enableCylinderPlacement()" style="margin-top: 10px; display: none;">
                    üìç Place Cylinder on Image
                </button>

                <button class="btn btn-secondary" id="downloadCylinderMarkupBtn" onclick="downloadCurrentCanvas('cylinder-markup.png')" style="margin-top: 10px; display: none;">
                    üíæ Download Image with Cylinder Markup
                </button>
            </div>

            <div id="flueEditingSection" style="display: none;">
                <div id="flueSpecialRulesSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                    <h4 style="color: #856404; margin-bottom: 10px;">‚ö†Ô∏è Special Flue Rules</h4>
                    <div id="flueSpecialRulesContent" style="color: #856404;"></div>
                </div>

                <div class="instructions">
                    <h3>Select Boiler Brand & Model</h3>
                    <p>Choose the boiler brand and model for accurate flue clearance requirements:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="flueBrandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateFlueModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="flueModelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model/Range:</strong>
                        <select id="flueModelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="displayFlueClearances()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>

                    <div id="flueClearancesDisplay" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">üìè Clearance Requirements</h4>
                        <div id="flueClearancesList" style="background: white; padding: 15px; border-radius: 8px;"></div>
                    </div>
                </div>
            </div>

            <div id="verticalFlueEditingSection" style="display: none;">
                <div id="verticalFlueSpecialRulesSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                    <h4 style="color: #856404; margin-bottom: 10px;">‚ö†Ô∏è Special Vertical Flue Rules</h4>
                    <div id="verticalFlueSpecialRulesContent" style="color: #856404;"></div>
                </div>

                <div class="instructions">
                    <h3>Select Boiler Brand & Model</h3>
                    <p>Choose the boiler brand and model for accurate vertical flue clearance requirements:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="verticalFlueBrandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateVerticalFlueModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="verticalFlueModelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model/Range:</strong>
                        <select id="verticalFlueModelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="displayVerticalFlueClearances()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>

                    <div id="verticalFlueClearancesDisplay" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">üìè Vertical Flue Clearance Requirements</h4>
                        <div id="verticalFlueClearancesList" style="background: white; padding: 15px; border-radius: 8px;"></div>
                    </div>
                </div>
            </div>

            <div id="obstacleMarkingSection" style="display: none;">
                <div class="instructions">
                    <h3>Step 4: Mark Obstacles</h3>
                    <p>Use auto-detection or manually mark obstacles on the image:</p>
                </div>

                <div class="status" id="markingStatus">
                    Select an obstacle type below to start marking
                </div>

                <!-- Auto-detection buttons -->
                <div style="margin-bottom: 20px; padding: 15px; background: #f7fafc; border-radius: 8px; border-left: 4px solid #48bb78;">
                    <h4 style="color: #2d3748; margin-bottom: 10px;">ü§ñ Auto-Detection</h4>
                    <p style="font-size: 13px; color: #4a5568; margin-bottom: 10px;">Automatically detect objects in the image. Try <strong>Enhanced Auto-Detect</strong> to identify windows (opening/fixed), flues, pipes, and vents with user confirmation:</p>
                    <div class="button-group">
                        <button type="button" class="btn" onclick="runAutoDetectWindows()" style="background: #48bb78;">
                            ü™ü Auto-Detect Windows
                        </button>
                        <button type="button" class="btn" onclick="runAutoDetectCircularObjects()" style="background: #48bb78;">
                            ‚≠ï Auto-Detect Circular Objects
                        </button>
                        <button type="button" class="btn" onclick="runAutoDetectAll()" style="background: #667eea;">
                            üîç Auto-Detect All (Basic)
                        </button>
                        <button type="button" class="btn" onclick="runAutoDetectAllEnhanced()" style="background: #805ad5;">
                            ‚ú® Enhanced Auto-Detect (Windows, Flues, Pipes, Vents)
                        </button>
                    </div>
                    <div class="status" id="autoDetectionStatus" style="display: none; margin-top: 10px;">
                        Detection in progress...
                    </div>
                </div>

                <!-- Manual marking buttons -->
                <h4 style="color: #2d3748; margin-bottom: 10px;">‚úèÔ∏è Manual Marking</h4>
                <div class="button-group" id="obstacleButtonsContainer">
                    <!-- Buttons will be populated dynamically based on flue type -->
                </div>

                <div id="obstaclesList" style="display: none;">
                    <h4 style="margin-top: 20px; color: #667eea;">Marked Obstacles:</h4>
                    <div id="obstaclesListContent"></div>
                </div>

                <button class="btn" id="calculateBtn" onclick="calculateClearances()" style="margin-top: 20px; display: none;">
                    üîç Calculate Clearance Zones
                </button>

                <div id="flueOutputSection" style="display: none; margin-top: 20px;">
                    <div class="instructions">
                        <h3>Generate Outputs</h3>
                        <p>Generate clearance visualizations and written guidance:</p>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="generateStandardFlueOutput()">
                            üìä Standard Flue Output
                        </button>
                        <button class="btn btn-secondary" onclick="generatePlumeManagementOutput()">
                            üí® Plume Management Output
                        </button>
                    </div>

                    <button type="button" class="btn" onclick="generateWrittenGuidance()" style="margin-top: 10px;">
                        üìù Generate Written Guidance (AI)
                    </button>

                    <div id="writtenGuidanceSection" style="display: none; background: #f7fafc; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">üìù Installation Guidance</h4>
                        <div id="writtenGuidanceContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                    </div>

                    <div id="outputImagesSection" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">Generated Outputs</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <h5 style="margin-bottom: 10px;">Standard Flue</h5>
                                <canvas id="standardFlueCanvas" style="width: 100%; border: 2px solid #667eea; border-radius: 8px;"></canvas>
                                <button class="btn btn-secondary" onclick="downloadCanvas('standardFlueCanvas', 'standard-flue.png')" style="margin-top: 10px; width: 100%;">
                                    üíæ Download
                                </button>
                            </div>
                            <div>
                                <h5 style="margin-bottom: 10px;">Plume Management</h5>
                                <canvas id="plumeCanvas" style="width: 100%; border: 2px solid #667eea; border-radius: 8px;"></canvas>
                                <button class="btn btn-secondary" onclick="downloadCanvas('plumeCanvas', 'plume-management.png')" style="margin-top: 10px; width: 100%;">
                                    üíæ Download
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="status" id="analysisStatus"></div>

            <div id="objectKey" style="display: none; background: #f7fafc; padding: 20px; border-radius: 8px; margin: 15px 0;">
            </div>

            <div class="results-panel" id="resultsPanel">
                <div class="zone-legend">
                    <div class="zone-legend-item">
                        <div class="zone-color-box zone-red"></div>
                        <span>Prohibited Zone</span>
                    </div>
                    <div class="zone-legend-item">
                        <div class="zone-color-box zone-green"></div>
                        <span>Safe Zone</span>
                    </div>
                </div>

                <div style="margin-top: 15px; padding: 10px; background: #f7fafc; border-radius: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 500;">
                        <input type="checkbox" id="plumeKitToggle" onchange="togglePlumeKitMode()" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span>üí® Plume Kit Mode (50% reduced clearances)</span>
                    </label>
                </div>

                <div id="complianceResult" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CARD_WIDTH_MM = 85.6;
        const CARD_HEIGHT_MM = 53.98;

        // UK Standard Brick Dimensions (in mm)
        const BRICK_LENGTH_MM = 215;    // Stretcher face (longest)
        const BRICK_WIDTH_MM = 102.5;   // Header face
        const BRICK_HEIGHT_MM = 65;     // Bed (thickness)

        // Brand-specific clearance rules (in mm from obstruction edge to flue/boiler center)
        // These are fallback/flue rules - boiler rules will be loaded from CSV
        const CLEARANCE_RULES = {
            worcester: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            vaillant: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            ideal: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            "glow-worm": {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            viessmann: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            }
        };

        // Boiler clearance data loaded from CSV
        let BOILER_CLEARANCES_DATA = [];
        let AVAILABLE_BRANDS = [];
        let AVAILABLE_MODELS = {};

        // Flue clearance data loaded from CSV
        let FLUE_CLEARANCES_DATA = [];
        let FLUE_AVAILABLE_BRANDS = [];
        let FLUE_AVAILABLE_MODELS = {};

        // Vertical Flue clearance data loaded from CSV
        let VERTICAL_FLUE_CLEARANCES_DATA = [];
        let VERTICAL_FLUE_AVAILABLE_BRANDS = [];
        let VERTICAL_FLUE_AVAILABLE_MODELS = {};

        // Cylinder data loaded from CSV
        let CYLINDERS_DATA = [];
        let CYLINDER_AVAILABLE_BRANDS = [];
        let CYLINDER_AVAILABLE_MODELS = {};

        // Core state
        const state = {
            photo: null,
            photoBase64: null,
            canvas: null,
            ctx: null,
            calibrationPoints: [],
            isCalibrating: false,
            pxPerMM: null,
            position: null,
            canvasScale: 1,
            mode: null,
            flueType: null, // 'horizontal' or 'vertical'
            calibrationMode: 'card', // 'card' or 'brick'
            brickOrientation: 'length', // 'length', 'width', or 'height'
            obstacles: [], // Manual obstacles marked by user
            markingMode: null, // Current obstacle type being marked
            markingPoints: [], // Points collected during marking
            zones: null,
            detectedObjects: [], // Objects detected by OpenAI
            boilerDimensions: null,
            boilerClearances: null,
            // Zoom and pan state
            zoomLevel: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            lastPanX: 0,
            lastPanY: 0,
            // Plume kit mode
            plumeKitMode: false,
            // Long press move state
            isLongPressing: false,
            longPressTimer: null,
            isMovingObject: false,
            // iPad mode
            isIPad: false
        };

        // Detect if device is iPad
        function detectIPad() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            const isIPadUA = /iPad/.test(userAgent) ||
                           (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isTabletSize = window.innerWidth >= 768 && window.innerWidth <= 1024;
            state.isIPad = isIPadUA || isTabletSize;
            console.log('iPad detected:', state.isIPad);
            return state.isIPad;
        }

        // Setup iPad layout
        function setupIPadLayout() {
            if (!state.isIPad) return;

            const container = document.querySelector('.container');
            const canvasContainer = document.getElementById('canvasContainer');
            const analysisCard = document.getElementById('analysisCard');

            // Create wrapper for iPad layout
            let ipadWrapper = document.getElementById('ipadLayoutWrapper');
            if (!ipadWrapper) {
                ipadWrapper = document.createElement('div');
                ipadWrapper.id = 'ipadLayoutWrapper';
                ipadWrapper.className = 'ipad-layout';

                // Create controls panel
                const controlsPanel = document.createElement('div');
                controlsPanel.id = 'controlsPanel';
                controlsPanel.className = 'controls-panel';

                // Move canvas and controls into wrapper
                if (canvasContainer && analysisCard) {
                    container.insertBefore(ipadWrapper, analysisCard);
                    ipadWrapper.appendChild(canvasContainer);
                    ipadWrapper.appendChild(controlsPanel);
                    controlsPanel.appendChild(analysisCard);
                }
            }
        }

        // Auto-advance to next step on iPad
        function autoAdvanceOnIPad(delay = 500) {
            if (!state.isIPad) return;

            setTimeout(() => {
                // Scroll to relevant section
                const activeSection = document.querySelector('[style*="display: block"]:not(#canvasContainer)');
                if (activeSection) {
                    activeSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, delay);
        }

        // CSV Parsing and Loading Functions
        async function loadBoilerClearances() {
            try {
                const response = await fetch('data/boiler-clearances.csv');
                const csvText = await response.text();
                parseBoilerClearancesCSV(csvText);
            } catch (error) {
                console.error('Failed to load boiler clearances CSV:', error);
                // Fallback to hardcoded values is already in CLEARANCE_RULES
            }
        }

        function parseBoilerClearancesCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            BOILER_CLEARANCES_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Parse CSV line (handle quoted fields)
                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    type: fields[0],
                    brand: fields[1],
                    model: fields[2],
                    clearanceArea: fields[3],
                    clearanceMM: fields[4],
                    notes: fields[5] || ''
                };

                BOILER_CLEARANCES_DATA.push(entry);

                // Track unique brands
                if (entry.brand) {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model && entry.model !== 'Notes') {
                        modelsMap[entry.brand].add(entry.model);
                    }
                }
            }

            AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded boiler clearances:', {
                entries: BOILER_CLEARANCES_DATA.length,
                brands: AVAILABLE_BRANDS,
                models: AVAILABLE_MODELS
            });
        }

        function parseCSVLine(line) {
            const fields = [];
            let currentField = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i < line.length - 1 ? line[i + 1] : null;

                if (char === '"') {
                    // Handle escaped quotes ("")
                    if (inQuotes && nextChar === '"') {
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    fields.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }

            fields.push(currentField.trim());
            return fields;
        }

        function getBoilerClearancesForModel(brand, model) {
            // Normalize brand name (case-insensitive)
            const normalizedBrand = brand.toLowerCase();

            const entries = BOILER_CLEARANCES_DATA.filter(entry =>
                entry.brand.toLowerCase() === normalizedBrand &&
                entry.model === model
            );

            // Convert to clearances object
            const clearances = {
                top: null,
                bottom: null,
                left: null,
                right: null,
                front: null,
                rear: null,
                notes: []
            };

            entries.forEach(entry => {
                const area = entry.clearanceArea.toLowerCase();
                const value = entry.clearanceMM;

                // Parse clearance value (handle ranges like "170/210")
                const numericValue = value ? parseFloat(value.split('/')[0]) : null;

                if (area.includes('above') || area.includes('top')) {
                    clearances.top = numericValue;
                } else if (area.includes('below') || area.includes('bottom')) {
                    clearances.bottom = numericValue;
                } else if (area.includes('side') || area.includes('left')) {
                    clearances.left = numericValue;
                    clearances.right = numericValue; // Assume symmetric unless specified
                } else if (area.includes('front')) {
                    clearances.front = numericValue;
                } else if (area.includes('rear')) {
                    clearances.rear = numericValue;
                }

                // Collect notes
                if (entry.notes || area.includes('notes')) {
                    clearances.notes.push(entry.notes || value);
                }
            });

            return clearances;
        }

        // Flue Clearance CSV Functions
        async function loadFlueClearances() {
            try {
                const response = await fetch('data/flue-clearances.csv');
                const csvText = await response.text();
                parseFlueClearancesCSV(csvText);
            } catch (error) {
                console.error('Failed to load flue clearances CSV:', error);
            }
        }

        function parseFlueClearancesCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            FLUE_CLEARANCES_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    type: fields[0],
                    brand: fields[1],
                    model: fields[2],
                    position: fields[3],
                    clearanceMM: parseInt(fields[4]) || 0,
                    specialRules: fields[5] || ''
                };

                FLUE_CLEARANCES_DATA.push(entry);

                // Track unique brands
                if (entry.brand && entry.brand !== 'Any') {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model) {
                        modelsMap[entry.brand].add(entry.model);
                    }
                }
            }

            FLUE_AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            FLUE_AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                FLUE_AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded flue clearances:', {
                entries: FLUE_CLEARANCES_DATA.length,
                brands: FLUE_AVAILABLE_BRANDS,
                models: FLUE_AVAILABLE_MODELS
            });
        }

        function getFlueClearancesForModel(brand, model) {
            const normalizedBrand = brand.toLowerCase();
            const normalizedModel = model.toLowerCase();

            const entries = FLUE_CLEARANCES_DATA.filter(entry => {
                const entryBrand = entry.brand.toLowerCase();
                const entryModel = entry.model.toLowerCase();

                return (entry.brand === 'Any' || entryBrand === normalizedBrand) &&
                       (entryModel === normalizedModel || entryModel.includes(normalizedModel));
            });

            // Group by position/scenario
            const clearances = {};
            entries.forEach(entry => {
                if (!clearances[entry.position]) {
                    clearances[entry.position] = {
                        clearanceMM: entry.clearanceMM,
                        specialRules: entry.specialRules
                    };
                }
            });

            return clearances;
        }

        // Vertical Flue Clearance CSV Functions
        async function loadVerticalFlueClearances() {
            try {
                const response = await fetch('data/vertical-flue-clearances.csv');
                const csvText = await response.text();
                parseVerticalFlueClearancesCSV(csvText);
            } catch (error) {
                console.error('Failed to load vertical flue clearances CSV:', error);
            }
        }

        function parseVerticalFlueClearancesCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            VERTICAL_FLUE_CLEARANCES_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    type: fields[0],
                    brand: fields[1],
                    model: fields[2],
                    position: fields[3],
                    clearanceMM: parseInt(fields[4]) || 0,
                    specialRules: fields[5] || ''
                };

                VERTICAL_FLUE_CLEARANCES_DATA.push(entry);

                // Track unique brands
                if (entry.brand && entry.brand !== 'Any') {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model) {
                        modelsMap[entry.brand].add(entry.model);
                    }
                }
            }

            VERTICAL_FLUE_AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            VERTICAL_FLUE_AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                VERTICAL_FLUE_AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded vertical flue clearances:', {
                entries: VERTICAL_FLUE_CLEARANCES_DATA.length,
                brands: VERTICAL_FLUE_AVAILABLE_BRANDS,
                models: VERTICAL_FLUE_AVAILABLE_MODELS
            });
        }

        function getVerticalFlueClearancesForModel(brand, model) {
            const normalizedBrand = brand.toLowerCase();
            const normalizedModel = model.toLowerCase();

            const entries = VERTICAL_FLUE_CLEARANCES_DATA.filter(entry => {
                const entryBrand = entry.brand.toLowerCase();
                const entryModel = entry.model.toLowerCase();

                return (entry.brand === 'Any' || entryBrand === normalizedBrand) &&
                       (entryModel === normalizedModel || entryModel.includes(normalizedModel));
            });

            // Group by position/scenario
            const clearances = {};
            entries.forEach(entry => {
                if (!clearances[entry.position]) {
                    clearances[entry.position] = {
                        clearanceMM: entry.clearanceMM,
                        specialRules: entry.specialRules
                    };
                }
            });

            return clearances;
        }

        // Cylinder loading functions
        async function loadCylinders() {
            try {
                const response = await fetch('data/cylinders.csv');
                const csvText = await response.text();
                parseCylindersCSV(csvText);
            } catch (error) {
                console.error('Failed to load cylinders CSV:', error);
            }
        }

        function parseCylindersCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            CYLINDERS_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    brand: fields[0],
                    type: fields[1],
                    model: fields[2],
                    volume: fields[3],
                    dimensions: fields[4],
                    price: fields[5] || '',
                    code: fields[6] || ''
                };

                CYLINDERS_DATA.push(entry);

                // Track unique brands
                if (entry.brand) {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model) {
                        const key = `${entry.type} - ${entry.model} - ${entry.volume}`;
                        modelsMap[entry.brand].add(key);
                    }
                }
            }

            CYLINDER_AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            CYLINDER_AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                CYLINDER_AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded cylinders:', {
                entries: CYLINDERS_DATA.length,
                brands: CYLINDER_AVAILABLE_BRANDS,
                models: CYLINDER_AVAILABLE_MODELS
            });
        }

        function getCylinderByKey(brand, modelKey) {
            return CYLINDERS_DATA.find(entry => {
                const key = `${entry.type} - ${entry.model} - ${entry.volume}`;
                return entry.brand === brand && key === modelKey;
            });
        }

        // Parse dimensions from format like "1200h x 520dia"
        function parseCylinderDimensions(dimStr) {
            if (!dimStr) return null;

            const heightMatch = dimStr.match(/(\d+)h/);
            const diameterMatch = dimStr.match(/(\d+)dia/);

            if (heightMatch && diameterMatch) {
                return {
                    height: parseInt(heightMatch[1]),
                    diameter: parseInt(diameterMatch[1])
                };
            }
            return null;
        }

        // Initialize - Load CSV data on page load
        loadBoilerClearances();
        loadFlueClearances();
        loadVerticalFlueClearances();
        loadCylinders();

        // Detect iPad and setup layout
        detectIPad();
        window.addEventListener('resize', () => {
            detectIPad();
            if (state.isIPad && state.canvas) {
                setupIPadLayout();
            }
        });

        document.getElementById('photoInput').addEventListener('change', handlePhotoUpload);

        function openCamera() {
            const input = document.getElementById('photoInput');
            input.setAttribute('capture', 'environment');
            input.click();
            setTimeout(() => input.removeAttribute('capture'), 100);
        }

        async function handlePhotoUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const originalDataUrl = event.target.result;
                const img = new Image();
                img.onload = async function() {
                    const { image: processedImg, dataUrl } = await prepareImage(img, originalDataUrl);

                    state.photoBase64 = dataUrl;
                    state.photo = processedImg;

                    setupCanvas(processedImg);
                    document.getElementById('canvasContainer').classList.add('active');
                    document.getElementById('calibrationCard').style.display = 'block';
                };
                img.src = originalDataUrl;
            };
            reader.readAsDataURL(file);
        }

        // Reduce very large photos to prevent mobile browsers from crashing while processing
        function prepareImage(img, fallbackDataUrl) {
            return new Promise((resolve) => {
                const MAX_DIMENSION = 2000;
                const largestSide = Math.max(img.width, img.height);

                // If the image is already within limits, reuse it as-is
                if (largestSide <= MAX_DIMENSION) {
                    resolve({ image: img, dataUrl: fallbackDataUrl });
                    return;
                }

                const scale = MAX_DIMENSION / largestSide;
                const targetWidth = Math.round(img.width * scale);
                const targetHeight = Math.round(img.height * scale);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = targetWidth;
                tempCanvas.height = targetHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0, targetWidth, targetHeight);

                const scaledDataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                const scaledImg = new Image();
                scaledImg.onload = () => resolve({ image: scaledImg, dataUrl: scaledDataUrl });
                scaledImg.src = scaledDataUrl;
            });
        }

        function setupCanvas(img) {
            const canvas = document.getElementById('photoCanvas');

            canvas.width = img.width;
            canvas.height = img.height;

            state.canvas = canvas;
            state.ctx = canvas.getContext('2d');

            state.ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const rect = canvas.getBoundingClientRect();
            state.canvasScale = canvas.width / rect.width;

            // Setup pan controls, long press move, and show zoom controls
            setupPanControls();
            setupLongPressMove();
            document.getElementById('zoomControls').style.display = 'block';

            // Setup iPad layout if on iPad
            if (state.isIPad) {
                setupIPadLayout();
            }
        }

        function setCalibrationMode(mode) {
            state.calibrationMode = mode;

            // Update button styles
            const cardBtn = document.getElementById('cardModeBtn');
            const brickBtn = document.getElementById('brickModeBtn');

            if (mode === 'card') {
                cardBtn.style.background = '#667eea';
                cardBtn.classList.remove('btn-secondary');
                brickBtn.style.background = '';
                brickBtn.classList.add('btn-secondary');
                document.getElementById('brickOrientationSelector').style.display = 'none';
                document.getElementById('autoDetectLabel').textContent = 'Card';
            } else {
                brickBtn.style.background = '#667eea';
                brickBtn.classList.remove('btn-secondary');
                cardBtn.style.background = '';
                cardBtn.classList.add('btn-secondary');
                document.getElementById('brickOrientationSelector').style.display = 'block';
                document.getElementById('autoDetectLabel').textContent = 'Brick';
            }

            // Reset calibration if already calibrated
            if (state.pxPerMM) {
                resetCalibration();
            }
        }

        function setBrickOrientation(orientation) {
            state.brickOrientation = orientation;

            // Reset calibration if already calibrated
            if (state.pxPerMM) {
                resetCalibration();
            }
        }

        function autoDetectReference() {
            if (state.calibrationMode === 'card') {
                autoDetectCard();
            } else {
                autoDetectBrick();
            }
        }

        function startManualCalibration() {
            state.isCalibrating = true;
            state.calibrationPoints = [];
            updatePointsDisplay();

            document.getElementById('pointsDisplay').style.display = 'block';

            const refObject = state.calibrationMode === 'brick' ? 'brick' : 'card';
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.classList.remove('warning');
            status.textContent = `Tap corner 1/4: Top-Left corner of ${refObject}`;

            state.canvas.addEventListener('click', handleCalibrationClick);
        }

        function autoDetectCard() {
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.textContent = 'üîç Searching for blue card...';
            
            const imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            const data = imageData.data;
            
            const bluePixels = [];
            
            for (let y = 0; y < state.canvas.height; y += 2) {
                for (let x = 0; x < state.canvas.width; x += 2) {
                    const i = (y * state.canvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (b > r + 30 && b > g + 30 && b > 100) {
                        bluePixels.push({x, y});
                    }
                }
            }
            
            if (bluePixels.length < 100) {
                status.classList.add('warning');
                status.textContent = '‚ùå Could not find blue card. Try manual calibration or adjust lighting.';
                return;
            }
            
            const minX = Math.min(...bluePixels.map(p => p.x));
            const maxX = Math.max(...bluePixels.map(p => p.x));
            const minY = Math.min(...bluePixels.map(p => p.y));
            const maxY = Math.max(...bluePixels.map(p => p.y));
            
            const width = maxX - minX;
            const height = maxY - minY;
            const aspectRatio = width / height;
            const expectedRatio = CARD_WIDTH_MM / CARD_HEIGHT_MM;
            
            if (Math.abs(aspectRatio - expectedRatio) > 0.3) {
                status.classList.add('warning');
                status.textContent = `‚ö†Ô∏è Found blue region but shape doesn't match card (ratio: ${aspectRatio.toFixed(2)}). Try manual calibration.`;
                
                state.ctx.strokeStyle = '#f56565';
                state.ctx.lineWidth = 3;
                state.ctx.strokeRect(minX, minY, width, height);
                return;
            }
            
            state.calibrationPoints = [
                {x: minX, y: minY},
                {x: maxX, y: minY},
                {x: maxX, y: maxY},
                {x: minX, y: maxY}
            ];
            
            status.textContent = '‚úÖ Card detected! Calculating scale...';

            setTimeout(() => calculateCalibration(), 500);
        }

        function autoDetectBrick() {
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.textContent = 'üîç Searching for brick...';

            const imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            const data = imageData.data;

            // Create a binary mask for brick-colored pixels
            const brickMask = new Uint8Array(state.canvas.width * state.canvas.height);

            // Enhanced brick color detection for red/orange/brown bricks
            // Supports various brick types: red clay, orange, buff, brown
            for (let y = 0; y < state.canvas.height; y += 2) {
                for (let x = 0; x < state.canvas.width; x += 2) {
                    const i = (y * state.canvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Calculate color characteristics
                    const brightness = (r + g + b) / 3;
                    const redDominance = r - Math.max(g, b);

                    // Red/orange brick detection (most common)
                    const isRedBrick = r > g + 20 && r > b + 30 &&
                                      r > 80 && r < 220 &&
                                      g > 30 && g < 180 &&
                                      b > 20 && b < 150 &&
                                      brightness > 60 && brightness < 180;

                    // Buff/yellow brick detection
                    const isBuffBrick = r > 120 && g > 100 && b > 60 &&
                                       r < 200 && g < 180 && b < 130 &&
                                       r > b + 20 && g > b + 15 &&
                                       Math.abs(r - g) < 40;

                    // Brown brick detection
                    const isBrownBrick = r > g && g > b &&
                                        r > 60 && r < 150 &&
                                        g > 40 && g < 120 &&
                                        b > 20 && b < 100 &&
                                        redDominance > 15;

                    if (isRedBrick || isBuffBrick || isBrownBrick) {
                        const maskIdx = y * state.canvas.width + x;
                        brickMask[maskIdx] = 1;
                    }
                }
            }

            // Cluster brick pixels into individual regions using connected components
            const brickRegions = findConnectedRegions(brickMask, state.canvas.width, state.canvas.height);

            if (brickRegions.length === 0) {
                status.classList.add('warning');
                status.textContent = '‚ùå Could not find brick. Try manual calibration, adjust lighting, or check brick orientation.';
                return;
            }

            // Get expected dimensions based on brick orientation
            let expectedWidth, expectedHeight, expectedRatio;
            if (state.brickOrientation === 'length') {
                // Stretcher: 215mm √ó 65mm
                expectedWidth = BRICK_LENGTH_MM;
                expectedHeight = BRICK_HEIGHT_MM;
            } else if (state.brickOrientation === 'width') {
                // Header: 102.5mm √ó 65mm
                expectedWidth = BRICK_WIDTH_MM;
                expectedHeight = BRICK_HEIGHT_MM;
            } else {
                // Bed: 215mm √ó 102.5mm
                expectedWidth = BRICK_LENGTH_MM;
                expectedHeight = BRICK_WIDTH_MM;
            }
            expectedRatio = expectedWidth / expectedHeight;

            // Evaluate each region and score them
            const candidates = brickRegions.map(region => {
                const width = region.maxX - region.minX;
                const height = region.maxY - region.minY;
                const area = width * height;
                const aspectRatio = width / height;
                const pixelDensity = (region.pixelCount * 4) / area; // *4 because we skip pixels

                // Calculate scores
                const ratioError = Math.abs(aspectRatio - expectedRatio);
                const ratioScore = Math.max(0, 1 - ratioError / expectedRatio);

                // Prefer larger regions
                const sizeScore = Math.min(1, area / 10000); // Normalize to typical brick size

                // Prefer centered regions
                const centerX = (region.minX + region.maxX) / 2;
                const centerY = (region.minY + region.maxY) / 2;
                const imageCenterX = state.canvas.width / 2;
                const imageCenterY = state.canvas.height / 2;
                const distFromCenter = Math.sqrt(
                    Math.pow(centerX - imageCenterX, 2) +
                    Math.pow(centerY - imageCenterY, 2)
                );
                const maxDist = Math.sqrt(
                    Math.pow(state.canvas.width / 2, 2) +
                    Math.pow(state.canvas.height / 2, 2)
                );
                const centerScore = Math.max(0, 1 - distFromCenter / maxDist);

                // Prefer solid regions
                const densityScore = Math.min(1, pixelDensity / 0.5);

                // Weighted combined score
                const totalScore = ratioScore * 0.5 + sizeScore * 0.2 + centerScore * 0.1 + densityScore * 0.2;

                return {
                    region,
                    aspectRatio,
                    ratioError,
                    pixelDensity,
                    totalScore,
                    width,
                    height
                };
            });

            // Sort by score (best first)
            candidates.sort((a, b) => b.totalScore - a.totalScore);

            // Select best candidate with reasonable constraints
            const ratioTolerance = 0.5;
            const bestCandidate = candidates.find(c =>
                c.ratioError < ratioTolerance &&
                c.width >= 50 && c.height >= 30 &&
                c.pixelDensity >= 0.25
            );

            if (!bestCandidate) {
                status.classList.add('warning');

                // Draw all detected regions in red for debugging
                state.ctx.strokeStyle = '#f56565';
                state.ctx.lineWidth = 2;
                candidates.slice(0, 5).forEach(c => {
                    state.ctx.strokeRect(c.region.minX, c.region.minY, c.width, c.height);
                });

                if (candidates.length > 0) {
                    const best = candidates[0];
                    status.textContent = `‚ö†Ô∏è Found ${brickRegions.length} brick region(s) but none match expected ${expectedRatio.toFixed(2)}:1 ratio. Best: ${best.aspectRatio.toFixed(2)}:1. Try manual calibration or check brick orientation.`;
                } else {
                    status.textContent = '‚ùå Could not find suitable brick. Try manual calibration, adjust lighting, or check brick orientation.';
                }
                return;
            }

            // Success - use best candidate
            const brick = bestCandidate.region;

            state.calibrationPoints = [
                {x: brick.minX, y: brick.minY},
                {x: brick.maxX, y: brick.minY},
                {x: brick.maxX, y: brick.maxY},
                {x: brick.minX, y: brick.maxY}
            ];

            // Visual feedback - draw green box around selected brick
            state.ctx.strokeStyle = '#48bb78';
            state.ctx.lineWidth = 3;
            state.ctx.strokeRect(brick.minX, brick.minY, bestCandidate.width, bestCandidate.height);

            // Draw light boxes around other candidates for context
            if (candidates.length > 1) {
                state.ctx.strokeStyle = 'rgba(72, 187, 120, 0.3)';
                state.ctx.lineWidth = 1;
                candidates.slice(1, Math.min(5, candidates.length)).forEach(c => {
                    state.ctx.strokeRect(c.region.minX, c.region.minY, c.width, c.height);
                });
            }

            const numDetected = brickRegions.length;
            status.textContent = numDetected > 1
                ? `‚úÖ Detected ${numDetected} bricks, selected best match! Calculating scale...`
                : '‚úÖ Brick detected! Calculating scale...';

            setTimeout(() => calculateCalibration(), 500);
        }

        // Helper function to find connected regions of brick pixels
        function findConnectedRegions(mask, width, height) {
            const visited = new Uint8Array(width * height);
            const regions = [];
            const minRegionSize = 100; // Minimum pixels to be considered a region

            function floodFill(startX, startY) {
                const stack = [{x: startX, y: startY}];
                const pixels = [];
                let minX = startX, maxX = startX;
                let minY = startY, maxY = startY;

                while (stack.length > 0) {
                    const {x, y} = stack.pop();
                    const idx = y * width + x;

                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    if (visited[idx] || !mask[idx]) continue;

                    visited[idx] = 1;
                    pixels.push({x, y});

                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);

                    // Check 4-connected neighbors (skip diagonal for better separation)
                    stack.push({x: x + 2, y});
                    stack.push({x: x - 2, y});
                    stack.push({x, y: y + 2});
                    stack.push({x, y: y - 2});
                }

                return {pixels, minX, maxX, minY, maxY};
            }

            // Scan for unvisited brick pixels
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    const idx = y * width + x;
                    if (mask[idx] && !visited[idx]) {
                        const region = floodFill(x, y);
                        if (region.pixels.length >= minRegionSize) {
                            regions.push({
                                minX: region.minX,
                                maxX: region.maxX,
                                minY: region.minY,
                                maxY: region.maxY,
                                pixelCount: region.pixels.length
                            });
                        }
                    }
                }
            }

            return regions;
        }

        // Auto-detect windows using edge detection and rectangular shape analysis
        function autoDetectWindows() {
            // Validate canvas context
            if (!state.ctx || !state.canvas) {
                throw new Error('Canvas not initialized');
            }

            let imageData;
            try {
                imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            } catch (error) {
                console.error('Failed to get image data:', error);
                throw new Error('Unable to access image data. This may occur on mobile devices with memory constraints.');
            }

            const edges = detectEdges(imageData);
            const rectangles = findRectangularShapes(edges, state.canvas.width, state.canvas.height);

            // Filter for window-like rectangles
            const windows = rectangles.filter(rect => {
                const width = rect.maxX - rect.minX;
                const height = rect.maxY - rect.minY;
                const area = width * height;
                const aspectRatio = width / height;

                // Windows are typically:
                // - Medium to large size (not tiny)
                // - Rectangular (aspect ratio between 0.5 and 3.0)
                // - Have strong edges
                return area > 5000 &&
                       aspectRatio > 0.5 && aspectRatio < 3.0 &&
                       rect.edgeStrength > 0.4;
            });

            return windows.map(w => ({
                type: 'window',
                x: w.minX,
                y: w.minY,
                width: w.maxX - w.minX,
                height: w.maxY - w.minY,
                confidence: w.edgeStrength
            }));
        }

        // Auto-detect circular objects (flues, vents, etc) using Hough-like circle detection
        function autoDetectCircularObjects() {
            // Validate canvas context
            if (!state.ctx || !state.canvas) {
                throw new Error('Canvas not initialized');
            }

            let imageData;
            try {
                imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            } catch (error) {
                console.error('Failed to get image data:', error);
                throw new Error('Unable to access image data. This may occur on mobile devices with memory constraints.');
            }

            const edges = detectEdges(imageData);
            const circles = findCircularShapes(edges, state.canvas.width, state.canvas.height);

            // Filter for flue-like circles
            const circularObjects = circles.filter(circle => {
                const diameter = circle.radius * 2;

                // Typical flue diameter is 100-150mm, but could vary
                // Filter for reasonable sizes
                return diameter > 30 && diameter < 400 && circle.confidence > 0.5;
            });

            return circularObjects.map(c => ({
                type: 'flue',
                x: c.centerX - c.radius,
                y: c.centerY - c.radius,
                width: c.radius * 2,
                height: c.radius * 2,
                centerX: c.centerX,
                centerY: c.centerY,
                radius: c.radius,
                confidence: c.confidence
            }));
        }

        // Edge detection using Sobel operator
        function detectEdges(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;

            // Check for large images on mobile devices
            const pixelCount = width * height;
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile && pixelCount > 4000000) { // > ~2000x2000
                console.warn('Large image on mobile device may cause performance issues');
            }

            let edges;
            try {
                edges = new Float32Array(width * height);
            } catch (error) {
                console.error('Failed to allocate memory for edge detection:', error);
                throw new Error('Insufficient memory for image processing. Try using a smaller image.');
            }

            // Sobel kernels
            const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
            const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

            // Convert to grayscale and apply Sobel operator
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;

                    // Apply kernel
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                            const kernelIdx = (ky + 1) * 3 + (kx + 1);

                            gx += gray * sobelX[kernelIdx];
                            gy += gray * sobelY[kernelIdx];
                        }
                    }

                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    edges[y * width + x] = magnitude;
                }
            }

            return edges;
        }

        // Find rectangular shapes from edge map
        function findRectangularShapes(edges, width, height) {
            const threshold = 30;
            const rectangles = [];

            // Create binary edge map
            const edgeMask = new Uint8Array(edges.length);
            for (let i = 0; i < edges.length; i++) {
                edgeMask[i] = edges[i] > threshold ? 1 : 0;
            }

            // Use connected components to find edge regions
            const edgeRegions = findConnectedRegions(edgeMask, width, height);

            // Analyze each region for rectangularity
            for (const region of edgeRegions) {
                const w = region.maxX - region.minX;
                const h = region.maxY - region.minY;
                const area = w * h;

                if (area < 2000) continue;

                // Calculate edge density along rectangle perimeter
                const perimeter = 2 * (w + h);
                const edgeCount = region.pixelCount;
                const edgeStrength = Math.min(1, edgeCount / (perimeter * 0.3));

                rectangles.push({
                    minX: region.minX,
                    maxX: region.maxX,
                    minY: region.minY,
                    maxY: region.maxY,
                    edgeStrength
                });
            }

            return rectangles;
        }

        // Find circular shapes using accumulator-based approach (simplified Hough)
        function findCircularShapes(edges, width, height) {
            const threshold = 30;
            const circles = [];
            const minRadius = 15;
            const maxRadius = 200;
            const radiusStep = 5;

            // Sample edge points
            const edgePoints = [];
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    if (edges[y * width + x] > threshold) {
                        edgePoints.push({x, y});
                    }
                }
            }

            if (edgePoints.length < 50) return circles;

            // Accumulator for circle centers and radii
            const accumulator = new Map();

            // Vote for circle centers
            for (let i = 0; i < edgePoints.length; i += 3) {
                const p1 = edgePoints[i];

                for (let r = minRadius; r < maxRadius; r += radiusStep) {
                    // Try different angles
                    for (let angle = 0; angle < 360; angle += 45) {
                        const rad = (angle * Math.PI) / 180;
                        const cx = Math.round(p1.x - r * Math.cos(rad));
                        const cy = Math.round(p1.y - r * Math.sin(rad));

                        if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;

                        const key = `${cx},${cy},${r}`;
                        accumulator.set(key, (accumulator.get(key) || 0) + 1);
                    }
                }
            }

            // Find peaks in accumulator
            const candidates = [];
            for (const [key, votes] of accumulator.entries()) {
                const [cx, cy, r] = key.split(',').map(Number);
                const expectedVotes = (2 * Math.PI * r) / 8; // Expected votes for a full circle

                if (votes > expectedVotes * 0.3) {
                    candidates.push({
                        centerX: cx,
                        centerY: cy,
                        radius: r,
                        votes,
                        confidence: Math.min(1, votes / expectedVotes)
                    });
                }
            }

            // Non-maximum suppression - keep only best circles
            candidates.sort((a, b) => b.votes - a.votes);

            for (const candidate of candidates) {
                // Check if this circle overlaps with existing circles
                const overlaps = circles.some(c => {
                    const dist = Math.sqrt(
                        Math.pow(c.centerX - candidate.centerX, 2) +
                        Math.pow(c.centerY - candidate.centerY, 2)
                    );
                    return dist < (c.radius + candidate.radius) / 2;
                });

                if (!overlaps) {
                    circles.push(candidate);
                }

                if (circles.length >= 10) break;
            }

            return circles;
        }

        // Enhanced auto-detection with classification
        function autoDetectWindowsEnhanced() {
            // Validate canvas context
            if (!state.ctx || !state.canvas) {
                throw new Error('Canvas not initialized');
            }

            let imageData;
            try {
                imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            } catch (error) {
                console.error('Failed to get image data:', error);
                throw new Error('Unable to access image data. This may occur on mobile devices with memory constraints.');
            }

            const edges = detectEdges(imageData);
            const rectangles = findRectangularShapes(edges, state.canvas.width, state.canvas.height);

            // Filter for window-like rectangles
            const windows = rectangles.filter(rect => {
                const width = rect.maxX - rect.minX;
                const height = rect.maxY - rect.minY;
                const area = width * height;
                const aspectRatio = width / height;

                return area > 5000 &&
                       aspectRatio > 0.5 && aspectRatio < 3.0 &&
                       rect.edgeStrength > 0.4;
            });

            return windows.map(w => {
                const width = w.maxX - w.minX;
                const height = w.maxY - w.minY;

                // Classify as opening or fixed based on visual characteristics
                // Opening windows typically have visible handles, hinges, or divisions
                const windowType = classifyWindowType(imageData, w.minX, w.minY, width, height);

                return {
                    type: windowType,
                    x: w.minX,
                    y: w.minY,
                    width: width,
                    height: height,
                    confidence: w.edgeStrength
                };
            });
        }

        function classifyWindowType(imageData, x, y, width, height) {
            // Sample the window area to detect features
            const data = imageData.data;
            const imgWidth = imageData.width;

            // Check for internal divisions (handles, hinges, mullions)
            let internalEdgeCount = 0;
            const sampleSize = 5;

            // Sample internal area (avoid outer edges)
            for (let dy = height * 0.2; dy < height * 0.8; dy += sampleSize) {
                for (let dx = width * 0.2; dx < width * 0.8; dx += sampleSize) {
                    const px = Math.floor(x + dx);
                    const py = Math.floor(y + dy);
                    if (px >= 0 && px < imgWidth && py >= 0 && py < imageData.height) {
                        const idx = (py * imgWidth + px) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];

                        // Look for dark elements (handles, hinges, frames)
                        if (r < 80 && g < 80 && b < 80) {
                            internalEdgeCount++;
                        }
                    }
                }
            }

            const totalSamples = ((width * 0.6) / sampleSize) * ((height * 0.6) / sampleSize);
            const internalFeatureRatio = internalEdgeCount / totalSamples;

            // Opening windows tend to have more internal features
            return internalFeatureRatio > 0.15 ? 'window-openable' : 'window-fixed';
        }

        function autoDetectCircularObjectsEnhanced() {
            // Validate canvas context
            if (!state.ctx || !state.canvas) {
                throw new Error('Canvas not initialized');
            }

            let imageData;
            try {
                imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            } catch (error) {
                console.error('Failed to get image data:', error);
                throw new Error('Unable to access image data. This may occur on mobile devices with memory constraints.');
            }

            const edges = detectEdges(imageData);
            const circles = findCircularShapes(edges, state.canvas.width, state.canvas.height);

            return circles.map(c => {
                const diameter = c.radius * 2;
                const diameterMM = diameter / (state.pxPerMM || 1);

                // Classify circular objects by size and context
                let objectType = 'circular';

                if (diameterMM >= 80 && diameterMM <= 160) {
                    // Typical flue terminal size (100-150mm)
                    objectType = 'flue';
                } else if (diameterMM >= 20 && diameterMM <= 80) {
                    // Smaller vents or pipes
                    objectType = classifySmallCircular(imageData, c, diameterMM);
                } else if (diameterMM > 160) {
                    // Larger objects might be downpipes or soil pipes
                    objectType = 'downpipe';
                }

                return {
                    type: objectType,
                    x: c.centerX - c.radius,
                    y: c.centerY - c.radius,
                    width: c.radius * 2,
                    height: c.radius * 2,
                    centerX: c.centerX,
                    centerY: c.centerY,
                    radius: c.radius,
                    confidence: c.confidence
                };
            });
        }

        function classifySmallCircular(imageData, circle, diameterMM) {
            const data = imageData.data;
            const width = imageData.width;

            // Sample the center of the circular object
            const cx = Math.floor(circle.centerX);
            const cy = Math.floor(circle.centerY);

            if (cx >= 0 && cx < width && cy >= 0 && cy < imageData.height) {
                const idx = (cy * width + cx) * 4;
                const r = data[idx];
                const g = data[idx + 1];
                const b = data[idx + 2];

                // Check color characteristics
                const brightness = (r + g + b) / 3;

                // White/light colored = likely air vent
                if (brightness > 180) {
                    return 'vent';
                }
                // Dark/metallic = likely pipe or flue
                else if (brightness < 100) {
                    return diameterMM > 40 ? 'downpipe' : 'vent';
                }
            }

            return 'vent';
        }

        function autoDetectPipes() {
            // Validate canvas context
            if (!state.ctx || !state.canvas) {
                throw new Error('Canvas not initialized');
            }

            let imageData;
            try {
                imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            } catch (error) {
                console.error('Failed to get image data:', error);
                throw new Error('Unable to access image data. This may occur on mobile devices with memory constraints.');
            }

            const edges = detectEdges(imageData);
            const pipes = findLinearShapes(edges, state.canvas.width, state.canvas.height);

            return pipes;
        }

        function findLinearShapes(edges, width, height) {
            const threshold = 30;
            const pipes = [];

            // Use Hough transform to detect lines
            const lines = detectLines(edges, width, height, threshold);

            // Filter for pipe-like lines (vertical or horizontal, with consistent width)
            for (const line of lines) {
                const angle = Math.abs(line.angle);
                const isVertical = angle > 80 && angle < 100;
                const isHorizontal = angle < 10 || angle > 170;

                if (isVertical || isHorizontal) {
                    const thickness = estimateLineThickness(edges, line, width, height);
                    const thicknessMM = thickness / (state.pxPerMM || 1);

                    // Pipes are typically 20-60mm diameter
                    if (thicknessMM >= 15 && thicknessMM <= 80) {
                        pipes.push({
                            type: 'downpipe',
                            x: line.x1,
                            y: line.y1,
                            x2: line.x2,
                            y2: line.y2,
                            width: thickness,
                            height: Math.abs(line.y2 - line.y1),
                            orientation: isVertical ? 'vertical' : 'horizontal',
                            confidence: line.strength
                        });
                    }
                }
            }

            return pipes;
        }

        function detectLines(edges, width, height, threshold) {
            const lines = [];
            const accumulator = {};

            // Simplified Hough transform for line detection
            for (let y = 0; y < height; y += 2) {
                for (let x = 0; x < width; x += 2) {
                    if (edges[y * width + x] > threshold) {
                        // Vote for possible lines through this point
                        for (let theta = 0; theta < 180; theta += 10) {
                            const rad = (theta * Math.PI) / 180;
                            const rho = Math.round(x * Math.cos(rad) + y * Math.sin(rad));
                            const key = `${rho},${theta}`;
                            accumulator[key] = (accumulator[key] || 0) + 1;
                        }
                    }
                }
            }

            // Find strong lines
            const candidates = [];
            for (const [key, votes] of Object.entries(accumulator)) {
                if (votes > 50) {
                    const [rho, theta] = key.split(',').map(Number);
                    candidates.push({ rho: parseInt(rho), theta, votes });
                }
            }

            // Convert rho-theta to line segments
            candidates.sort((a, b) => b.votes - a.votes);
            for (let i = 0; i < Math.min(20, candidates.length); i++) {
                const { rho, theta, votes } = candidates[i];
                const rad = (theta * Math.PI) / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);

                const x0 = cos * rho;
                const y0 = sin * rho;

                const x1 = Math.round(x0 + 1000 * (-sin));
                const y1 = Math.round(y0 + 1000 * cos);
                const x2 = Math.round(x0 - 1000 * (-sin));
                const y2 = Math.round(y0 - 1000 * cos);

                lines.push({
                    x1: Math.max(0, Math.min(width, x1)),
                    y1: Math.max(0, Math.min(height, y1)),
                    x2: Math.max(0, Math.min(width, x2)),
                    y2: Math.max(0, Math.min(height, y2)),
                    angle: theta,
                    strength: votes / 100
                });
            }

            return lines;
        }

        function estimateLineThickness(edges, line, width, height) {
            // Sample perpendicular to the line to estimate thickness
            const angle = (line.angle * Math.PI) / 180;
            const perpAngle = angle + Math.PI / 2;

            const midX = (line.x1 + line.x2) / 2;
            const midY = (line.y1 + line.y2) / 2;

            let thickness = 0;
            for (let dist = -50; dist <= 50; dist++) {
                const x = Math.round(midX + dist * Math.cos(perpAngle));
                const y = Math.round(midY + dist * Math.sin(perpAngle));

                if (x >= 0 && x < width && y >= 0 && y < height) {
                    if (edges[y * width + x] > 30) {
                        thickness++;
                    }
                }
            }

            return thickness;
        }

        function autoDetectVents() {
            // Validate canvas context
            if (!state.ctx || !state.canvas) {
                throw new Error('Canvas not initialized');
            }

            let imageData;
            try {
                imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            } catch (error) {
                console.error('Failed to get image data:', error);
                throw new Error('Unable to access image data. This may occur on mobile devices with memory constraints.');
            }

            const edges = detectEdges(imageData);
            const rectangles = findRectangularShapes(edges, state.canvas.width, state.canvas.height);

            // Filter for vent-like rectangles (smaller, specific aspect ratios)
            const vents = rectangles.filter(rect => {
                const width = rect.maxX - rect.minX;
                const height = rect.maxY - rect.minY;
                const area = width * height;
                const aspectRatio = width / height;

                const widthMM = width / (state.pxPerMM || 1);
                const heightMM = height / (state.pxPerMM || 1);

                // Vents are typically smaller than windows
                // Common vent sizes: 100x100mm to 300x300mm, or rectangular air bricks
                return area > 1000 && area < 10000 &&
                       aspectRatio > 0.5 && aspectRatio < 4.0 &&
                       widthMM >= 50 && widthMM <= 400 &&
                       heightMM >= 50 && heightMM <= 400 &&
                       rect.edgeStrength > 0.35;
            });

            return vents.map(v => ({
                type: 'vent',
                x: v.minX,
                y: v.minY,
                width: v.maxX - v.minX,
                height: v.maxY - v.minY,
                confidence: v.edgeStrength
            }));
        }

        // Comprehensive auto-detection with confirmation UI
        function runAutoDetectAllEnhanced() {
            const status = document.getElementById('autoDetectionStatus');
            status.style.display = 'block';
            status.classList.remove('warning');
            status.classList.add('active');
            status.textContent = 'üîç Running enhanced auto-detection...';

            try {
                const detections = {
                    windows: autoDetectWindowsEnhanced(),
                    circular: autoDetectCircularObjectsEnhanced(),
                    pipes: autoDetectPipes(),
                    vents: autoDetectVents()
                };

                const totalDetected = detections.windows.length +
                                     detections.circular.length +
                                     detections.pipes.length +
                                     detections.vents.length;

                if (totalDetected === 0) {
                    status.classList.add('warning');
                    status.textContent = '‚ö†Ô∏è No objects detected. Try adjusting lighting or manually mark obstacles.';
                    return;
                }

                // Show confirmation dialog
                showDetectionConfirmation(detections);

                status.classList.remove('warning');
                status.textContent = `üîç Detected ${totalDetected} object(s). Please review and confirm.`;

                console.log('Enhanced auto-detection complete:', detections);
            } catch (error) {
                console.error('Enhanced auto-detection error:', error);
                status.classList.add('warning');
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    status.textContent = '‚ùå Detection failed on mobile device. Try using a smaller image or mark obstacles manually.';
                } else {
                    status.textContent = '‚ùå Detection failed. Please mark obstacles manually.';
                }
            }
        }

        function showDetectionConfirmation(detections) {
            // Create modal dialog for confirmation
            const modal = document.createElement('div');
            modal.id = 'detectionConfirmationModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                max-width: 800px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;

            let html = `
                <h2 style="margin-top: 0; color: #2d3748;">Review Detected Objects</h2>
                <p style="color: #4a5568; margin-bottom: 20px;">
                    Please review the detected objects below. You can change their type or delete them before confirming.
                </p>
                <div id="detectionsList"></div>
                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="cancelDetectionConfirmation()" style="padding: 10px 20px; background: #e53e3e; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Cancel All
                    </button>
                    <button onclick="confirmDetections()" style="padding: 10px 20px; background: #48bb78; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Confirm & Add
                    </button>
                </div>
            `;

            dialog.innerHTML = html;
            modal.appendChild(dialog);
            document.body.appendChild(modal);

            // Store detections in global scope for confirmation
            window.pendingDetections = [];

            // Populate list
            const listContainer = document.getElementById('detectionsList');
            let detectionIndex = 0;

            const allDetections = [
                ...detections.windows,
                ...detections.circular,
                ...detections.pipes,
                ...detections.vents
            ];

            allDetections.forEach((det, idx) => {
                window.pendingDetections.push(det);

                const item = document.createElement('div');
                item.style.cssText = `
                    padding: 15px;
                    margin-bottom: 10px;
                    background: #f7fafc;
                    border-radius: 5px;
                    border-left: 4px solid #4299e1;
                `;

                const typeOptions = [
                    'window-openable', 'window-fixed', 'flue', 'vent',
                    'downpipe', 'circular', 'corner', 'soffit'
                ];

                item.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>Object ${idx + 1}</strong><br>
                            <small>Position: (${Math.round(det.x)}, ${Math.round(det.y)}),
                            Size: ${Math.round(det.width)}√ó${Math.round(det.height)}px,
                            Confidence: ${(det.confidence * 100).toFixed(1)}%</small>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="detType_${idx}" style="padding: 8px; border-radius: 4px; border: 1px solid #cbd5e0;">
                                ${typeOptions.map(type =>
                                    `<option value="${type}" ${type === det.type ? 'selected' : ''}>${type}</option>`
                                ).join('')}
                            </select>
                            <button onclick="removeDetection(${idx})" style="padding: 8px 15px; background: #e53e3e; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                Remove
                            </button>
                        </div>
                    </div>
                `;

                listContainer.appendChild(item);
            });
        }

        function removeDetection(index) {
            if (window.pendingDetections) {
                window.pendingDetections[index] = null;
                document.getElementById('detectionsList').children[index].style.display = 'none';
            }
        }

        function cancelDetectionConfirmation() {
            const modal = document.getElementById('detectionConfirmationModal');
            if (modal) {
                modal.remove();
            }
            window.pendingDetections = null;

            const status = document.getElementById('autoDetectionStatus');
            status.textContent = '‚ùå Detection cancelled.';
        }

        function confirmDetections() {
            if (!window.pendingDetections) return;

            let addedCount = 0;

            window.pendingDetections.forEach((det, idx) => {
                if (det === null) return; // Removed detection

                // Get updated type from dropdown
                const typeSelect = document.getElementById(`detType_${idx}`);
                if (typeSelect) {
                    det.type = typeSelect.value;
                }

                const obstacle = {
                    type: det.type,
                    x: det.x,
                    y: det.y,
                    width: det.width,
                    height: det.height,
                    confidence: det.confidence,
                    autoDetected: true
                };

                // Add circular object properties if applicable
                if (det.centerX !== undefined) {
                    obstacle.centerX = det.centerX;
                    obstacle.centerY = det.centerY;
                    obstacle.radius = det.radius;
                }

                state.obstacles.push(obstacle);
                addedCount++;
            });

            // Close modal
            const modal = document.getElementById('detectionConfirmationModal');
            if (modal) {
                modal.remove();
            }
            window.pendingDetections = null;

            // Update UI
            updateObstaclesList();
            redrawCanvasWithObstacles();
            document.getElementById('calculateBtn').style.display = 'block';

            const status = document.getElementById('autoDetectionStatus');
            status.classList.remove('warning');
            status.textContent = `‚úÖ Added ${addedCount} object(s)! You can add more obstacles manually or calculate clearances.`;
        }

        // Integration functions for auto-detection
        function runAutoDetectWindows() {
            const status = document.getElementById('autoDetectionStatus');
            status.style.display = 'block';
            status.classList.remove('warning');
            status.classList.add('active');
            status.textContent = 'üîç Detecting windows...';

            try {
                const windows = autoDetectWindows();

                if (windows.length === 0) {
                    status.classList.add('warning');
                    status.textContent = '‚ö†Ô∏è No windows detected. Try adjusting lighting or manually mark obstacles.';
                    return;
                }

                // Add detected windows to obstacles
                windows.forEach((window, idx) => {
                    const obstacle = {
                        type: 'window',
                        x: window.x,
                        y: window.y,
                        width: window.width,
                        height: window.height,
                        confidence: window.confidence,
                        autoDetected: true
                    };
                    state.obstacles.push(obstacle);

                    // Draw window on canvas
                    state.ctx.strokeStyle = '#48bb78';
                    state.ctx.lineWidth = 3;
                    state.ctx.strokeRect(window.x, window.y, window.width, window.height);

                    // Add label
                    state.ctx.fillStyle = '#48bb78';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.fillText(`Window ${idx + 1}`, window.x + 5, window.y + 20);
                });

                updateObstaclesList();
                document.getElementById('calculateBtn').style.display = 'block';

                status.classList.remove('warning');
                status.textContent = `‚úÖ Detected ${windows.length} window(s)! You can add more obstacles manually or calculate clearances.`;

                console.log('Auto-detected windows:', windows);
            } catch (error) {
                console.error('Window detection error:', error);
                status.classList.add('warning');
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    status.textContent = '‚ùå Detection failed on mobile device. Try using a smaller image or mark obstacles manually.';
                } else {
                    status.textContent = '‚ùå Detection failed. Please mark obstacles manually.';
                }
            }
        }

        function runAutoDetectCircularObjects() {
            const status = document.getElementById('autoDetectionStatus');
            status.style.display = 'block';
            status.classList.remove('warning');
            status.classList.add('active');
            status.textContent = 'üîç Detecting circular objects (flues, vents, pipes)...';

            try {
                const circles = autoDetectCircularObjects();

                if (circles.length === 0) {
                    status.classList.add('warning');
                    status.textContent = '‚ö†Ô∏è No circular objects detected. Try adjusting lighting or manually mark obstacles.';
                    return;
                }

                // Add detected circular objects to obstacles
                circles.forEach((circle, idx) => {
                    const obstacle = {
                        type: 'circular',
                        x: circle.x,
                        y: circle.y,
                        width: circle.width,
                        height: circle.height,
                        centerX: circle.centerX,
                        centerY: circle.centerY,
                        radius: circle.radius,
                        confidence: circle.confidence,
                        autoDetected: true
                    };
                    state.obstacles.push(obstacle);

                    // Draw circle on canvas
                    state.ctx.strokeStyle = '#48bb78';
                    state.ctx.lineWidth = 3;
                    state.ctx.beginPath();
                    state.ctx.arc(circle.centerX, circle.centerY, circle.radius, 0, Math.PI * 2);
                    state.ctx.stroke();

                    // Add label
                    state.ctx.fillStyle = '#48bb78';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.fillText(`Circle ${idx + 1}`, circle.centerX - 25, circle.centerY - circle.radius - 10);
                });

                updateObstaclesList();
                document.getElementById('calculateBtn').style.display = 'block';

                status.classList.remove('warning');
                status.textContent = `‚úÖ Detected ${circles.length} circular object(s)! You can add more obstacles manually or calculate clearances.`;

                console.log('Auto-detected circular objects:', circles);
            } catch (error) {
                console.error('Circular object detection error:', error);
                status.classList.add('warning');
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    status.textContent = '‚ùå Detection failed on mobile device. Try using a smaller image or mark obstacles manually.';
                } else {
                    status.textContent = '‚ùå Detection failed. Please mark obstacles manually.';
                }
            }
        }

        function runAutoDetectAll() {
            const status = document.getElementById('autoDetectionStatus');
            status.style.display = 'block';
            status.classList.remove('warning');
            status.classList.add('active');
            status.textContent = 'üîç Running comprehensive auto-detection...';

            try {
                // Detect windows
                const windows = autoDetectWindows();
                windows.forEach((window, idx) => {
                    const obstacle = {
                        type: 'window',
                        x: window.x,
                        y: window.y,
                        width: window.width,
                        height: window.height,
                        confidence: window.confidence,
                        autoDetected: true
                    };
                    state.obstacles.push(obstacle);

                    state.ctx.strokeStyle = '#4299e1';
                    state.ctx.lineWidth = 3;
                    state.ctx.strokeRect(window.x, window.y, window.width, window.height);

                    state.ctx.fillStyle = '#4299e1';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.fillText(`Window ${idx + 1}`, window.x + 5, window.y + 20);
                });

                // Detect circular objects
                const circles = autoDetectCircularObjects();
                circles.forEach((circle, idx) => {
                    const obstacle = {
                        type: 'circular',
                        x: circle.x,
                        y: circle.y,
                        width: circle.width,
                        height: circle.height,
                        centerX: circle.centerX,
                        centerY: circle.centerY,
                        radius: circle.radius,
                        confidence: circle.confidence,
                        autoDetected: true
                    };
                    state.obstacles.push(obstacle);

                    state.ctx.strokeStyle = '#ed8936';
                    state.ctx.lineWidth = 3;
                    state.ctx.beginPath();
                    state.ctx.arc(circle.centerX, circle.centerY, circle.radius, 0, Math.PI * 2);
                    state.ctx.stroke();

                    state.ctx.fillStyle = '#ed8936';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.fillText(`Circle ${idx + 1}`, circle.centerX - 25, circle.centerY - circle.radius - 10);
                });

                const totalDetected = windows.length + circles.length;

                if (totalDetected === 0) {
                    status.classList.add('warning');
                    status.textContent = '‚ö†Ô∏è No objects detected. Try adjusting lighting or manually mark obstacles.';
                } else {
                    updateObstaclesList();
                    document.getElementById('calculateBtn').style.display = 'block';

                    status.classList.remove('warning');
                    status.textContent = `‚úÖ Detected ${windows.length} window(s) and ${circles.length} circular object(s)! You can add more obstacles manually or calculate clearances.`;
                }

                console.log('Auto-detection complete:', { windows, circles });
            } catch (error) {
                console.error('Auto-detection error:', error);
                status.classList.add('warning');
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    status.textContent = '‚ùå Detection failed on mobile device. Try using a smaller image or mark obstacles manually.';
                } else {
                    status.textContent = '‚ùå Detection failed. Please mark obstacles manually.';
                }
            }
        }

        function handleCalibrationClick(e) {
            if (!state.isCalibrating) return;
            
            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;
            
            state.calibrationPoints.push({x, y});
            
            state.ctx.fillStyle = '#f56565';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();
            
            state.ctx.fillStyle = 'white';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.textAlign = 'center';
            state.ctx.textBaseline = 'middle';
            state.ctx.fillText(state.calibrationPoints.length, x, y);
            
            updatePointsDisplay();

            const refObject = state.calibrationMode === 'brick' ? 'brick' : 'card';
            const status = document.getElementById('tapStatus');
            const corners = ['Top-Left', 'Top-Right', 'Bottom-Right', 'Bottom-Left'];

            if (state.calibrationPoints.length < 4) {
                status.textContent = `Tap corner ${state.calibrationPoints.length + 1}/4: ${corners[state.calibrationPoints.length]} corner of ${refObject}`;
            } else {
                calculateCalibration();
            }
        }

        function calculateCalibration() {
            const points = state.calibrationPoints;
            
            const topWidth = distance(points[0], points[1]);
            const bottomWidth = distance(points[3], points[2]);
            const leftHeight = distance(points[0], points[3]);
            const rightHeight = distance(points[1], points[2]);
            
            const avgWidthPx = (topWidth + bottomWidth) / 2;
            const avgHeightPx = (leftHeight + rightHeight) / 2;

            // Get reference dimensions based on calibration mode
            let refWidthMM, refHeightMM, refName;
            if (state.calibrationMode === 'brick') {
                // Get brick dimensions based on orientation
                if (state.brickOrientation === 'length') {
                    // Stretcher: 215mm √ó 65mm
                    refWidthMM = BRICK_LENGTH_MM;
                    refHeightMM = BRICK_HEIGHT_MM;
                    refName = 'Brick (Stretcher)';
                } else if (state.brickOrientation === 'width') {
                    // Header: 102.5mm √ó 65mm
                    refWidthMM = BRICK_WIDTH_MM;
                    refHeightMM = BRICK_HEIGHT_MM;
                    refName = 'Brick (Header)';
                } else {
                    // Bed: 215mm √ó 102.5mm
                    refWidthMM = BRICK_LENGTH_MM;
                    refHeightMM = BRICK_WIDTH_MM;
                    refName = 'Brick (Bed)';
                }
            } else {
                refWidthMM = CARD_WIDTH_MM;
                refHeightMM = CARD_HEIGHT_MM;
                refName = 'Card';
            }

            const pxPerMMWidth = avgWidthPx / refWidthMM;
            const pxPerMMHeight = avgHeightPx / refHeightMM;
            
            state.pxPerMM = (pxPerMMWidth + pxPerMMHeight) / 2;

            const skew = Math.abs(pxPerMMWidth - pxPerMMHeight) / state.pxPerMM * 100;

            // Calculate plumb line accuracy (check if card is level/vertical)
            const topAngle = Math.abs(Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x) * 180 / Math.PI);
            const bottomAngle = Math.abs(Math.atan2(points[2].y - points[3].y, points[2].x - points[3].x) * 180 / Math.PI);
            const leftAngle = Math.abs(Math.atan2(points[3].y - points[0].y, points[3].x - points[0].x) * 180 / Math.PI - 90);
            const rightAngle = Math.abs(Math.atan2(points[2].y - points[1].y, points[2].x - points[1].x) * 180 / Math.PI - 90);

            const avgHorizontalAngle = (topAngle + bottomAngle) / 2;
            const avgVerticalAngle = (leftAngle + rightAngle) / 2;

            let plumbRating = '';
            let plumbAccurate = true;

            if (avgHorizontalAngle < 3 && avgVerticalAngle < 3) {
                plumbRating = `‚úÖ Excellent - ${refName} is level and plumb`;
            } else if (avgHorizontalAngle < 5 && avgVerticalAngle < 5) {
                plumbRating = '‚ö†Ô∏è Good - Slight tilt detected';
            } else {
                plumbRating = `‚ùå ${refName} not level - Use plumb line for accuracy`;
                plumbAccurate = false;
            }

            let accuracyRating = '';

            if (skew < 5) {
                accuracyRating = '‚úÖ Excellent (< 5% skew)';
            } else if (skew < 10) {
                accuracyRating = '‚ö†Ô∏è Good (< 10% skew)';
            } else {
                accuracyRating = '‚ùå Poor - Consider retaking photo more straight-on';
            }
            
            state.ctx.strokeStyle = skew < 10 ? '#48bb78' : '#f56565';
            state.ctx.lineWidth = 4;
            state.ctx.beginPath();
            state.ctx.moveTo(points[0].x, points[0].y);
            state.ctx.lineTo(points[1].x, points[1].y);
            state.ctx.lineTo(points[2].x, points[2].y);
            state.ctx.lineTo(points[3].x, points[3].y);
            state.ctx.closePath();
            state.ctx.stroke();
            
            points.forEach((point, i) => {
                state.ctx.fillStyle = skew < 10 ? '#48bb78' : '#f56565';
                state.ctx.beginPath();
                state.ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                state.ctx.fill();
                
                state.ctx.fillStyle = 'white';
                state.ctx.font = 'bold 14px Arial';
                state.ctx.textAlign = 'center';
                state.ctx.textBaseline = 'middle';
                state.ctx.fillText(i + 1, point.x, point.y);
            });
            
            state.isCalibrating = false;
            state.canvas.removeEventListener('click', handleCalibrationClick);
            
            const status = document.getElementById('tapStatus');
            status.classList.remove('active');
            
            const info = document.getElementById('calibrationInfo');
            info.classList.add('active');
            document.getElementById('scaleDisplay').textContent = state.pxPerMM.toFixed(2);

            // Update dimension labels based on calibration mode
            document.getElementById('refDim1Label').innerHTML = `Width: <span id="refDim1Display">${avgWidthPx.toFixed(1)}</span> pixels (should be ~${refWidthMM}mm)`;
            document.getElementById('refDim2Label').innerHTML = `Height: <span id="refDim2Display">${avgHeightPx.toFixed(1)}</span> pixels (should be ~${refHeightMM}mm)`;

            document.getElementById('accuracyDisplay').textContent = accuracyRating;
            document.getElementById('plumbDisplay').textContent = plumbRating;

            document.getElementById('analysisCard').style.display = 'block';

            // FIX: Clone canvas to remove ALL event listeners
            const oldCanvas = state.canvas;
            const newCanvas = oldCanvas.cloneNode(false);
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);

            // Update state references
            state.canvas = newCanvas;
            state.ctx = newCanvas.getContext('2d');

            // Redraw photo and calibration overlay
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Recalculate canvas scale
            const rect = newCanvas.getBoundingClientRect();
            state.canvasScale = newCanvas.width / rect.width;
        }

        function startFlueMode() {
            console.log('=== START FLUE MODE CALLED ===');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'flue';
            state.flueType = 'horizontal';
            state.position = null;
            state.flueBrand = null;
            state.flueModel = null;
            state.flueClearances = null;

            // Hide other mode sections
            document.getElementById('boilerEditingSection').style.display = 'none';
            document.getElementById('radiatorEditingSection').style.display = 'none';
            document.getElementById('verticalFlueEditingSection').style.display = 'none';

            // Show flue editing section
            document.getElementById('flueEditingSection').style.display = 'block';

            // Populate brand selector
            const brandSelect = document.getElementById('flueBrandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';
            FLUE_AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üî• Select brand/model, then tap to mark horizontal flue terminal position';

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Add fresh listener
            state.canvas.addEventListener('click', handlePositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Horizontal flue mode started');
        }

        function startVerticalFlueMode() {
            console.log('=== START VERTICAL FLUE MODE CALLED ===');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'flue';
            state.flueType = 'vertical';
            state.position = null;
            state.flueBrand = null;
            state.flueModel = null;
            state.flueClearances = null;

            // Hide other mode sections
            document.getElementById('boilerEditingSection').style.display = 'none';
            document.getElementById('radiatorEditingSection').style.display = 'none';
            document.getElementById('flueEditingSection').style.display = 'none';

            // Show vertical flue editing section
            document.getElementById('verticalFlueEditingSection').style.display = 'block';

            // Populate brand selector
            const brandSelect = document.getElementById('verticalFlueBrandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';
            VERTICAL_FLUE_AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = '‚¨ÜÔ∏è Select brand/model, then tap to mark vertical flue terminal position';

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Add fresh listener
            state.canvas.addEventListener('click', handlePositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Vertical flue mode started');
        }

        function updateFlueModelSelector() {
            const brand = document.getElementById('flueBrandSelect').value;
            const modelSelect = document.getElementById('flueModelSelect');
            const modelLabel = document.getElementById('flueModelSelectorLabel');

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            // Get models for this brand
            if (FLUE_AVAILABLE_MODELS[brand]) {
                const models = FLUE_AVAILABLE_MODELS[brand];

                // Populate model dropdown
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });

                modelLabel.style.display = 'block';
            } else {
                modelLabel.style.display = 'none';
            }
        }

        function displayFlueClearances() {
            const brand = document.getElementById('flueBrandSelect').value;
            const model = document.getElementById('flueModelSelect').value;

            if (!brand || !model) return;

            state.flueBrand = brand;
            state.flueModel = model;

            // Get clearances for this model
            const clearances = getFlueClearancesForModel(brand, model);
            state.flueClearances = clearances;

            // Display clearances
            const displayDiv = document.getElementById('flueClearancesDisplay');
            const listDiv = document.getElementById('flueClearancesList');
            const rulesSection = document.getElementById('flueSpecialRulesSection');
            const rulesContent = document.getElementById('flueSpecialRulesContent');

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #667eea;"><th style="padding: 8px; text-align: left;">Position/Scenario</th><th style="padding: 8px; text-align: right;">Clearance</th></tr>';

            let specialRules = [];

            for (const [position, data] of Object.entries(clearances)) {
                html += `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px;">${position}</td>
                    <td style="padding: 8px; text-align: right; font-weight: bold;">${data.clearanceMM}mm</td>
                </tr>`;

                if (data.specialRules) {
                    specialRules.push(`<strong>${position}:</strong> ${data.specialRules}`);
                }
            }

            html += '</table>';
            listDiv.innerHTML = html;
            displayDiv.style.display = 'block';

            // Show special rules if any
            if (specialRules.length > 0) {
                rulesContent.innerHTML = '‚Ä¢ ' + specialRules.join('<br>‚Ä¢ ');
                rulesSection.style.display = 'block';
            } else {
                rulesSection.style.display = 'none';
            }

            // Update status
            document.getElementById('positionStatus').textContent = 'üî• Tap on the image to mark the flue terminal position';
        }

        function updateVerticalFlueModelSelector() {
            const brand = document.getElementById('verticalFlueBrandSelect').value;
            const modelSelect = document.getElementById('verticalFlueModelSelect');
            const modelLabel = document.getElementById('verticalFlueModelSelectorLabel');

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            // Get models for this brand
            if (VERTICAL_FLUE_AVAILABLE_MODELS[brand]) {
                const models = VERTICAL_FLUE_AVAILABLE_MODELS[brand];

                // Populate model dropdown
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });

                modelLabel.style.display = 'block';
            } else {
                modelLabel.style.display = 'none';
            }
        }

        function displayVerticalFlueClearances() {
            const brand = document.getElementById('verticalFlueBrandSelect').value;
            const model = document.getElementById('verticalFlueModelSelect').value;

            if (!brand || !model) return;

            state.flueBrand = brand;
            state.flueModel = model;

            // Get clearances for this model
            const clearances = getVerticalFlueClearancesForModel(brand, model);
            state.flueClearances = clearances;

            // Display clearances
            const displayDiv = document.getElementById('verticalFlueClearancesDisplay');
            const listDiv = document.getElementById('verticalFlueClearancesList');
            const rulesSection = document.getElementById('verticalFlueSpecialRulesSection');
            const rulesContent = document.getElementById('verticalFlueSpecialRulesContent');

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #667eea;"><th style="padding: 8px; text-align: left;">Position/Scenario</th><th style="padding: 8px; text-align: right;">Clearance</th></tr>';

            let specialRules = [];

            for (const [position, data] of Object.entries(clearances)) {
                html += `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px;">${position}</td>
                    <td style="padding: 8px; text-align: right; font-weight: bold;">${data.clearanceMM}mm</td>
                </tr>`;

                if (data.specialRules) {
                    specialRules.push(`<strong>${position}:</strong> ${data.specialRules}`);
                }
            }

            html += '</table>';
            listDiv.innerHTML = html;
            displayDiv.style.display = 'block';

            // Show special rules if any
            if (specialRules.length > 0) {
                rulesContent.innerHTML = '‚Ä¢ ' + specialRules.join('<br>‚Ä¢ ');
                rulesSection.style.display = 'block';
            } else {
                rulesSection.style.display = 'none';
            }

            // Update status
            document.getElementById('positionStatus').textContent = '‚¨ÜÔ∏è Tap on the image to mark the vertical flue terminal position';
        }

        function updateModelSelector() {
            const brand = document.getElementById('brandSelect').value;
            const modelSelect = document.getElementById('modelSelect');
            const modelLabel = document.getElementById('modelSelectorLabel');

            // Show model selector only in boiler mode
            if (state.mode !== 'boiler') return;

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            if (AVAILABLE_MODELS[brand]) {
                const models = AVAILABLE_MODELS[brand];

                // Populate model dropdown
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });

                modelLabel.style.display = 'block';

                // Auto-advance on iPad
                autoAdvanceOnIPad();
            } else {
                modelLabel.style.display = 'none';
            }
        }

        function updateBoilerClearancesFromCSV() {
            const brand = document.getElementById('brandSelect').value;
            const model = document.getElementById('modelSelect').value;

            if (!model) return;

            // Get clearances from CSV
            const clearances = getBoilerClearancesForModel(brand, model);

            console.log('Loaded clearances for', brand, model, ':', clearances);

            // Update the input fields with CSV values
            if (clearances.top !== null) {
                document.getElementById('clearanceTop').value = clearances.top;
                state.boilerClearances.top = clearances.top;
            }
            if (clearances.bottom !== null) {
                document.getElementById('clearanceBottom').value = clearances.bottom;
                state.boilerClearances.bottom = clearances.bottom;
            }
            if (clearances.left !== null) {
                document.getElementById('clearanceLeft').value = clearances.left;
                state.boilerClearances.left = clearances.left;
            }
            if (clearances.right !== null) {
                document.getElementById('clearanceRight').value = clearances.right;
                state.boilerClearances.right = clearances.right;
            }

            // Show notes if available
            const notesSection = document.getElementById('clearanceNotesSection');
            const notesContent = document.getElementById('clearanceNotesContent');

            if (clearances.notes.length > 0) {
                const notesText = clearances.notes.filter(n => n).join('<br>‚Ä¢ ');
                console.log('Notes:', notesText);

                notesContent.innerHTML = '‚Ä¢ ' + notesText;
                notesSection.style.display = 'block';
            } else {
                notesSection.style.display = 'none';
            }

            // Redraw if position already set
            if (state.position) {
                drawBoilerWithClearances();
            }

            // Auto-advance on iPad to show position instructions
            autoAdvanceOnIPad();
        }

        function startBoilerMode() {
            console.log('startBoilerMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'boiler';
            state.position = null; // Clear any previous position

            // Initialize default boiler dimensions
            state.boilerDimensions = {
                height: 600,  // mm
                width: 390,   // mm
                depth: 280    // mm (not used in 2D view)
            };

            // Initialize default clearances
            state.boilerClearances = {
                top: 170,     // mm
                bottom: 200,  // mm
                left: 5,      // mm
                right: 5      // mm
            };

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üîß Select brand/model, then tap where the boiler center will be located';

            // Populate brand selector from CSV data
            const brandSelect = document.getElementById('brandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';
            AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });

            // Show model selector
            updateModelSelector();

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);

            // Add boiler-specific listener
            state.canvas.addEventListener('click', handleBoilerPositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Boiler mode started - canvas ready for position click');
        }

        function startRadiatorMode() {
            console.log('startRadiatorMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'radiator';
            state.position = null; // Clear any previous position

            // Initialize default radiator dimensions
            state.radiatorDimensions = {
                height: 600,  // mm (options: 300, 450, 600, 700)
                width: 400    // mm (400-3000 in 200mm steps)
            };

            // Initialize default clearances (150mm sides/bottom, 0mm top)
            state.radiatorClearances = {
                top: 0,       // mm
                bottom: 150,  // mm
                left: 150,    // mm
                right: 150    // mm
            };

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üå°Ô∏è Tap where the radiator center will be located';

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Add radiator-specific listener
            state.canvas.addEventListener('click', handleRadiatorPositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Radiator mode started - canvas ready for position click');
        }

        function startCylinderMode() {
            console.log('startCylinderMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'cylinder';
            state.position = null; // Clear any previous position

            // Show cylinder selection UI
            document.getElementById('cylinderEditingSection').style.display = 'block';
            document.getElementById('boilerEditingSection').style.display = 'none';
            document.getElementById('radiatorEditingSection').style.display = 'none';
            document.getElementById('flueEditingSection').style.display = 'none';
            document.getElementById('verticalFlueEditingSection').style.display = 'none';

            // Populate brand selector
            updateCylinderBrandSelector();

            console.log('Cylinder mode started');
        }

        function updateCylinderBrandSelector() {
            const brandSelect = document.getElementById('cylinderBrandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';

            CYLINDER_AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });
        }

        function updateCylinderModelSelector() {
            const brand = document.getElementById('cylinderBrandSelect').value;
            const modelSelect = document.getElementById('cylinderModelSelect');
            const modelLabel = document.getElementById('cylinderModelSelectorLabel');

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            modelSelect.innerHTML = '<option value="">Select a model...</option>';

            const models = CYLINDER_AVAILABLE_MODELS[brand] || [];
            models.forEach(modelKey => {
                const option = document.createElement('option');
                option.value = modelKey;
                option.textContent = modelKey;
                modelSelect.appendChild(option);
            });

            modelLabel.style.display = 'block';
        }

        function displayCylinderDetails() {
            const brand = document.getElementById('cylinderBrandSelect').value;
            const modelKey = document.getElementById('cylinderModelSelect').value;

            if (!brand || !modelKey) {
                document.getElementById('cylinderDetailsDisplay').style.display = 'none';
                document.getElementById('placeCylinderBtn').style.display = 'none';
                return;
            }

            const cylinder = getCylinderByKey(brand, modelKey);
            if (!cylinder) {
                console.error('Cylinder not found:', brand, modelKey);
                return;
            }

            // Parse dimensions
            const dims = parseCylinderDimensions(cylinder.dimensions);

            // Store in state
            state.cylinderDimensions = dims || { height: 1200, diameter: 520 };
            state.cylinderInfo = cylinder;

            // Display details
            const detailsList = document.getElementById('cylinderDetailsList');
            detailsList.innerHTML = `
                <p><strong>Type:</strong> ${cylinder.type}</p>
                <p><strong>Model:</strong> ${cylinder.model}</p>
                <p><strong>Volume:</strong> ${cylinder.volume}</p>
                ${cylinder.dimensions ? `<p><strong>Dimensions:</strong> ${cylinder.dimensions}</p>` : ''}
                ${cylinder.price ? `<p><strong>Price:</strong> ¬£${cylinder.price}</p>` : ''}
                ${cylinder.code ? `<p><strong>Code:</strong> ${cylinder.code}</p>` : ''}
            `;

            document.getElementById('cylinderDetailsDisplay').style.display = 'block';
            document.getElementById('placeCylinderBtn').style.display = 'block';
        }

        function enableCylinderPlacement() {
            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);
            state.canvas.removeEventListener('click', handleCylinderPositionClick);

            // Add cylinder-specific listener
            state.canvas.addEventListener('click', handleCylinderPositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            // Update status
            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üóúÔ∏è Tap where the cylinder center will be located';

            console.log('Cylinder placement enabled - canvas ready for position click');
        }

        function handleCylinderPositionClick(e) {
            if (state.isCalibrating) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            state.position = {x, y};

            // Draw cylinder
            drawCylinderOnCanvas();

            console.log('Cylinder placed at:', state.position);
        }

        function drawCylinderOnCanvas() {
            if (!state.cylinderDimensions || !state.position) return;

            // Redraw base
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            const diameterPx = state.cylinderDimensions.diameter * state.pxPerMM;
            const heightPx = state.cylinderDimensions.height * state.pxPerMM;

            const cylinderX = state.position.x - diameterPx / 2;
            const cylinderY = state.position.y - heightPx / 2;

            // Draw cylinder outline (rectangle with rounded ends for side view)
            state.ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            state.ctx.fillRect(cylinderX, cylinderY, diameterPx, heightPx);

            state.ctx.strokeStyle = '#4a90e2';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(cylinderX, cylinderY, diameterPx, heightPx);

            // Draw rounded top and bottom
            state.ctx.beginPath();
            state.ctx.ellipse(state.position.x, cylinderY, diameterPx / 2, diameterPx / 8, 0, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            state.ctx.beginPath();
            state.ctx.ellipse(state.position.x, cylinderY + heightPx, diameterPx / 2, diameterPx / 8, 0, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Label
            state.ctx.fillStyle = '#4a90e2';
            state.ctx.font = 'bold 16px Arial';
            const label = `Cylinder ${state.cylinderDimensions.height}√ó${state.cylinderDimensions.diameter}mm`;
            state.ctx.fillText(label, cylinderX + 10, cylinderY + 25);

            // Show download button
            document.getElementById('downloadCylinderMarkupBtn').style.display = 'block';
        }

        function handleBoilerPositionClick(e) {
            if (state.isCalibrating) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            state.position = {x, y};

            // Draw boiler box and clearances
            drawBoilerWithClearances();

            document.getElementById('positionStatus').textContent = '‚úÖ Boiler position set! Edit dimensions and mark obstacles below.';

            // Remove click listener
            state.canvas.removeEventListener('click', handleBoilerPositionClick);

            // Show boiler editing controls
            document.getElementById('boilerEditingSection').style.display = 'block';

            // Show obstacle marking UI
            document.getElementById('obstacleMarkingSection').style.display = 'block';
        }

        function handleRadiatorPositionClick(e) {
            if (state.isCalibrating) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            state.position = {x, y};

            // Draw radiator box and clearances
            drawRadiatorWithClearances();

            document.getElementById('positionStatus').textContent = '‚úÖ Radiator position set! Edit dimensions and mark obstacles below.';

            // Remove click listener
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Show radiator editing controls
            document.getElementById('radiatorEditingSection').style.display = 'block';

            // Show obstacle marking UI
            document.getElementById('obstacleMarkingSection').style.display = 'block';
        }

        function populateObstacleButtons() {
            const container = document.getElementById('obstacleButtonsContainer');
            container.innerHTML = '';

            let buttons = [];

            if (state.mode === 'flue' && state.flueType === 'vertical') {
                // Vertical flue obstacles
                buttons = [
                    { type: 'boundary', icon: 'üî≤', label: 'Add Boundary' },
                    { type: 'window-vent-vertical', icon: 'ü™ü', label: 'Add Window/Vent (Vertical)' },
                    { type: 'pitched-roof', icon: 'üè†', label: 'Add Pitched Roof' },
                    { type: 'velux-below', icon: 'üîª', label: 'Add Velux (Below)' },
                    { type: 'velux-above-sides', icon: 'üî∫', label: 'Add Velux (Above/Sides)' },
                    { type: 'skylight', icon: '‚òÄÔ∏è', label: 'Add Skylight' },
                    { type: 'combustible-material', icon: 'üî•', label: 'Add Combustible Material' },
                    { type: 'vertical-terminal', icon: '‚¨ÜÔ∏è', label: 'Add Other Vertical Terminal' }
                ];
            } else {
                // Horizontal flue obstacles (default)
                buttons = [
                    { type: 'window-openable', icon: 'ü™ü', label: 'Add Openable Window' },
                    { type: 'window-fixed', icon: 'ü™ü', label: 'Add Fixed Window' },
                    { type: 'vent', icon: 'üåÄ', label: 'Add Vent' },
                    { type: 'corner', icon: 'üìê', label: 'Add Corner' },
                    { type: 'soffit', icon: 'üè†', label: 'Add Soffit/Eaves' },
                    { type: 'downpipe', icon: 'üíß', label: 'Add Downpipe' }
                ];
            }

            // Add buttons to container
            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = 'btn btn-secondary';
                button.onclick = () => startMarkingObstacle(btn.type);
                button.textContent = `${btn.icon} ${btn.label}`;
                container.appendChild(button);
            });

            // Add cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn btn-danger';
            cancelBtn.onclick = cancelMarking;
            cancelBtn.textContent = '‚ùå Cancel Marking';
            container.appendChild(cancelBtn);
        }

        function handlePositionClick(e) {
            if (state.isCalibrating) return;

            console.log('Position click detected!'); // Debug

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            console.log('Clicked at:', x, y); // Debug

            state.position = {x, y};

            // Clear and redraw EVERYTHING
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw BIG obvious marker
            state.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            state.ctx.strokeStyle = '#ff0000';
            state.ctx.lineWidth = 5;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 30, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            // Draw crosshair
            state.ctx.strokeStyle = '#ff0000';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 50, y);
            state.ctx.lineTo(x + 50, y);
            state.ctx.moveTo(x, y - 50);
            state.ctx.lineTo(x, y + 50);
            state.ctx.stroke();

            console.log('Marker drawn'); // Debug

            document.getElementById('positionStatus').textContent = '‚úÖ Flue terminal position marked! Now mark obstacles below.';

            // Remove position click listener
            state.canvas.removeEventListener('click', handlePositionClick);

            // Show manual obstacle marking UI immediately and populate buttons
            populateObstacleButtons();
            document.getElementById('obstacleMarkingSection').style.display = 'block';
        }

        function updateBoilerDisplay() {
            // Read values from inputs
            state.boilerDimensions.height = parseInt(document.getElementById('boilerHeight').value) || 600;
            state.boilerDimensions.width = parseInt(document.getElementById('boilerWidth').value) || 390;
            state.boilerClearances.top = parseInt(document.getElementById('clearanceTop').value) || 170;
            state.boilerClearances.bottom = parseInt(document.getElementById('clearanceBottom').value) || 200;
            state.boilerClearances.left = parseInt(document.getElementById('clearanceLeft').value) || 5;
            state.boilerClearances.right = parseInt(document.getElementById('clearanceRight').value) || 5;

            // Redraw
            drawBoilerWithClearances();
        }

        function updateRadiatorDisplay() {
            // Read values from inputs
            state.radiatorDimensions.height = parseInt(document.getElementById('radiatorHeight').value) || 600;
            state.radiatorDimensions.width = parseInt(document.getElementById('radiatorWidth').value) || 400;
            state.radiatorClearances.top = parseInt(document.getElementById('radiatorClearanceTop').value) || 0;
            state.radiatorClearances.bottom = parseInt(document.getElementById('radiatorClearanceBottom').value) || 150;
            state.radiatorClearances.left = parseInt(document.getElementById('radiatorClearanceLeft').value) || 150;
            state.radiatorClearances.right = parseInt(document.getElementById('radiatorClearanceRight').value) || 150;

            // Redraw
            drawRadiatorWithClearances();
        }

        function adjustRadiatorWidth(delta) {
            const currentWidth = parseInt(document.getElementById('radiatorWidth').value) || 400;
            let newWidth = currentWidth + delta;

            // Clamp to valid range (400 to 3000mm in 200mm steps)
            newWidth = Math.max(400, Math.min(3000, newWidth));

            document.getElementById('radiatorWidth').value = newWidth;
            updateRadiatorDisplay();
        }

        function adjustBoilerWidth(delta) {
            const currentWidth = parseInt(document.getElementById('boilerWidth').value) || 390;
            let newWidth = currentWidth + delta;

            // Keep reasonable bounds (minimum 100mm, maximum 1000mm)
            newWidth = Math.max(100, Math.min(1000, newWidth));

            document.getElementById('boilerWidth').value = newWidth;
            updateBoilerDisplay();
        }

        function drawBoilerWithClearances() {
            // Clear and redraw
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            const boilerWidthPx = state.boilerDimensions.width * state.pxPerMM;
            const boilerHeightPx = state.boilerDimensions.height * state.pxPerMM;

            const clearanceTopPx = state.boilerClearances.top * state.pxPerMM;
            const clearanceBottomPx = state.boilerClearances.bottom * state.pxPerMM;
            const clearanceLeftPx = state.boilerClearances.left * state.pxPerMM;
            const clearanceRightPx = state.boilerClearances.right * state.pxPerMM;

            // Calculate boiler box position (centered on click)
            const boilerX = state.position.x - boilerWidthPx / 2;
            const boilerY = state.position.y - boilerHeightPx / 2;

            // Draw clearance zone (red transparent)
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
            state.ctx.fillRect(
                boilerX - clearanceLeftPx,
                boilerY - clearanceTopPx,
                boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                boilerHeightPx + clearanceTopPx + clearanceBottomPx
            );

            // Draw clearance outline (red dashed)
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.strokeRect(
                boilerX - clearanceLeftPx,
                boilerY - clearanceTopPx,
                boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                boilerHeightPx + clearanceTopPx + clearanceBottomPx
            );
            state.ctx.setLineDash([]);

            // Draw boiler box (green solid)
            state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
            state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

            state.ctx.strokeStyle = '#48bb78';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw labels
            state.ctx.fillStyle = '#333';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.fillText(`Boiler ${state.boilerDimensions.width}√ó${state.boilerDimensions.height}mm`, boilerX + 10, boilerY + 25);
            state.ctx.fillText(`Clearances: ${state.boilerClearances.top}mm ‚Üë`, boilerX + 10, boilerY - clearanceTopPx + 20);
            state.ctx.fillText(`${state.boilerClearances.bottom}mm ‚Üì`, boilerX + 10, boilerY + boilerHeightPx + clearanceBottomPx - 10);

            // Show download button
            document.getElementById('downloadBoilerMarkupBtn').style.display = 'block';
        }

        function drawRadiatorWithClearances() {
            // Clear and redraw
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            const radiatorWidthPx = state.radiatorDimensions.width * state.pxPerMM;
            const radiatorHeightPx = state.radiatorDimensions.height * state.pxPerMM;

            const clearanceTopPx = state.radiatorClearances.top * state.pxPerMM;
            const clearanceBottomPx = state.radiatorClearances.bottom * state.pxPerMM;
            const clearanceLeftPx = state.radiatorClearances.left * state.pxPerMM;
            const clearanceRightPx = state.radiatorClearances.right * state.pxPerMM;

            // Calculate radiator box position (centered on click)
            const radiatorX = state.position.x - radiatorWidthPx / 2;
            const radiatorY = state.position.y - radiatorHeightPx / 2;

            // Draw clearance zone (red transparent)
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
            state.ctx.fillRect(
                radiatorX - clearanceLeftPx,
                radiatorY - clearanceTopPx,
                radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                radiatorHeightPx + clearanceTopPx + clearanceBottomPx
            );

            // Draw clearance outline (red dashed)
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.strokeRect(
                radiatorX - clearanceLeftPx,
                radiatorY - clearanceTopPx,
                radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                radiatorHeightPx + clearanceTopPx + clearanceBottomPx
            );
            state.ctx.setLineDash([]);

            // Draw radiator box (orange solid for visibility)
            state.ctx.fillStyle = 'rgba(237, 137, 54, 0.3)';
            state.ctx.fillRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

            state.ctx.strokeStyle = '#ed8936';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw labels
            state.ctx.fillStyle = '#333';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.fillText(`Radiator ${state.radiatorDimensions.width}√ó${state.radiatorDimensions.height}mm`, radiatorX + 10, radiatorY + 25);
            if (clearanceTopPx > 0) {
                state.ctx.fillText(`Clearances: ${state.radiatorClearances.top}mm ‚Üë`, radiatorX + 10, radiatorY - clearanceTopPx + 20);
            }
            state.ctx.fillText(`${state.radiatorClearances.bottom}mm ‚Üì`, radiatorX + 10, radiatorY + radiatorHeightPx + clearanceBottomPx - 10);

            // Show download button
            document.getElementById('downloadRadiatorMarkupBtn').style.display = 'block';
        }

        function drawPositionMarker(x, y) {
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 20, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();
            
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 2;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 30, y);
            state.ctx.lineTo(x + 30, y);
            state.ctx.moveTo(x, y - 30);
            state.ctx.lineTo(x, y + 30);
            state.ctx.stroke();
        }

        function startMarkingObstacle(type) {
            state.markingMode = type;
            state.markingPoints = [];

            let needsPoints;
            let firstMessage;

            // Point obstacles (single tap)
            if (type === 'corner' || type === 'downpipe' || type === 'boundary' || type === 'vertical-terminal') {
                needsPoints = 1;
                const displayName = type.replace(/-/g, ' ');
                firstMessage = `üëÜ Tap location of ${displayName}`;
            }
            // 2-point obstacles (windows)
            else if (type === 'window-openable' || type === 'window-fixed') {
                needsPoints = 2;
                const windowType = type === 'window-openable' ? 'openable window' : 'fixed window';
                firstMessage = `üëÜ Tap top-left corner of ${windowType}`;
            }
            // 2-point rectangular obstacles
            else {
                needsPoints = 2;
                const displayName = type.replace(/-/g, ' ');
                firstMessage = `üëÜ Tap top-left corner of ${displayName}`;
            }

            const status = document.getElementById('markingStatus');
            status.classList.add('active');
            status.textContent = firstMessage;

            // Add marking click listener
            state.canvas.removeEventListener('click', handleMarkingClick);
            state.canvas.addEventListener('click', handleMarkingClick);
        }

        // Helper function to convert click coordinates to canvas coordinates with zoom/pan
        function getCanvasCoordinates(e) {
            const rect = state.canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left) * state.canvasScale;
            let y = (e.clientY - rect.top) * state.canvasScale;

            // Reverse zoom and pan transformation
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            x = (x - (centerX - centerX * state.zoomLevel) - state.panX) / state.zoomLevel;
            y = (y - (centerY - centerY * state.zoomLevel) - state.panY) / state.zoomLevel;

            return {x, y};
        }

        function handleMarkingClick(e) {
            if (!state.markingMode) return;

            const {x, y} = getCanvasCoordinates(e);

            state.markingPoints.push({x, y});

            let needsPoints;
            if (state.markingMode === 'corner' || state.markingMode === 'downpipe') {
                needsPoints = 1;
            } else if (state.markingMode === 'window-openable' || state.markingMode === 'window-fixed') {
                needsPoints = 4;
            } else {
                needsPoints = 2;
            }

            // Draw temporary marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw rectangle preview for windows (2-point marking)
            if ((state.markingMode === 'window-openable' || state.markingMode === 'window-fixed') && state.markingPoints.length === 1) {
                const firstPoint = state.markingPoints[0];
                const width = x - firstPoint.x;
                const height = y - firstPoint.y;
                state.ctx.strokeStyle = '#667eea';
                state.ctx.lineWidth = 2;
                state.ctx.strokeRect(firstPoint.x, firstPoint.y, width, height);
            }

            if (state.markingPoints.length < needsPoints) {
                // Need more points
                const status = document.getElementById('markingStatus');
                const windowType = state.markingMode === 'window-openable' ? 'openable window' :
                                 state.markingMode === 'window-fixed' ? 'fixed window' : state.markingMode;

                if (state.markingMode === 'window-openable' || state.markingMode === 'window-fixed') {
                    status.textContent = `üëÜ Tap bottom-right corner of ${windowType}`;
                } else {
                    status.textContent = `üëÜ Tap bottom-right corner of ${state.markingMode}`;
                }
            } else {
                // Complete the obstacle
                completeObstacleMarking();
            }
        }

        function completeObstacleMarking() {
            const type = state.markingMode;
            const points = state.markingPoints;

            let obstacle;

            if (type === 'corner' || type === 'downpipe') {
                // Point obstacle - use a small fixed size
                const pointSize = 20;
                obstacle = {
                    type: type,
                    x: points[0].x - pointSize / 2,
                    y: points[0].y - pointSize / 2,
                    width: pointSize,
                    height: pointSize
                };
            } else if (type === 'window-openable' || type === 'window-fixed') {
                // 2-point window (top-left and bottom-right corners)
                const x1 = Math.min(points[0].x, points[1].x);
                const y1 = Math.min(points[0].y, points[1].y);
                const x2 = Math.max(points[0].x, points[1].x);
                const y2 = Math.max(points[0].y, points[1].y);

                obstacle = {
                    type: 'window',
                    windowType: type === 'window-openable' ? 'openable' : 'fixed',
                    points: [{x: x1, y: y1}, {x: x2, y: y2}], // Store 2 points (top-left, bottom-right)
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: y2 - y1
                };
            } else {
                // Rectangle obstacle
                const x1 = Math.min(points[0].x, points[1].x);
                const y1 = Math.min(points[0].y, points[1].y);
                const x2 = Math.max(points[0].x, points[1].x);
                const y2 = Math.max(points[0].y, points[1].y);

                obstacle = {
                    type: type,
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: y2 - y1
                };
            }

            state.obstacles.push(obstacle);

            // Redraw canvas with all obstacles
            redrawCanvasWithObstacles();

            // Update obstacle list
            updateObstaclesList();

            // Reset marking mode
            cancelMarking();

            // Show calculate button
            document.getElementById('calculateBtn').style.display = 'block';

            const status = document.getElementById('markingStatus');
            status.classList.add('active');
            const displayType = type === 'window-openable' ? 'openable window' :
                              type === 'window-fixed' ? 'fixed window' : type;
            status.textContent = `‚úÖ ${displayType} marked! Add more obstacles or click Calculate.`;
        }

        function cancelMarking() {
            state.markingMode = null;
            state.markingPoints = [];
            state.canvas.removeEventListener('click', handleMarkingClick);

            const status = document.getElementById('markingStatus');
            status.classList.remove('active');
            status.textContent = 'Select an obstacle type below to start marking';
        }

        function updateObstaclesList() {
            const list = document.getElementById('obstaclesListContent');
            const container = document.getElementById('obstaclesList');

            if (state.obstacles.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            list.innerHTML = state.obstacles.map((obs, index) => `
                <div class="obstacle-item">
                    <div>
                        <strong>${index + 1}. ${obs.type}</strong> -
                        Position: (${Math.round(obs.x)}, ${Math.round(obs.y)})
                        Size: ${Math.round(obs.width)}√ó${Math.round(obs.height)}px
                    </div>
                    <button class="obstacle-delete-btn" onclick="deleteObstacle(${index})">
                        Delete
                    </button>
                </div>
            `).join('');
        }

        function deleteObstacle(index) {
            state.obstacles.splice(index, 1);
            updateObstaclesList();
            redrawCanvasWithObstacles();

            if (state.obstacles.length === 0) {
                document.getElementById('calculateBtn').style.display = 'none';
            }
        }

        // Zoom and Pan Functions
        function zoomIn() {
            state.zoomLevel = Math.min(state.zoomLevel * 1.2, 5);
            applyZoomAndPan();
        }

        function zoomOut() {
            state.zoomLevel = Math.max(state.zoomLevel / 1.2, 0.5);
            applyZoomAndPan();
        }

        function resetZoom() {
            state.zoomLevel = 1;
            state.panX = 0;
            state.panY = 0;
            applyZoomAndPan();
        }

        function panUp() {
            state.panY += 50;
            applyZoomAndPan();
        }

        function panDown() {
            state.panY -= 50;
            applyZoomAndPan();
        }

        function panLeft() {
            state.panX += 50;
            applyZoomAndPan();
        }

        function panRight() {
            state.panX -= 50;
            applyZoomAndPan();
        }

        function applyZoomAndPan() {
            // Redraw with current zoom and pan
            if (state.zones) {
                drawClearanceZones();
            } else {
                redrawCanvasWithObstacles();
            }
        }

        // Long press object moving functionality
        function setupLongPressMove() {
            const canvas = state.canvas;

            canvas.addEventListener('mousedown', handleLongPressStart);
            canvas.addEventListener('touchstart', handleLongPressTouchStart);
            canvas.addEventListener('mousemove', handleObjectMove);
            canvas.addEventListener('touchmove', handleObjectMoveTouch);
            canvas.addEventListener('mouseup', handleLongPressEnd);
            canvas.addEventListener('touchend', handleLongPressEnd);
        }

        function handleLongPressStart(e) {
            if (!canMoveObject()) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            // Check if click is on placed object
            if (isClickOnObject(x, y)) {
                // Start long press timer
                state.longPressTimer = setTimeout(() => {
                    state.isMovingObject = true;
                    state.canvas.style.cursor = 'move';
                    showMessage('Moving object - drag to new position');
                }, 500); // 500ms for long press
            }
        }

        function handleLongPressTouchStart(e) {
            if (!canMoveObject() || e.touches.length !== 1) return;

            e.preventDefault();
            const rect = state.canvas.getBoundingClientRect();
            const x = (e.touches[0].clientX - rect.left) * state.canvasScale;
            const y = (e.touches[0].clientY - rect.top) * state.canvasScale;

            if (isClickOnObject(x, y)) {
                state.longPressTimer = setTimeout(() => {
                    state.isMovingObject = true;
                    showMessage('Moving object - drag to new position');
                }, 500);
            }
        }

        function handleObjectMove(e) {
            if (!state.isMovingObject) {
                // Cancel long press if mouse moves before timeout
                if (state.longPressTimer) {
                    clearTimeout(state.longPressTimer);
                    state.longPressTimer = null;
                }
                return;
            }

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            // Update position
            state.position = {x, y};

            // Redraw based on mode
            redrawObjectAtNewPosition();
        }

        function handleObjectMoveTouch(e) {
            if (!state.isMovingObject || e.touches.length !== 1) {
                if (state.longPressTimer) {
                    clearTimeout(state.longPressTimer);
                    state.longPressTimer = null;
                }
                return;
            }

            e.preventDefault();
            const rect = state.canvas.getBoundingClientRect();
            const x = (e.touches[0].clientX - rect.left) * state.canvasScale;
            const y = (e.touches[0].clientY - rect.top) * state.canvasScale;

            state.position = {x, y};
            redrawObjectAtNewPosition();
        }

        function handleLongPressEnd() {
            if (state.longPressTimer) {
                clearTimeout(state.longPressTimer);
                state.longPressTimer = null;
            }

            if (state.isMovingObject) {
                state.isMovingObject = false;
                state.canvas.style.cursor = 'crosshair';
                showMessage('Object moved successfully');
            }
        }

        function canMoveObject() {
            return state.position && (state.mode === 'boiler' || state.mode === 'radiator' || state.mode === 'cylinder');
        }

        function isClickOnObject(x, y) {
            if (!state.position) return false;

            // Check if click is within object bounds
            let width, height;

            if (state.mode === 'boiler' && state.boilerDimensions) {
                width = state.boilerDimensions.width * state.pxPerMM;
                height = state.boilerDimensions.height * state.pxPerMM;
            } else if (state.mode === 'radiator' && state.radiatorDimensions) {
                width = state.radiatorDimensions.width * state.pxPerMM;
                height = state.radiatorDimensions.height * state.pxPerMM;
            } else if (state.mode === 'cylinder' && state.cylinderDimensions) {
                width = state.cylinderDimensions.diameter * state.pxPerMM;
                height = state.cylinderDimensions.height * state.pxPerMM;
            } else {
                return false;
            }

            const objX = state.position.x - width / 2;
            const objY = state.position.y - height / 2;

            return x >= objX && x <= objX + width && y >= objY && y <= objY + height;
        }

        function redrawObjectAtNewPosition() {
            if (state.mode === 'boiler') {
                drawBoilerWithClearances();
            } else if (state.mode === 'radiator') {
                drawRadiatorWithClearances();
            } else if (state.mode === 'cylinder') {
                drawCylinderOnCanvas();
            }
        }

        function showMessage(msg) {
            const statusDiv = document.getElementById('positionStatus');
            if (statusDiv) {
                const originalText = statusDiv.textContent;
                statusDiv.textContent = msg;
                setTimeout(() => {
                    statusDiv.textContent = originalText;
                }, 2000);
            }
        }

        function setupPanControls() {
            const canvas = state.canvas;

            canvas.addEventListener('mousedown', startPan);
            canvas.addEventListener('mousemove', doPan);
            canvas.addEventListener('mouseup', endPan);
            canvas.addEventListener('mouseleave', endPan);

            // Touch events for mobile
            canvas.addEventListener('touchstart', startPanTouch);
            canvas.addEventListener('touchmove', doPanTouch);
            canvas.addEventListener('touchend', endPan);
        }

        function startPan(e) {
            // Only pan if not in marking mode and zoom is active
            if (!state.markingMode && state.zoomLevel !== 1) {
                state.isPanning = true;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                state.canvas.style.cursor = 'grabbing';
            }
        }

        function doPan(e) {
            if (state.isPanning) {
                const deltaX = e.clientX - state.lastPanX;
                const deltaY = e.clientY - state.lastPanY;

                state.panX += deltaX;
                state.panY += deltaY;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;

                applyZoomAndPan();
            }
        }

        function endPan() {
            if (state.isPanning) {
                state.isPanning = false;
                state.canvas.style.cursor = state.zoomLevel === 1 ? 'crosshair' : 'grab';
            }
        }

        function startPanTouch(e) {
            if (!state.markingMode && state.zoomLevel !== 1 && e.touches.length === 1) {
                e.preventDefault();
                state.isPanning = true;
                state.lastPanX = e.touches[0].clientX;
                state.lastPanY = e.touches[0].clientY;
            }
        }

        function doPanTouch(e) {
            if (state.isPanning && e.touches.length === 1) {
                e.preventDefault();
                const deltaX = e.touches[0].clientX - state.lastPanX;
                const deltaY = e.touches[0].clientY - state.lastPanY;

                state.panX += deltaX;
                state.panY += deltaY;
                state.lastPanX = e.touches[0].clientX;
                state.lastPanY = e.touches[0].clientY;

                applyZoomAndPan();
            }
        }

        function redrawCanvasWithObstacles() {
            // Clear and redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);

            // Apply zoom and pan transformation
            state.ctx.save();
            const rect = state.canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            state.ctx.translate(state.panX / state.canvasScale, state.panY / state.canvasScale);
            state.ctx.scale(state.zoomLevel, state.zoomLevel);
            state.ctx.translate((centerX - centerX * state.zoomLevel) / state.canvasScale, (centerY - centerY * state.zoomLevel) / state.canvasScale);

            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw position marker based on mode
            if (state.position) {
                if (state.mode === 'boiler' && state.boilerDimensions) {
                    // Draw boiler box with clearances
                    const boilerWidthPx = state.boilerDimensions.width * state.pxPerMM;
                    const boilerHeightPx = state.boilerDimensions.height * state.pxPerMM;

                    const clearanceTopPx = state.boilerClearances.top * state.pxPerMM;
                    const clearanceBottomPx = state.boilerClearances.bottom * state.pxPerMM;
                    const clearanceLeftPx = state.boilerClearances.left * state.pxPerMM;
                    const clearanceRightPx = state.boilerClearances.right * state.pxPerMM;

                    const boilerX = state.position.x - boilerWidthPx / 2;
                    const boilerY = state.position.y - boilerHeightPx / 2;

                    // Draw clearance zone (red transparent)
                    state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
                    state.ctx.fillRect(
                        boilerX - clearanceLeftPx,
                        boilerY - clearanceTopPx,
                        boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                        boilerHeightPx + clearanceTopPx + clearanceBottomPx
                    );

                    // Draw clearance outline (red dashed)
                    state.ctx.strokeStyle = '#f56565';
                    state.ctx.lineWidth = 3;
                    state.ctx.setLineDash([10, 5]);
                    state.ctx.strokeRect(
                        boilerX - clearanceLeftPx,
                        boilerY - clearanceTopPx,
                        boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                        boilerHeightPx + clearanceTopPx + clearanceBottomPx
                    );
                    state.ctx.setLineDash([]);

                    // Draw boiler box (green solid)
                    state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
                    state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    state.ctx.strokeStyle = '#48bb78';
                    state.ctx.lineWidth = 4;
                    state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    // Draw center marker
                    state.ctx.fillStyle = '#667eea';
                    state.ctx.beginPath();
                    state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                } else if (state.mode === 'radiator' && state.radiatorDimensions) {
                    // Draw radiator box with clearances
                    const radiatorWidthPx = state.radiatorDimensions.width * state.pxPerMM;
                    const radiatorHeightPx = state.radiatorDimensions.height * state.pxPerMM;

                    const clearanceTopPx = state.radiatorClearances.top * state.pxPerMM;
                    const clearanceBottomPx = state.radiatorClearances.bottom * state.pxPerMM;
                    const clearanceLeftPx = state.radiatorClearances.left * state.pxPerMM;
                    const clearanceRightPx = state.radiatorClearances.right * state.pxPerMM;

                    const radiatorX = state.position.x - radiatorWidthPx / 2;
                    const radiatorY = state.position.y - radiatorHeightPx / 2;

                    // Draw clearance zone (red transparent)
                    state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
                    state.ctx.fillRect(
                        radiatorX - clearanceLeftPx,
                        radiatorY - clearanceTopPx,
                        radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                        radiatorHeightPx + clearanceTopPx + clearanceBottomPx
                    );

                    // Draw clearance outline (red dashed)
                    state.ctx.strokeStyle = '#f56565';
                    state.ctx.lineWidth = 3;
                    state.ctx.setLineDash([10, 5]);
                    state.ctx.strokeRect(
                        radiatorX - clearanceLeftPx,
                        radiatorY - clearanceTopPx,
                        radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                        radiatorHeightPx + clearanceTopPx + clearanceBottomPx
                    );
                    state.ctx.setLineDash([]);

                    // Draw radiator box (orange solid)
                    state.ctx.fillStyle = 'rgba(237, 137, 54, 0.3)';
                    state.ctx.fillRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

                    state.ctx.strokeStyle = '#ed8936';
                    state.ctx.lineWidth = 4;
                    state.ctx.strokeRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

                    // Draw center marker
                    state.ctx.fillStyle = '#667eea';
                    state.ctx.beginPath();
                    state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                } else {
                    // Draw flue position marker
                    drawPositionMarker(state.position.x, state.position.y);
                }
            }

            // Draw all obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];

                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 4;

                // Draw all obstacles as rectangles
                state.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                // Label
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 20px Arial';
                const displayType = obs.type === 'window' ? `${obs.windowType || ''} window`.trim() : obs.type;
                state.ctx.fillText(`${index + 1}: ${displayType}`, obs.x + 5, obs.y + 25);
            });

            // Restore context state
            state.ctx.restore();
        }

        function calculateClearances() {
            if (!state.position || !state.pxPerMM) {
                alert('Missing position or calibration data');
                return;
            }

            let rules;
            if (state.mode === 'flue') {
                // Use CSV-based clearances for flue mode
                if (!state.flueClearances) {
                    alert('Please select a brand and model first');
                    return;
                }
                rules = state.flueClearances;
            } else {
                // Use hardcoded rules for boiler/radiator modes
                const brand = document.getElementById('brandSelect').value;
                rules = CLEARANCE_RULES[brand][state.mode];
            }

            // Calculate clearance zones for each obstacle
            state.zones = {
                prohibited: [],
                safe: []
            };

            state.obstacles.forEach(obs => {
                const clearanceMM = state.mode === 'flue' ?
                    getClearanceForObjectFlue(obs, rules) :
                    getClearanceForObject(obs.type, rules);
                if (clearanceMM === null) return;

                const clearancePx = clearanceMM * state.pxPerMM;

                // Calculate zone based on obstacle type
                let zoneX, zoneY, zoneMaxX, zoneMaxY;

                // Point obstacles get circular zones
                const pointObstacles = ['corner', 'downpipe', 'boundary', 'vertical-terminal'];
                if (pointObstacles.includes(obs.type)) {
                    // Circular zone for point obstacles
                    const centerX = obs.x + obs.width / 2;
                    const centerY = obs.y + obs.height / 2;

                    zoneX = centerX - clearancePx;
                    zoneY = centerY - clearancePx;
                    zoneMaxX = centerX + clearancePx;
                    zoneMaxY = centerY + clearancePx;
                } else {
                    // Directional zone for rectangular obstacles
                    const flueLeft = state.position.x < obs.x;
                    const flueRight = state.position.x > obs.x + obs.width;
                    const flueAbove = state.position.y < obs.y;
                    const flueBelow = state.position.y > obs.y + obs.height;

                    zoneX = flueLeft ? obs.x - clearancePx : obs.x - clearancePx * 0.3;
                    zoneY = flueAbove ? obs.y - clearancePx : obs.y - clearancePx * 0.3;
                    zoneMaxX = flueRight ? obs.x + obs.width + clearancePx : obs.x + obs.width + clearancePx * 0.3;
                    zoneMaxY = flueBelow ? obs.y + obs.height + clearancePx : obs.y + obs.height + clearancePx * 0.3;
                }

                // Clamp to image boundaries
                const clampedX = Math.max(0, zoneX);
                const clampedY = Math.max(0, zoneY);
                const clampedMaxX = Math.min(state.canvas.width, zoneMaxX);
                const clampedMaxY = Math.min(state.canvas.height, zoneMaxY);

                const finalWidth = clampedMaxX - clampedX;
                const finalHeight = clampedMaxY - clampedY;

                if (finalWidth > 0 && finalHeight > 0) {
                    const zone = {
                        x: clampedX,
                        y: clampedY,
                        width: finalWidth,
                        height: finalHeight,
                        reason: `${clearanceMM}mm clearance from ${obs.type}`,
                        objectType: obs.type,
                        clearanceMM: clearanceMM
                    };

                    // Store window points for specialized rendering
                    if (obs.type === 'window' && obs.points && obs.points.length === 2) {
                        zone.windowPoints = obs.points;
                        zone.windowType = obs.windowType;
                    }

                    state.zones.prohibited.push(zone);
                }
            });

            // Draw zones and check compliance
            drawClearanceZones();
            checkCompliance();

            // Show results panel
            document.getElementById('resultsPanel').classList.add('active');

            // Show flue output section if in flue mode
            if (state.mode === 'flue') {
                document.getElementById('flueOutputSection').style.display = 'block';
            }
        }

        function getClearanceForObject(objectType, rules) {
            const mapping = {
                window: "window",
                door: "door",
                corner: "corner",
                soffit: "soffit",
                vent: "vent",
                downpipe: "downpipe"
            };

            const ruleKey = mapping[objectType];
            return ruleKey ? (rules[ruleKey] ?? null) : null;
        }

        function getClearanceForObjectFlue(obstacle, flueClearances) {
            const objectType = obstacle.type;

            // Map obstacle type to CSV position/scenario
            let mapping;

            if (state.flueType === 'vertical') {
                // Vertical flue obstacle mappings
                mapping = {
                    'boundary': ['Boundary vertical', 'Boundary', 'Adjacent to boundary'],
                    'window-vent-vertical': ['To window/door/vent vertically', 'To opening (window/vent) horizontally', 'Openings'],
                    'pitched-roof': ['To pitched roof', 'Diagonal from pitched roof'],
                    'velux-below': ['To Velux below'],
                    'velux-above-sides': ['To Velux above/sides'],
                    'skylight': ['To skylight/opening vertically', 'To skylight other vertical flue'],
                    'combustible-material': ['To combustible material'],
                    'vertical-terminal': ['Between vertical terminals', 'Separation vertical ‚Üî horizontal', 'To skylight other vertical flue']
                };
            } else {
                // Horizontal flue obstacle mappings
                mapping = {
                    window: obstacle.windowType === 'fixed' ?
                        ['Change of fabric', 'Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'] :
                        ['Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'],
                    door: ['Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'],
                    vent: ['Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'],
                    corner: ['Internal/external corner', 'Corner', 'Outside corner'],
                    soffit: ['Below eaves/gutters/pipes', 'Eaves/gutters', 'Eaves/gutter'],
                    downpipe: ['Drainpipes/soil pipes', 'Below eaves/gutters/pipes']
                };
            }

            const positions = mapping[objectType];
            if (!positions) return null;

            // Try to find matching clearance from CSV
            for (const pos of positions) {
                if (flueClearances[pos]) {
                    return flueClearances[pos].clearanceMM;
                }
            }

            // Check if "Outside corner" rule exists (260mm) for horizontal flues
            if (objectType === 'corner' && flueClearances['Outside corner']) {
                return flueClearances['Outside corner'].clearanceMM;
            }

            return null;
        }

        function togglePlumeKitMode() {
            state.plumeKitMode = document.getElementById('plumeKitToggle').checked;
            // Redraw clearance zones with updated mode
            if (state.zones) {
                drawClearanceZones();
                checkCompliance();
            }
        }

        function checkCompliance() {
            if (!state.position || !state.zones) return;

            let hasConflict = false;

            // Check if position is inside any prohibited zone
            const pointObstacles = ['corner', 'downpipe', 'boundary', 'vertical-terminal'];
            for (const zone of state.zones.prohibited) {
                if (pointObstacles.includes(zone.objectType)) {
                    // Check circular zone
                    const centerX = zone.x + zone.width / 2;
                    const centerY = zone.y + zone.height / 2;
                    let radius = zone.width / 2;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        radius = radius * 0.5;
                    }

                    const distance = Math.sqrt(
                        Math.pow(state.position.x - centerX, 2) +
                        Math.pow(state.position.y - centerY, 2)
                    );
                    if (distance < radius) {
                        hasConflict = true;
                        break;
                    }
                } else if (zone.objectType === 'window' && zone.windowPoints) {
                    // Check window clearance zone with circles and parallel lines
                    if (isPointInWindowClearance(state.position.x, state.position.y, zone.windowPoints, zone.clearanceMM)) {
                        hasConflict = true;
                        break;
                    }
                } else {
                    // Check rectangular zone
                    let zoneX = zone.x;
                    let zoneY = zone.y;
                    let zoneWidth = zone.width;
                    let zoneHeight = zone.height;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        zoneWidth = zone.width * 0.5;
                        zoneHeight = zone.height * 0.5;
                        zoneX = zone.x + (zone.width - zoneWidth) / 2;
                        zoneY = zone.y + (zone.height - zoneHeight) / 2;
                    }

                    if (state.position.x >= zoneX &&
                        state.position.x <= zoneX + zoneWidth &&
                        state.position.y >= zoneY &&
                        state.position.y <= zoneY + zoneHeight) {
                        hasConflict = true;
                        break;
                    }
                }
            }

            const resultDiv = document.getElementById('complianceResult');
            if (hasConflict) {
                resultDiv.className = 'compliance-fail';
                resultDiv.innerHTML = '‚ùå FAIL - Position conflicts with clearance zones!<br><br>The flue/boiler position violates minimum clearance requirements.';
            } else {
                resultDiv.className = 'compliance-pass';
                resultDiv.innerHTML = '‚úÖ PASS - Position complies with clearance requirements!<br><br>The flue/boiler can be safely installed at this location.';
            }
        }

        function drawCircularClearance(x, y, radiusPx, color, dashPattern) {
            state.ctx.fillStyle = color;
            state.ctx.strokeStyle = color.replace('0.3', '0.8'); // More opaque stroke
            state.ctx.lineWidth = 3;
            if (dashPattern) state.ctx.setLineDash(dashPattern);

            state.ctx.beginPath();
            state.ctx.arc(x, y, radiusPx, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            if (dashPattern) state.ctx.setLineDash([]);
        }

        // Helper function to draw rounded rectangle
        function drawRoundedRect(ctx, x, y, width, height, radius, fill = false, stroke = true) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }

        // Check if a point is inside window clearance zone (hashed box with rounded corners)
        function isPointInWindowClearance(x, y, points, clearanceMM) {
            if (!points || points.length !== 2 || !state.pxPerMM) return false;

            const clearancePx = clearanceMM * state.pxPerMM;
            const effectiveClearancePx = state.plumeKitMode ? clearancePx * 0.5 : clearancePx;

            // Extract window boundaries
            const topLeft = points[0];
            const bottomRight = points[1];
            const windowLeft = topLeft.x;
            const windowTop = topLeft.y;
            const windowRight = bottomRight.x;
            const windowBottom = bottomRight.y;

            // The clearance zone extends from the window edge outward by the clearance distance
            // Outer boundary (clearance limit) - bounding box of the rounded rectangle
            const outerLeft = windowLeft - effectiveClearancePx;
            const outerTop = windowTop - effectiveClearancePx;
            const outerRight = windowRight + effectiveClearancePx;
            const outerBottom = windowBottom + effectiveClearancePx;

            // Inner boundary (window edge)
            const innerLeft = windowLeft;
            const innerTop = windowTop;
            const innerRight = windowRight;
            const innerBottom = windowBottom;

            // First check: Is point completely outside the outer bounding box?
            if (x < outerLeft || x > outerRight || y < outerTop || y > outerBottom) {
                return false;
            }

            // Second check: Is point inside the window itself?
            const insideInner = x >= innerLeft && x <= innerRight &&
                               y >= innerTop && y <= innerBottom;
            if (insideInner) {
                return false;
            }

            // Now we know the point is in the annular region between outer and inner rectangles
            // We need to check if it's within the rounded corners

            const radius = effectiveClearancePx;

            // Define corner centers for the outer rounded rectangle
            const corners = [
                { cx: outerLeft + radius, cy: outerTop + radius, type: 'top-left' },
                { cx: outerRight - radius, cy: outerTop + radius, type: 'top-right' },
                { cx: outerRight - radius, cy: outerBottom - radius, type: 'bottom-right' },
                { cx: outerLeft + radius, cy: outerBottom - radius, type: 'bottom-left' }
            ];

            // Check if point is in a corner region
            for (const corner of corners) {
                const inCornerRegion = (
                    (corner.type === 'top-left' && x < corner.cx && y < corner.cy) ||
                    (corner.type === 'top-right' && x > corner.cx && y < corner.cy) ||
                    (corner.type === 'bottom-right' && x > corner.cx && y > corner.cy) ||
                    (corner.type === 'bottom-left' && x < corner.cx && y > corner.cy)
                );

                if (inCornerRegion) {
                    // Calculate distance from corner center
                    const dx = x - corner.cx;
                    const dy = y - corner.cy;
                    const distFromCenter = Math.sqrt(dx * dx + dy * dy);

                    // Point is in clearance zone if distance is within the radius
                    return distFromCenter <= radius;
                }
            }

            // Point is in a straight edge region (not in a corner), so it's in the clearance zone
            return true;
        }

        // Create a rounded rectangle path with quarter-circle corners
        function createRoundedRectPath(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            // Start from top edge, after the top-left radius
            ctx.moveTo(x + radius, y);
            // Top edge
            ctx.lineTo(x + width - radius, y);
            // Top-right corner (quarter circle)
            ctx.arc(x + width - radius, y + radius, radius, -Math.PI / 2, 0);
            // Right edge
            ctx.lineTo(x + width, y + height - radius);
            // Bottom-right corner (quarter circle)
            ctx.arc(x + width - radius, y + height - radius, radius, 0, Math.PI / 2);
            // Bottom edge
            ctx.lineTo(x + radius, y + height);
            // Bottom-left corner (quarter circle)
            ctx.arc(x + radius, y + height - radius, radius, Math.PI / 2, Math.PI);
            // Left edge
            ctx.lineTo(x, y + radius);
            // Top-left corner (quarter circle)
            ctx.arc(x + radius, y + radius, radius, Math.PI, -Math.PI / 2);
            ctx.closePath();
        }

        // Draw diagonal hatch lines inside a region
        function drawDiagonalHatch(ctx, x, y, width, height, spacing = 20, angle = 45) {
            ctx.save();

            // Convert angle to radians
            const angleRad = angle * Math.PI / 180;

            // Calculate the diagonal span needed to cover the entire rectangle
            const diagonalLength = Math.sqrt(width * width + height * height) * 2;

            // Start position for hatch lines
            const startX = x - diagonalLength;
            const startY = y;

            // Draw hatch lines
            ctx.beginPath();
            for (let offset = 0; offset < diagonalLength * 2; offset += spacing) {
                const lineStartX = startX + offset;
                const lineStartY = startY;
                const lineEndX = lineStartX + diagonalLength * Math.cos(angleRad);
                const lineEndY = lineStartY + diagonalLength * Math.sin(angleRad);

                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineEndX, lineEndY);
            }
            ctx.stroke();

            ctx.restore();
        }

        // Draw window clearance on any canvas context using hashed box with rounded corners
        function drawWindowClearanceOnCanvas(ctx, points, clearanceMM, fillStyle, strokeStyle, dashPattern) {
            if (!points || points.length !== 2 || !state.pxPerMM) return;

            // Calculate clearance in pixels
            const clearancePx = clearanceMM * state.pxPerMM;

            // Apply 50% reduction for plume kit mode
            const effectiveClearance = state.plumeKitMode ? clearancePx * 0.5 : clearancePx;

            // Extract top-left and bottom-right corners
            const topLeft = points[0];
            const bottomRight = points[1];

            // Window rectangle dimensions
            const windowLeft = topLeft.x;
            const windowTop = topLeft.y;
            const windowRight = bottomRight.x;
            const windowBottom = bottomRight.y;
            const windowWidth = windowRight - windowLeft;
            const windowHeight = windowBottom - windowTop;

            // Calculate outer rectangle (window + clearance)
            const outerX = windowLeft - effectiveClearance;
            const outerY = windowTop - effectiveClearance;
            const outerWidth = windowWidth + (2 * effectiveClearance);
            const outerHeight = windowHeight + (2 * effectiveClearance);

            // Corner radius equals the clearance distance
            const cornerRadius = effectiveClearance;

            // Save context state
            ctx.save();

            // Create the rounded rectangle path for the clearance zone
            createRoundedRectPath(ctx, outerX, outerY, outerWidth, outerHeight, cornerRadius);

            // Clip to this region for hatching
            ctx.clip();

            // Fill with base color
            if (fillStyle) {
                ctx.fillStyle = fillStyle;
                createRoundedRectPath(ctx, outerX, outerY, outerWidth, outerHeight, cornerRadius);
                ctx.fill();
            }

            // Draw diagonal hatch lines
            ctx.strokeStyle = strokeStyle || 'rgba(200, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            if (dashPattern) ctx.setLineDash(dashPattern);
            else ctx.setLineDash([]);

            // Draw 45-degree diagonal hatching
            const hatchSpacing = 25; // 25mm spacing between hatch lines
            drawDiagonalHatch(ctx, outerX, outerY, outerWidth, outerHeight, hatchSpacing, 45);

            // Restore to remove clipping
            ctx.restore();

            // Draw the outline border
            ctx.save();
            ctx.strokeStyle = strokeStyle || 'rgba(200, 0, 0, 0.8)';
            ctx.lineWidth = 3;
            if (dashPattern) ctx.setLineDash(dashPattern);
            else ctx.setLineDash([]);

            createRoundedRectPath(ctx, outerX, outerY, outerWidth, outerHeight, cornerRadius);
            ctx.stroke();

            ctx.restore();
        }

        // Draw window clearance with circles at corners and parallel lines (uses state.ctx)
        function drawWindowClearance(points, clearanceMM, fillStyle, strokeStyle, dashPattern) {
            drawWindowClearanceOnCanvas(state.ctx, points, clearanceMM, fillStyle, strokeStyle, dashPattern);
        }

        function drawClearanceZones() {
            // Redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);

            // Apply zoom and pan transformation
            state.ctx.save();
            const rect = state.canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            state.ctx.translate(state.panX / state.canvasScale, state.panY / state.canvasScale);
            state.ctx.scale(state.zoomLevel, state.zoomLevel);
            state.ctx.translate((centerX - centerX * state.zoomLevel) / state.canvasScale, (centerY - centerY * state.zoomLevel) / state.canvasScale);

            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            if (!state.zones) {
                state.ctx.restore();
                return;
            }

            // Draw obstacles first
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 3;

                // Draw all obstacles as rectangles
                state.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                // Label the object
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 16px Arial';
                const displayType = obs.type === 'window' ? `${obs.windowType || ''} window`.trim() : obs.type;
                state.ctx.fillText(`${index + 1}: ${displayType}`, obs.x + 5, obs.y + 22);
            });
            
            const prohibitedFill = 'rgba(245, 101, 101, 0.3)';
            const prohibitedStroke = '#f56565';
            const prohibitedDash = [10, 5];

            const applyProhibitedStyles = () => {
                state.ctx.fillStyle = prohibitedFill;
                state.ctx.strokeStyle = prohibitedStroke;
                state.ctx.lineWidth = 3;
                state.ctx.setLineDash(prohibitedDash);
            };

            // Draw prohibited zones (red)
            applyProhibitedStyles();
            state.zones.prohibited.forEach(zone => {
                if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                    const centerX = zone.x + zone.width / 2;
                    const centerY = zone.y + zone.height / 2;
                    let radiusPx = Math.min(zone.width, zone.height) / 2;

                    if (state.pxPerMM && zone.reason) {
                        const match = zone.reason.match(/([\d.]+)\s*mm/i);
                        if (match) {
                            radiusPx = parseFloat(match[1]) * state.pxPerMM;
                        }
                    }

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        radiusPx = radiusPx * 0.5;
                    }

                    drawCircularClearance(centerX, centerY, radiusPx, prohibitedFill, prohibitedDash);
                    applyProhibitedStyles();
                } else if (zone.objectType === 'window' && zone.windowPoints) {
                    // Use special window clearance with circles at corners and parallel lines
                    drawWindowClearance(zone.windowPoints, zone.clearanceMM, prohibitedFill, prohibitedStroke, prohibitedDash);
                    applyProhibitedStyles();
                } else {
                    // Use rounded rectangles for clearance zones (300mm corner radius)
                    const cornerRadius = state.pxPerMM ? 300 * state.pxPerMM : 15;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        const reducedWidth = zone.width * 0.5;
                        const reducedHeight = zone.height * 0.5;
                        const offsetX = (zone.width - reducedWidth) / 2;
                        const offsetY = (zone.height - reducedHeight) / 2;
                        drawRoundedRect(state.ctx, zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight, cornerRadius, true, true);
                    } else {
                        drawRoundedRect(state.ctx, zone.x, zone.y, zone.width, zone.height, cornerRadius, true, true);
                    }
                }
            });

            state.ctx.setLineDash([]);
            
            // Draw restricted zones (blue)
            const restrictedFill = 'rgba(66, 153, 225, 0.2)';
            const restrictedStroke = '#4299e1';
            const restrictedDash = [5, 5];

            state.ctx.fillStyle = restrictedFill;
            state.ctx.strokeStyle = restrictedStroke;
            state.ctx.lineWidth = 2;
            state.ctx.setLineDash(restrictedDash);

            state.zones.restricted.forEach(zone => {
                if (zone.objectType === 'window' && zone.windowPoints) {
                    // Use special window clearance with circles at corners and parallel lines
                    drawWindowClearance(zone.windowPoints, zone.clearanceMM, restrictedFill, restrictedStroke, restrictedDash);
                } else {
                    const cornerRadius = state.pxPerMM ? 300 * state.pxPerMM : 15;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        const reducedWidth = zone.width * 0.5;
                        const reducedHeight = zone.height * 0.5;
                        const offsetX = (zone.width - reducedWidth) / 2;
                        const offsetY = (zone.height - reducedHeight) / 2;
                        drawRoundedRect(state.ctx, zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight, cornerRadius, true, true);
                    } else {
                        drawRoundedRect(state.ctx, zone.x, zone.y, zone.width, zone.height, cornerRadius, true, true);
                    }
                }
            });
            
            state.ctx.setLineDash([]);

            // Redraw position marker on top based on mode
            if (state.position) {
                if (state.mode === 'boiler' && state.boilerDimensions) {
                    // Draw boiler box with clearances
                    const boilerWidthPx = state.boilerDimensions.width * state.pxPerMM;
                    const boilerHeightPx = state.boilerDimensions.height * state.pxPerMM;

                    const boilerX = state.position.x - boilerWidthPx / 2;
                    const boilerY = state.position.y - boilerHeightPx / 2;

                    // Draw boiler box (green solid)
                    state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
                    state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    state.ctx.strokeStyle = '#48bb78';
                    state.ctx.lineWidth = 4;
                    state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    // Draw center marker
                    state.ctx.fillStyle = '#667eea';
                    state.ctx.beginPath();
                    state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                } else {
                    drawPositionMarker(state.position.x, state.position.y);
                }
            }
        }

        function redrawCanvas() {
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Restore context state
            state.ctx.restore();
        }

        function drawCalibrationOverlay() {
            if (state.calibrationPoints.length === 4) {
                const points = state.calibrationPoints;
                
                state.ctx.strokeStyle = '#48bb78';
                state.ctx.lineWidth = 3;
                state.ctx.beginPath();
                state.ctx.moveTo(points[0].x, points[0].y);
                state.ctx.lineTo(points[1].x, points[1].y);
                state.ctx.lineTo(points[2].x, points[2].y);
                state.ctx.lineTo(points[3].x, points[3].y);
                state.ctx.closePath();
                state.ctx.stroke();
                
                points.forEach((point, i) => {
                    state.ctx.fillStyle = '#f56565';
                    state.ctx.beginPath();
                    state.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                    
                    state.ctx.fillStyle = 'white';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.textAlign = 'center';
                    state.ctx.textBaseline = 'middle';
                    state.ctx.fillText(i + 1, point.x, point.y);
                });
            }
        }

        function resetCalibration() {
            state.calibrationPoints = [];
            state.isCalibrating = false;
            state.pxPerMM = null;
            state.position = null;
            state.mode = null;
            state.obstacles = [];
            state.markingMode = null;
            state.markingPoints = [];
            state.zones = null;
            state.plumeKitMode = false;
            document.getElementById('plumeKitToggle').checked = false;

            if (state.photo) {
                state.ctx.drawImage(state.photo, 0, 0);
            }

            updatePointsDisplay();

            document.getElementById('tapStatus').classList.remove('active');
            document.getElementById('tapStatus').classList.remove('warning');
            document.getElementById('tapStatus').textContent = 'Choose calibration method below';
            document.getElementById('calibrationInfo').classList.remove('active');
            document.getElementById('pointsDisplay').style.display = 'none';
            document.getElementById('analysisCard').style.display = 'none';
            document.getElementById('positionInstructions').style.display = 'none';
            document.getElementById('obstacleMarkingSection').style.display = 'none';
            document.getElementById('resultsPanel').classList.remove('active');

            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleMarkingClick);
        }

        function updatePointsDisplay() {
            document.getElementById('pointCount').textContent = state.calibrationPoints.length;
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function testClick() {
            alert('Button works! Mode: ' + state.mode + ', Canvas: ' + !!state.canvas);

            console.log('=== TEST CLICK DEBUG ===');
            console.log('State mode:', state.mode);
            console.log('Canvas exists:', !!state.canvas);
            console.log('Canvas:', state.canvas);

            if (!state.canvas) {
                alert('ERROR: Canvas is null!');
                return;
            }

            // Try adding listener directly
            state.canvas.onclick = function(e) {
                alert('Canvas clicked!');
                const rect = state.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * state.canvasScale;
                const y = (e.clientY - rect.top) * state.canvasScale;
                alert('Position: ' + Math.round(x) + ', ' + Math.round(y));
            };

            alert('Direct onclick handler added! Try clicking the canvas now.');
        }

        // Flue Output Generation Functions
        function generateStandardFlueOutput() {
            const canvas = document.getElementById('standardFlueCanvas');
            canvas.width = state.canvas.width;
            canvas.height = state.canvas.height;
            const ctx = canvas.getContext('2d');

            // Draw base image
            ctx.drawImage(state.photo, 0, 0);

            // Draw calibration overlay
            drawCalibrationOverlayOnCanvas(ctx);

            // Draw obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;

                // Draw all obstacles as rectangles
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                ctx.fillStyle = color;
                ctx.font = 'bold 16px Arial';
                const displayType = obs.type === 'window' ? `${obs.windowType || ''} window`.trim() : obs.type;
                ctx.fillText(`${index + 1}: ${displayType}`, obs.x + 5, obs.y + 22);
            });

            // Draw prohibited zones (RED)
            const prohibitedFill = 'rgba(245, 101, 101, 0.4)';
            const prohibitedStroke = '#f56565';
            const prohibitedDash = [10, 5];

            ctx.fillStyle = prohibitedFill;
            ctx.strokeStyle = prohibitedStroke;
            ctx.lineWidth = 3;
            ctx.setLineDash(prohibitedDash);

            if (state.zones && state.zones.prohibited) {
                state.zones.prohibited.forEach(zone => {
                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = zone.width / 2;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (zone.objectType === 'window' && zone.windowPoints) {
                        // Use special window clearance with circles at corners and parallel lines
                        drawWindowClearanceOnCanvas(ctx, zone.windowPoints, zone.clearanceMM, prohibitedFill, prohibitedStroke, prohibitedDash);
                    } else {
                        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
                    }
                });
            }

            ctx.setLineDash([]);

            // Draw acceptable zones (GREEN) - areas outside prohibited zones
            ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Re-draw prohibited zones to overlap green
            ctx.fillStyle = prohibitedFill;
            ctx.strokeStyle = prohibitedStroke;
            ctx.lineWidth = 3;
            ctx.setLineDash(prohibitedDash);

            if (state.zones && state.zones.prohibited) {
                state.zones.prohibited.forEach(zone => {
                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = zone.width / 2;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (zone.objectType === 'window' && zone.windowPoints) {
                        // Use special window clearance with circles at corners and parallel lines
                        drawWindowClearanceOnCanvas(ctx, zone.windowPoints, zone.clearanceMM, prohibitedFill, prohibitedStroke, prohibitedDash);
                    } else {
                        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
                    }
                });
            }

            ctx.setLineDash([]);

            // Draw flue position marker
            if (state.position) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(state.position.x, state.position.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Add legend
            drawLegendOnCanvas(ctx, canvas.width, canvas.height, 'Standard Flue');

            document.getElementById('outputImagesSection').style.display = 'block';
        }

        function generatePlumeManagementOutput() {
            const canvas = document.getElementById('plumeCanvas');
            canvas.width = state.canvas.width;
            canvas.height = state.canvas.height;
            const ctx = canvas.getContext('2d');

            // Draw base image
            ctx.drawImage(state.photo, 0, 0);

            // Draw calibration overlay
            drawCalibrationOverlayOnCanvas(ctx);

            // Draw obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;

                // Draw all obstacles as rectangles
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                ctx.fillStyle = color;
                ctx.font = 'bold 16px Arial';
                const displayType = obs.type === 'window' ? `${obs.windowType || ''} window`.trim() : obs.type;
                ctx.fillText(`${index + 1}: ${displayType}`, obs.x + 5, obs.y + 22);
            });

            // For plume management, reduce clearances by 50% (plume kits reduce clearance requirements)
            const plumeProhibitedFill = 'rgba(245, 101, 101, 0.3)';
            const plumeProhibitedStroke = '#f56565';
            const plumeProhibitedDash = [10, 5];

            ctx.fillStyle = plumeProhibitedFill;
            ctx.strokeStyle = plumeProhibitedStroke;
            ctx.lineWidth = 3;
            ctx.setLineDash(plumeProhibitedDash);

            if (state.zones && state.zones.prohibited) {
                // Temporarily enable plume kit mode for drawing
                const originalPlumeMode = state.plumeKitMode;
                state.plumeKitMode = true;

                state.zones.prohibited.forEach(zone => {
                    // Reduce zone size by 50% for plume management
                    const reducedWidth = zone.width * 0.5;
                    const reducedHeight = zone.height * 0.5;
                    const offsetX = (zone.width - reducedWidth) / 2;
                    const offsetY = (zone.height - reducedHeight) / 2;

                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = (zone.width / 2) * 0.5;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (zone.objectType === 'window' && zone.windowPoints) {
                        // Use special window clearance with circles at corners and parallel lines (50% reduced)
                        drawWindowClearanceOnCanvas(ctx, zone.windowPoints, zone.clearanceMM, plumeProhibitedFill, plumeProhibitedStroke, plumeProhibitedDash);
                    } else {
                        ctx.fillRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                        ctx.strokeRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                    }
                });

                // Restore plume kit mode
                state.plumeKitMode = originalPlumeMode;
            }

            ctx.setLineDash([]);

            // Draw acceptable zones (GREEN)
            ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Re-draw reduced prohibited zones
            ctx.fillStyle = plumeProhibitedFill;
            ctx.strokeStyle = plumeProhibitedStroke;
            ctx.lineWidth = 3;
            ctx.setLineDash(plumeProhibitedDash);

            if (state.zones && state.zones.prohibited) {
                // Temporarily enable plume kit mode for drawing
                const originalPlumeMode2 = state.plumeKitMode;
                state.plumeKitMode = true;

                state.zones.prohibited.forEach(zone => {
                    const reducedWidth = zone.width * 0.5;
                    const reducedHeight = zone.height * 0.5;
                    const offsetX = (zone.width - reducedWidth) / 2;
                    const offsetY = (zone.height - reducedHeight) / 2;

                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = (zone.width / 2) * 0.5;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (zone.objectType === 'window' && zone.windowPoints) {
                        // Use special window clearance with circles at corners and parallel lines (50% reduced)
                        drawWindowClearanceOnCanvas(ctx, zone.windowPoints, zone.clearanceMM, plumeProhibitedFill, plumeProhibitedStroke, plumeProhibitedDash);
                    } else {
                        ctx.fillRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                        ctx.strokeRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                    }
                });

                // Restore plume kit mode
                state.plumeKitMode = originalPlumeMode2;
            }

            ctx.setLineDash([]);

            // Draw flue position marker
            if (state.position) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(state.position.x, state.position.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Add legend
            drawLegendOnCanvas(ctx, canvas.width, canvas.height, 'Plume Management');

            document.getElementById('outputImagesSection').style.display = 'block';
        }

        function drawCalibrationOverlayOnCanvas(ctx) {
            if (state.calibrationPoints.length === 4) {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                state.calibrationPoints.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function drawLegendOnCanvas(ctx, width, height, title) {
            const legendX = width - 250;
            const legendY = 20;

            // Background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(legendX, legendY, 230, 120);
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX, legendY, 230, 120);

            // Title
            ctx.fillStyle = '#667eea';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(title, legendX + 10, legendY + 25);

            // Legend items
            ctx.font = '14px Arial';

            // Red box
            ctx.fillStyle = 'rgba(245, 101, 101, 0.4)';
            ctx.fillRect(legendX + 10, legendY + 40, 30, 20);
            ctx.strokeStyle = '#f56565';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX + 10, legendY + 40, 30, 20);
            ctx.fillStyle = '#333';
            ctx.fillText('Prohibited Zone', legendX + 50, legendY + 55);

            // Green box
            ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            ctx.fillRect(legendX + 10, legendY + 70, 30, 20);
            ctx.strokeStyle = '#48bb78';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX + 10, legendY + 70, 30, 20);
            ctx.fillStyle = '#333';
            ctx.fillText('Acceptable Zone', legendX + 50, legendY + 85);

            // Flue marker
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(legendX + 25, legendY + 108, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Flue Terminal', legendX + 50, legendY + 113);
        }

        function downloadCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function downloadCurrentCanvas(filename) {
            if (!state.canvas) {
                console.error('No canvas available to download');
                return;
            }

            const link = document.createElement('a');
            link.download = filename;
            link.href = state.canvas.toDataURL('image/png');
            link.click();
        }

        function showApiKeyModal(callback) {
            // Create modal for API key input
            const modal = document.createElement('div');
            modal.id = 'apiKeyModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                padding: 30px;
                border-radius: 10px;
                max-width: 500px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;

            dialog.innerHTML = `
                <h2 style="margin-top: 0; color: #667eea;">üîë OpenAI API Key Required</h2>
                <p style="color: #4a5568; margin-bottom: 20px;">
                    Please enter your OpenAI API key to generate AI-powered installation guidance.
                </p>
                <input type="password" id="apiKeyInput" placeholder="sk-..." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; margin-bottom: 15px; font-family: monospace;">
                <label style="display: block; margin-bottom: 20px; color: #4a5568;">
                    <input type="checkbox" id="saveApiKey" checked style="margin-right: 5px;">
                    Save API key for future use
                </label>
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeApiKeyModal()" style="padding: 10px 20px; background: #e2e8f0; color: #2d3748; border: none; border-radius: 5px; cursor: pointer;">
                        Cancel
                    </button>
                    <button onclick="submitApiKey()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        Submit
                    </button>
                </div>
            `;

            modal.appendChild(dialog);
            document.body.appendChild(modal);

            // Store callback for later
            window.apiKeyCallback = callback;

            // Focus on input
            setTimeout(() => document.getElementById('apiKeyInput')?.focus(), 100);

            // Allow Enter key to submit
            document.getElementById('apiKeyInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitApiKey();
                }
            });
        }

        function closeApiKeyModal() {
            const modal = document.getElementById('apiKeyModal');
            if (modal) {
                modal.remove();
            }
            window.apiKeyCallback = null;
        }

        function submitApiKey() {
            const apiKey = document.getElementById('apiKeyInput')?.value;
            const saveKey = document.getElementById('saveApiKey')?.checked;

            if (!apiKey || !apiKey.trim()) {
                alert('Please enter a valid API key');
                return;
            }

            if (saveKey) {
                localStorage.setItem('openai_api_key', apiKey.trim());
            }

            closeApiKeyModal();

            if (window.apiKeyCallback) {
                window.apiKeyCallback(apiKey.trim());
            }
        }

        async function generateWrittenGuidance() {
            const section = document.getElementById('writtenGuidanceSection');
            const content = document.getElementById('writtenGuidanceContent');

            if (!state.position) {
                content.textContent = 'Please set the flue terminal position before generating guidance.';
                section.style.display = 'block';
                return;
            }

            content.textContent = 'Generating guidance...';
            section.style.display = 'block';

            // Get API key from localStorage or show modal
            let apiKey = localStorage.getItem('openai_api_key');

            if (!apiKey) {
                // Show modal and wait for user input
                showApiKeyModal((key) => {
                    // Retry with the provided key
                    performGuidanceGeneration(key);
                });
                return;
            }

            await performGuidanceGeneration(apiKey);
        }

        async function performGuidanceGeneration(apiKey) {
            const section = document.getElementById('writtenGuidanceSection');
            const content = document.getElementById('writtenGuidanceContent');

            content.textContent = 'Generating guidance...';
            section.style.display = 'block';

            try {
                const positionText = state.position
                    ? `(${Math.round(state.position.x)}, ${Math.round(state.position.y)})`
                    : 'Not set';

                // Prepare data for OpenAI
                const promptText = `Generate professional installation guidance for a flue terminal installation with the following details:

Boiler: ${state.flueBrand || 'Unknown'} ${state.flueModel || 'Unknown'}

Marked Obstacles:
${state.obstacles.map((obs, i) => `${i + 1}. ${obs.type} at position (${Math.round(obs.x)}, ${Math.round(obs.y)})`).join('\n')}

Clearance Requirements:
${state.flueClearances ? Object.entries(state.flueClearances).map(([pos, data]) =>
    `- ${pos}: ${data.clearanceMM}mm${data.specialRules ? ' (' + data.specialRules + ')' : ''}`
).join('\n') : 'Not specified'}

Flue Terminal Position: ${positionText}

Scale: ${state.pxPerMM ? state.pxPerMM.toFixed(2) : 'Unknown'} pixels/mm

Please provide:
1. A summary of the installation requirements
2. Key clearance distances that must be maintained
3. Any special considerations or rules
4. Compliance status (whether the marked position meets requirements)
5. Recommendations for the installer

Format the response in clear, professional language suitable for a gas engineer.`;

                // Call OpenAI API
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + apiKey
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: [{
                            role: 'user',
                            content: promptText
                        }],
                        temperature: 0.7,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) {
                    // If unauthorized, clear the stored key and show modal again
                    if (response.status === 401) {
                        localStorage.removeItem('openai_api_key');
                        content.textContent = 'Invalid API key. Please try again.';
                        showApiKeyModal((key) => {
                            performGuidanceGeneration(key);
                        });
                        return;
                    }
                    throw new Error('API request failed: ' + response.statusText);
                }

                const data = await response.json();
                const guidance = data.choices[0].message.content;

                content.textContent = guidance;

            } catch (error) {
                console.error('Error generating guidance:', error);
                content.textContent = `Error generating guidance: ${error.message}\n\nPlease check your API key and try again.`;
            }
        }

        async function detectObjectsWithOpenAI() {
            const status = document.getElementById('positionStatus');
            status.textContent = 'üîç Detecting objects with OpenAI...';
            status.classList.remove('warning');

            // Ensure we have everything needed before calling the worker
            if (!state.photo || !state.canvas || !state.ctx) {
                status.textContent = '‚ùå Please load a photo before running detection.';
                status.classList.add('warning');
                return;
            }

            if (!state.position) {
                status.textContent = '‚ùå Tap the flue position before running detection.';
                status.classList.add('warning');
                return;
            }

            if (!state.pxPerMM) {
                status.textContent = '‚ùå Calibrate the image before running detection.';
                status.classList.add('warning');
                return;
            }

            try {
                // Call the Cloudflare Worker (which calls OpenAI)
                const response = await fetch('https://clearance-genie-worker.martinbibb.workers.dev', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image: state.photoBase64,
                        pxPerMM: state.pxPerMM,
                        mode: 'flue',
                        position: state.position,
                        imageWidth: state.canvas.width,
                        imageHeight: state.canvas.height
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }

                const result = await response.json();

                if (!result.success || !result.detections) {
                    throw new Error('Invalid API response');
                }

                state.detectedObjects = result.detections;
                state.zones = result.zones;

                // Draw detected objects
                drawDetectedObjects();

                // Show object key
                showObjectKey();

                status.textContent = `‚úÖ Detected ${result.detections.length} objects!`;

                // Show results panel
                document.getElementById('resultsPanel').classList.add('active');

            } catch (error) {
                console.error('Detection error:', error);
                status.textContent = '‚ùå Object detection failed. Please try manual marking.';
                status.classList.add('warning');

                // Fall back to manual marking
                document.getElementById('obstacleMarkingSection').style.display = 'block';
            }
        }

        function drawDetectedObjects() {
            if (!state.photo || !state.canvas || !state.ctx || !state.position) {
                console.warn('Skipping drawDetectedObjects: missing canvas, photo, or position');
                return;
            }

            // Clear and redraw
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw position marker
            drawPositionMarker(state.position.x, state.position.y);

            // Draw detected objects with different colors
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800', '#0088ff'];

            state.detectedObjects.forEach((obj, index) => {
                const color = colors[index % colors.length];

                // Draw bounding box
                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 4;
                state.ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);

                // Draw label
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 20px Arial';
                const label = obj.label || obj.type;
                state.ctx.fillText(`${index + 1}: ${label}`, obj.x + 5, obj.y + 25);
            });

            // Draw clearance zones if available
            if (state.zones) {
                drawClearanceZones();
            }
        }

        function showObjectKey() {
            const keyDiv = document.getElementById('objectKey');
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800', '#0088ff'];

            let keyHTML = '<h4 style="color: #667eea; margin-bottom: 15px;">Detected Objects Key:</h4>';

            state.detectedObjects.forEach((obj, index) => {
                const color = colors[index % colors.length];
                const label = obj.label || obj.type;

                keyHTML += `
                    <div class="detection-item" style="border-left-color: ${color};">
                        <strong style="color: ${color};">${index + 1}. ${label}</strong><br>
                        Type: ${obj.type}<br>
                        Position: (${Math.round(obj.x)}, ${Math.round(obj.y)})<br>
                        Size: ${Math.round(obj.width)}√ó${Math.round(obj.height)}px
                    </div>
                `;
            });

            keyDiv.innerHTML = keyHTML;
            keyDiv.style.display = 'block';
        }

        // Bug Report Functions
        let bugReportScreenshots = [];

        function openBugReportModal() {
            document.getElementById('bugReportModal').style.display = 'block';
            bugReportScreenshots = [];
            document.getElementById('bugDescription').value = '';
            document.getElementById('bugScreenshotPreview').innerHTML = '';
        }

        function closeBugReportModal() {
            document.getElementById('bugReportModal').style.display = 'none';
        }

        function handleBugScreenshotUpload(event) {
            const files = Array.from(event.target.files);

            files.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        bugReportScreenshots.push({
                            name: file.name,
                            data: e.target.result
                        });
                        updateBugScreenshotPreview();
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        function updateBugScreenshotPreview() {
            const previewDiv = document.getElementById('bugScreenshotPreview');
            previewDiv.innerHTML = bugReportScreenshots.map((screenshot, index) => `
                <div class="bug-screenshot-item">
                    <img src="${screenshot.data}" alt="${screenshot.name}">
                    <button class="bug-screenshot-remove" onclick="removeBugScreenshot(${index})">&times;</button>
                </div>
            `).join('');
        }

        function removeBugScreenshot(index) {
            bugReportScreenshots.splice(index, 1);
            updateBugScreenshotPreview();
        }

        function submitBugReport() {
            const description = document.getElementById('bugDescription').value.trim();

            if (!description) {
                alert('Please describe the bug before submitting.');
                return;
            }

            try {
                // Collect all relevant debugging data
                const debugData = {
                    description: description,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    screenResolution: `${window.screen.width}x${window.screen.height}`,
                    windowSize: `${window.innerWidth}x${window.innerHeight}`,
                    url: window.location.href,
                    state: {
                        hasPhoto: !!state.photo,
                        isCalibrated: state.isCalibrated,
                        scale: state.scale,
                        position: state.position,
                        detectedObjects: state.detectedObjects?.length || 0,
                        obstacles: state.obstacles?.length || 0,
                        zones: state.zones ? Object.keys(state.zones) : []
                    },
                    localStorage: {
                        hasOpenAIKey: !!localStorage.getItem('openai_api_key'),
                        hasCloudflareUrl: !!localStorage.getItem('cloudflareWorkerUrl')
                    }
                };

                // Format email body with all debug info
                const emailBody = formatBugReportEmail(debugData);

                // Create mailto link
                const recipient = 'martinbibb@gmail.com';
                const subject = encodeURIComponent(`Clearance Genie Bug Report: ${description.substring(0, 50)}${description.length > 50 ? '...' : ''}`);
                const body = encodeURIComponent(emailBody);

                const mailtoLink = `mailto:${recipient}?subject=${subject}&body=${body}`;

                // Open user's email client
                window.location.href = mailtoLink;

                // Show success message
                alert('Your email client should open now. Please attach any screenshots manually if needed, then send the email.');
                closeBugReportModal();
            } catch (error) {
                console.error('Bug report error:', error);
                alert('Failed to prepare bug report. Please contact martinbibb@gmail.com directly.');
            }
        }

        function formatBugReportEmail(debugData) {
            const lines = [];

            lines.push('===== BUG REPORT =====');
            lines.push('');
            lines.push(`Submitted: ${debugData.timestamp}`);
            lines.push('');
            lines.push('--- USER DESCRIPTION ---');
            lines.push(debugData.description);
            lines.push('');
            lines.push('');
            lines.push('--- BROWSER INFORMATION ---');
            lines.push(`User Agent: ${debugData.userAgent}`);
            lines.push(`Platform: ${debugData.platform}`);
            lines.push(`Screen Resolution: ${debugData.screenResolution}`);
            lines.push(`Window Size: ${debugData.windowSize}`);
            lines.push(`URL: ${debugData.url}`);
            lines.push('');
            lines.push('');
            lines.push('--- APPLICATION STATE ---');
            lines.push(`Has Photo: ${debugData.state.hasPhoto}`);
            lines.push(`Is Calibrated: ${debugData.state.isCalibrated}`);
            lines.push(`Scale: ${debugData.state.scale}`);
            lines.push(`Position: ${JSON.stringify(debugData.state.position)}`);
            lines.push(`Detected Objects: ${debugData.state.detectedObjects}`);
            lines.push(`Obstacles: ${debugData.state.obstacles}`);
            lines.push(`Zones: ${JSON.stringify(debugData.state.zones)}`);
            lines.push('');
            lines.push('');
            lines.push('--- CONFIGURATION ---');
            lines.push(`Has OpenAI Key: ${debugData.localStorage.hasOpenAIKey}`);
            lines.push(`Has Cloudflare URL: ${debugData.localStorage.hasCloudflareUrl}`);
            lines.push('');
            lines.push('');
            lines.push('===== END REPORT =====');

            return lines.join('\n');
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('bugReportModal');
            if (event.target === modal) {
                closeBugReportModal();
            }
        }
    </script>

    <!-- Bug Report Button -->
    <button class="bug-report-btn" onclick="openBugReportModal()">
        Report Bug
    </button>

    <!-- Bug Report Modal -->
    <div id="bugReportModal" class="bug-modal">
        <div class="bug-modal-content">
            <div class="bug-modal-header">
                <h2>Report a Bug</h2>
                <button class="bug-modal-close" onclick="closeBugReportModal()">&times;</button>
            </div>

            <div class="bug-form-group">
                <label for="bugDescription">What went wrong?</label>
                <textarea
                    id="bugDescription"
                    placeholder="Please describe the issue you encountered in detail..."
                ></textarea>
            </div>

            <div class="bug-form-group">
                <label>Screenshots (optional)</label>
                <input
                    type="file"
                    id="bugScreenshotInput"
                    accept="image/*"
                    multiple
                    onchange="handleBugScreenshotUpload(event)"
                    style="display: none;"
                >
                <div class="bug-screenshot-upload" onclick="document.getElementById('bugScreenshotInput').click()">
                    Click to add screenshots
                </div>
                <div id="bugScreenshotPreview" class="bug-screenshot-preview"></div>
            </div>

            <button id="bugSubmitBtn" class="bug-submit-btn" onclick="submitBugReport()">
                Send Bug Report
            </button>

            <p style="margin-top: 15px; font-size: 12px; color: #666; text-align: center;">
                This will open your email client with debugging info included. Please attach screenshots manually if needed.
            </p>
        </div>
    </div>

</body>
</html>
