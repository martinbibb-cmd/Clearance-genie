<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Clearance Genie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
        }

        input[type="file"] {
            display: none;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            background: #f7fafc;
            display: none;
        }

        .canvas-container.active {
            display: block;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: crosshair;
        }

        .instructions {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .calibration-points {
            background: #fff5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f56565;
        }

        .calibration-points p {
            margin: 5px 0;
            font-weight: 600;
        }

        .status {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.warning {
            background: #feebc8;
            color: #7c2d12;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
        }

        .calibration-info {
            background: #e6fffa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #38b2ac;
            display: none;
        }

        .calibration-info.active {
            display: block;
        }

        .calibration-info h4 {
            color: #38b2ac;
            margin-bottom: 10px;
        }

        .calibration-info p {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .button-group {
                grid-template-columns: 1fr;
            }

            #outputImagesSection > div {
                grid-template-columns: 1fr !important;
            }
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-panel {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
        }

        .results-panel.active {
            display: block;
        }

        .results-panel h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .detection-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
        }

        .detection-item strong {
            color: #667eea;
        }

        .zone-legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .zone-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zone-color-box {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #333;
        }

        .zone-red {
            background: rgba(245, 101, 101, 0.5);
        }

        .zone-green {
            background: rgba(72, 187, 120, 0.5);
        }

        .zone-blue {
            background: rgba(66, 153, 225, 0.5);
        }

        .obstacle-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .obstacle-item strong {
            color: #667eea;
        }

        .obstacle-delete-btn {
            background: #f56565;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .obstacle-delete-btn:hover {
            background: #e53e3e;
        }

        .compliance-pass {
            background: #c6f6d5;
            color: #22543d;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 18px;
            text-align: center;
        }

        .compliance-fail {
            background: #fed7d7;
            color: #742a2a;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 18px;
            text-align: center;
        }
    </style>

</head>
<body>
    <div class="container">
        <h1>üî• Clearance Genie</h1>

        <div class="card">
            <h2>Step 1: Load Photo</h2>
            <p style="margin: 10px 0; color: #666;">Take or upload a photo with your blue calibration card visible</p>
            
            <input type="file" id="photoInput" accept="image/*">
            <div class="button-group">
                <button class="btn" onclick="document.getElementById('photoInput').click()">
                    üìÅ Choose Photo
                </button>
                <button class="btn" onclick="openCamera()">
                    üì∑ Take Photo
                </button>
            </div>

            <div class="instructions">
                <h3>üìã How to take the photo:</h3>
                <ol>
                    <li>Place your blue calibration card on the wall at the proposed flue/boiler height</li>
                    <li>Stand back and take a clear photo that includes the card and surrounding area</li>
                    <li>Make sure the card is visible and not blurry</li>
                    <li>Include any windows, vents, corners, or obstacles in the frame</li>
                </ol>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="photoCanvas"></canvas>
            <div id="zoomControls" style="display: none; position: absolute; top: 10px; right: 10px; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 100;">
                <div style="margin-bottom: 10px;">
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 5px; text-align: center;">Zoom</div>
                    <button onclick="zoomIn()" style="display: block; width: 40px; height: 40px; margin-bottom: 5px; font-size: 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">+</button>
                    <button onclick="resetZoom()" style="display: block; width: 40px; height: 40px; margin-bottom: 5px; font-size: 14px; background: #48bb78; color: white; border: none; border-radius: 5px; cursor: pointer;">1:1</button>
                    <button onclick="zoomOut()" style="display: block; width: 40px; height: 40px; font-size: 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">-</button>
                </div>
                <div>
                    <div style="font-size: 12px; font-weight: bold; margin-bottom: 5px; text-align: center;">Pan</div>
                    <button onclick="panUp()" style="display: block; width: 40px; height: 40px; margin: 0 auto 5px; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üë</button>
                    <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                        <button onclick="panLeft()" style="width: 40px; height: 40px; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üê</button>
                        <button onclick="panRight()" style="width: 40px; height: 40px; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üí</button>
                    </div>
                    <button onclick="panDown()" style="display: block; width: 40px; height: 40px; margin: 0 auto; font-size: 18px; background: #4299e1; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üì</button>
                </div>
            </div>
        </div>

        <div class="card" id="calibrationCard" style="display: none;">
            <h2>Step 2: Calibrate Scale</h2>
            
            <div class="status" id="tapStatus">
                Choose calibration method below
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="autoDetectCard()">
                    ü§ñ Auto-Detect Card
                </button>
                <button class="btn" onclick="startManualCalibration()">
                    üëÜ Manual 4-Point
                </button>
            </div>

            <div class="calibration-points" id="pointsDisplay" style="display: none;">
                <p>Points tapped: <span id="pointCount">0</span>/4</p>
                <button class="btn btn-danger" onclick="resetCalibration()" style="margin-top: 10px;">
                    ‚Ü∫ Reset Points
                </button>
            </div>

            <div class="calibration-info" id="calibrationInfo">
                <h4>‚úÖ Calibration Complete!</h4>
                <p>Scale: <span id="scaleDisplay">-</span> pixels/mm</p>
                <p>Card Width: <span id="cardWidthDisplay">-</span> pixels (should be ~85.6mm)</p>
                <p>Card Height: <span id="cardHeightDisplay">-</span> pixels (should be ~53.98mm)</p>
                <p>Accuracy: <span id="accuracyDisplay">-</span></p>
                <p>Plumb Line: <span id="plumbDisplay">-</span></p>
                <button class="btn" onclick="resetCalibration()" style="margin-top: 10px;">
                    üîÑ Recalibrate
                </button>
            </div>
        </div>

        <div class="card" id="analysisCard" style="display: none;">
            <h2>Step 3: Choose Analysis Type</h2>
            
            <div class="instructions">
                <h3>What do you want to check?</h3>
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="startFlueMode()">
                    üî• Horizontal Flue Clearances
                </button>
                <button class="btn btn-secondary" onclick="startVerticalFlueMode()">
                    ‚¨ÜÔ∏è Vertical Flue Clearances
                </button>
                <button class="btn btn-secondary" onclick="startBoilerMode()">
                    üîß Boiler Clearances
                </button>
                <button class="btn btn-secondary" onclick="startRadiatorMode()">
                    üå°Ô∏è Radiator Clearances
                </button>
                <button class="btn btn-secondary" onclick="startCylinderMode()">
                    üóúÔ∏è Cylinder Placement
                </button>
            </div>

            <button class="btn" onclick="testClick()">üß™ Test Click</button>

            <div id="positionInstructions" style="display: none;">
                <div class="status active" id="positionStatus">
                    üëÜ Tap on the image to mark the position
                </div>

                <label style="display: block; margin: 15px 0;">
                    <strong>Brand:</strong>
                    <select id="brandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px;" onchange="updateModelSelector()">
                        <option value="">Select a brand...</option>
                    </select>
                </label>

                <label id="modelSelectorLabel" style="display: none; margin: 15px 0;">
                    <strong>Model/Range:</strong>
                    <select id="modelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px;" onchange="updateBoilerClearancesFromCSV()">
                        <option value="">Select a model...</option>
                    </select>
                </label>
            </div>

            <div id="boilerEditingSection" style="display: none;">
                <div id="clearanceNotesSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                    <h4 style="color: #856404; margin-bottom: 10px;">‚ö†Ô∏è Special Requirements</h4>
                    <div id="clearanceNotesContent" style="color: #856404;"></div>
                </div>

                <div class="instructions">
                    <h3>Edit Boiler Dimensions & Clearances</h3>
                    <p>Adjust the dimensions and clearances as needed:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="color: #667eea; margin-bottom: 15px;">Boiler Dimensions (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Height:</label>
                            <input type="number" id="boilerHeight" value="600" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Width:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button onclick="adjustBoilerWidth(-10)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚óÄ</button>
                                <input type="number" id="boilerWidth" value="390" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc; text-align: center;">
                                <button onclick="adjustBoilerWidth(10)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚ñ∂</button>
                            </div>
                        </div>
                    </div>

                    <h4 style="color: #667eea; margin-bottom: 15px; margin-top: 20px;">Service Clearances (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Top:</label>
                            <input type="number" id="clearanceTop" value="170" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Bottom:</label>
                            <input type="number" id="clearanceBottom" value="200" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Left:</label>
                            <input type="number" id="clearanceLeft" value="5" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Right:</label>
                            <input type="number" id="clearanceRight" value="5" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                    </div>

                    <button class="btn btn-secondary" onclick="updateBoilerDisplay()" style="margin-top: 15px;">
                        üîÑ Update Display
                    </button>

                    <button class="btn btn-secondary" id="downloadBoilerMarkupBtn" onclick="downloadCurrentCanvas('boiler-markup.png')" style="margin-top: 10px; display: none;">
                        üíæ Download Image with Boiler Markup
                    </button>
                </div>
            </div>

            <div id="radiatorEditingSection" style="display: none;">
                <div class="instructions">
                    <h3>Edit Radiator Dimensions & Clearances</h3>
                    <p>Adjust the dimensions and clearances as needed:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="color: #667eea; margin-bottom: 15px;">Radiator Dimensions (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Height:</label>
                            <select id="radiatorHeight" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                                <option value="300">300mm</option>
                                <option value="450">450mm</option>
                                <option value="600" selected>600mm</option>
                                <option value="700">700mm</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Width:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <button onclick="adjustRadiatorWidth(-200)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚óÄ</button>
                                <input type="number" id="radiatorWidth" value="400" readonly style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc; text-align: center;">
                                <button onclick="adjustRadiatorWidth(200)" style="padding: 10px 15px; border-radius: 5px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 16px;">‚ñ∂</button>
                            </div>
                        </div>
                    </div>

                    <h4 style="color: #667eea; margin-bottom: 15px; margin-top: 20px;">Service Clearances (mm)</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Top:</label>
                            <input type="number" id="radiatorClearanceTop" value="0" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Bottom:</label>
                            <input type="number" id="radiatorClearanceBottom" value="150" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Left:</label>
                            <input type="number" id="radiatorClearanceLeft" value="150" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Right:</label>
                            <input type="number" id="radiatorClearanceRight" value="150" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ccc;">
                        </div>
                    </div>

                    <button class="btn btn-secondary" onclick="updateRadiatorDisplay()" style="margin-top: 15px;">
                        üîÑ Update Display
                    </button>

                    <button class="btn btn-secondary" id="downloadRadiatorMarkupBtn" onclick="downloadCurrentCanvas('radiator-markup.png')" style="margin-top: 10px; display: none;">
                        üíæ Download Image with Radiator Markup
                    </button>
                </div>
            </div>

            <div id="cylinderEditingSection" style="display: none;">
                <div class="instructions">
                    <h3>Select Cylinder</h3>
                    <p>Choose the cylinder brand and model:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="cylinderBrandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateCylinderModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="cylinderModelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model:</strong>
                        <select id="cylinderModelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="displayCylinderDetails()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>

                    <div id="cylinderDetailsDisplay" style="display: none; margin-top: 20px; background: white; padding: 15px; border-radius: 8px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">Cylinder Details</h4>
                        <div id="cylinderDetailsList"></div>
                    </div>
                </div>

                <button class="btn" id="placeCylinderBtn" onclick="enableCylinderPlacement()" style="margin-top: 10px; display: none;">
                    üìç Place Cylinder on Image
                </button>

                <button class="btn btn-secondary" id="downloadCylinderMarkupBtn" onclick="downloadCurrentCanvas('cylinder-markup.png')" style="margin-top: 10px; display: none;">
                    üíæ Download Image with Cylinder Markup
                </button>
            </div>

            <div id="flueEditingSection" style="display: none;">
                <div id="flueSpecialRulesSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                    <h4 style="color: #856404; margin-bottom: 10px;">‚ö†Ô∏è Special Flue Rules</h4>
                    <div id="flueSpecialRulesContent" style="color: #856404;"></div>
                </div>

                <div class="instructions">
                    <h3>Select Boiler Brand & Model</h3>
                    <p>Choose the boiler brand and model for accurate flue clearance requirements:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="flueBrandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateFlueModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="flueModelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model/Range:</strong>
                        <select id="flueModelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="displayFlueClearances()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>

                    <div id="flueClearancesDisplay" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">üìè Clearance Requirements</h4>
                        <div id="flueClearancesList" style="background: white; padding: 15px; border-radius: 8px;"></div>
                    </div>
                </div>
            </div>

            <div id="verticalFlueEditingSection" style="display: none;">
                <div id="verticalFlueSpecialRulesSection" style="display: none; background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ffc107;">
                    <h4 style="color: #856404; margin-bottom: 10px;">‚ö†Ô∏è Special Vertical Flue Rules</h4>
                    <div id="verticalFlueSpecialRulesContent" style="color: #856404;"></div>
                </div>

                <div class="instructions">
                    <h3>Select Boiler Brand & Model</h3>
                    <p>Choose the boiler brand and model for accurate vertical flue clearance requirements:</p>
                </div>

                <div style="background: #f7fafc; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <label style="display: block; margin-bottom: 15px;">
                        <strong>Brand:</strong>
                        <select id="verticalFlueBrandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="updateVerticalFlueModelSelector()">
                            <option value="">Select a brand...</option>
                        </select>
                    </label>

                    <label id="verticalFlueModelSelectorLabel" style="display: none; margin-bottom: 15px;">
                        <strong>Model/Range:</strong>
                        <select id="verticalFlueModelSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px; border: 1px solid #ccc;" onchange="displayVerticalFlueClearances()">
                            <option value="">Select a model...</option>
                        </select>
                    </label>

                    <div id="verticalFlueClearancesDisplay" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">üìè Vertical Flue Clearance Requirements</h4>
                        <div id="verticalFlueClearancesList" style="background: white; padding: 15px; border-radius: 8px;"></div>
                    </div>
                </div>
            </div>

            <div id="obstacleMarkingSection" style="display: none;">
                <div class="instructions">
                    <h3>Step 4: Mark Obstacles</h3>
                    <p>Click a button below, then tap on the image to mark obstacles:</p>
                </div>

                <div class="status" id="markingStatus">
                    Select an obstacle type below to start marking
                </div>

                <div class="button-group" id="obstacleButtonsContainer">
                    <!-- Buttons will be populated dynamically based on flue type -->
                </div>

                <div id="obstaclesList" style="display: none;">
                    <h4 style="margin-top: 20px; color: #667eea;">Marked Obstacles:</h4>
                    <div id="obstaclesListContent"></div>
                </div>

                <button class="btn" id="calculateBtn" onclick="calculateClearances()" style="margin-top: 20px; display: none;">
                    üîç Calculate Clearance Zones
                </button>

                <div id="flueOutputSection" style="display: none; margin-top: 20px;">
                    <div class="instructions">
                        <h3>Generate Outputs</h3>
                        <p>Generate clearance visualizations and written guidance:</p>
                    </div>

                    <div class="button-group">
                        <button class="btn btn-secondary" onclick="generateStandardFlueOutput()">
                            üìä Standard Flue Output
                        </button>
                        <button class="btn btn-secondary" onclick="generatePlumeManagementOutput()">
                            üí® Plume Management Output
                        </button>
                    </div>

                    <button class="btn" onclick="generateWrittenGuidance()" style="margin-top: 10px;">
                        üìù Generate Written Guidance (AI)
                    </button>

                    <div id="writtenGuidanceSection" style="display: none; background: #f7fafc; padding: 20px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">üìù Installation Guidance</h4>
                        <div id="writtenGuidanceContent" style="white-space: pre-wrap; line-height: 1.6;"></div>
                    </div>

                    <div id="outputImagesSection" style="display: none; margin-top: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 15px;">Generated Outputs</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <h5 style="margin-bottom: 10px;">Standard Flue</h5>
                                <canvas id="standardFlueCanvas" style="width: 100%; border: 2px solid #667eea; border-radius: 8px;"></canvas>
                                <button class="btn btn-secondary" onclick="downloadCanvas('standardFlueCanvas', 'standard-flue.png')" style="margin-top: 10px; width: 100%;">
                                    üíæ Download
                                </button>
                            </div>
                            <div>
                                <h5 style="margin-bottom: 10px;">Plume Management</h5>
                                <canvas id="plumeCanvas" style="width: 100%; border: 2px solid #667eea; border-radius: 8px;"></canvas>
                                <button class="btn btn-secondary" onclick="downloadCanvas('plumeCanvas', 'plume-management.png')" style="margin-top: 10px; width: 100%;">
                                    üíæ Download
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="status" id="analysisStatus"></div>

            <div id="objectKey" style="display: none; background: #f7fafc; padding: 20px; border-radius: 8px; margin: 15px 0;">
            </div>

            <div class="results-panel" id="resultsPanel">
                <div class="zone-legend">
                    <div class="zone-legend-item">
                        <div class="zone-color-box zone-red"></div>
                        <span>Prohibited Zone</span>
                    </div>
                    <div class="zone-legend-item">
                        <div class="zone-color-box zone-green"></div>
                        <span>Safe Zone</span>
                    </div>
                </div>

                <div style="margin-top: 15px; padding: 10px; background: #f7fafc; border-radius: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 500;">
                        <input type="checkbox" id="plumeKitToggle" onchange="togglePlumeKitMode()" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
                        <span>üí® Plume Kit Mode (50% reduced clearances)</span>
                    </label>
                </div>

                <div id="complianceResult" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CARD_WIDTH_MM = 85.6;
        const CARD_HEIGHT_MM = 53.98;

        // Brand-specific clearance rules (in mm from obstruction edge to flue/boiler center)
        // These are fallback/flue rules - boiler rules will be loaded from CSV
        const CLEARANCE_RULES = {
            worcester: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            vaillant: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            ideal: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            "glow-worm": {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            },
            viessmann: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                },
                radiator: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 0,
                    floor: 500
                }
            }
        };

        // Boiler clearance data loaded from CSV
        let BOILER_CLEARANCES_DATA = [];
        let AVAILABLE_BRANDS = [];
        let AVAILABLE_MODELS = {};

        // Flue clearance data loaded from CSV
        let FLUE_CLEARANCES_DATA = [];
        let FLUE_AVAILABLE_BRANDS = [];
        let FLUE_AVAILABLE_MODELS = {};

        // Vertical Flue clearance data loaded from CSV
        let VERTICAL_FLUE_CLEARANCES_DATA = [];
        let VERTICAL_FLUE_AVAILABLE_BRANDS = [];
        let VERTICAL_FLUE_AVAILABLE_MODELS = {};

        // Cylinder data loaded from CSV
        let CYLINDERS_DATA = [];
        let CYLINDER_AVAILABLE_BRANDS = [];
        let CYLINDER_AVAILABLE_MODELS = {};

        // Core state
        const state = {
            photo: null,
            photoBase64: null,
            canvas: null,
            ctx: null,
            calibrationPoints: [],
            isCalibrating: false,
            pxPerMM: null,
            position: null,
            canvasScale: 1,
            mode: null,
            flueType: null, // 'horizontal' or 'vertical'
            obstacles: [], // Manual obstacles marked by user
            markingMode: null, // Current obstacle type being marked
            markingPoints: [], // Points collected during marking
            zones: null,
            detectedObjects: [], // Objects detected by Gemini API
            boilerDimensions: null,
            boilerClearances: null,
            // Zoom and pan state
            zoomLevel: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            lastPanX: 0,
            lastPanY: 0,
            // Plume kit mode
            plumeKitMode: false,
            // Long press move state
            isLongPressing: false,
            longPressTimer: null,
            isMovingObject: false,
            movingObjectIndex: null,
            // Placed objects array for multiple boilers/cylinders/radiators
            placedObjects: []
        };

        // CSV Parsing and Loading Functions
        async function loadBoilerClearances() {
            try {
                const response = await fetch('data/boiler-clearances.csv');
                const csvText = await response.text();
                parseBoilerClearancesCSV(csvText);
            } catch (error) {
                console.error('Failed to load boiler clearances CSV:', error);
                // Fallback to hardcoded values is already in CLEARANCE_RULES
            }
        }

        function parseBoilerClearancesCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            BOILER_CLEARANCES_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Parse CSV line (handle quoted fields)
                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    type: fields[0],
                    brand: fields[1],
                    model: fields[2],
                    clearanceArea: fields[3],
                    clearanceMM: fields[4],
                    notes: fields[5] || ''
                };

                BOILER_CLEARANCES_DATA.push(entry);

                // Track unique brands
                if (entry.brand) {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model && entry.model !== 'Notes') {
                        modelsMap[entry.brand].add(entry.model);
                    }
                }
            }

            AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded boiler clearances:', {
                entries: BOILER_CLEARANCES_DATA.length,
                brands: AVAILABLE_BRANDS,
                models: AVAILABLE_MODELS
            });
        }

        function parseCSVLine(line) {
            const fields = [];
            let currentField = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = i < line.length - 1 ? line[i + 1] : null;

                if (char === '"') {
                    // Handle escaped quotes ("")
                    if (inQuotes && nextChar === '"') {
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    fields.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }

            fields.push(currentField.trim());
            return fields;
        }

        function getBoilerClearancesForModel(brand, model) {
            // Normalize brand name (case-insensitive)
            const normalizedBrand = brand.toLowerCase();

            const entries = BOILER_CLEARANCES_DATA.filter(entry =>
                entry.brand.toLowerCase() === normalizedBrand &&
                entry.model === model
            );

            // Convert to clearances object
            const clearances = {
                top: null,
                bottom: null,
                left: null,
                right: null,
                front: null,
                rear: null,
                notes: []
            };

            entries.forEach(entry => {
                const area = entry.clearanceArea.toLowerCase();
                const value = entry.clearanceMM;

                // Parse clearance value (handle ranges like "170/210")
                const numericValue = value ? parseFloat(value.split('/')[0]) : null;

                if (area.includes('above') || area.includes('top')) {
                    clearances.top = numericValue;
                } else if (area.includes('below') || area.includes('bottom')) {
                    clearances.bottom = numericValue;
                } else if (area.includes('side') || area.includes('left')) {
                    clearances.left = numericValue;
                    clearances.right = numericValue; // Assume symmetric unless specified
                } else if (area.includes('front')) {
                    clearances.front = numericValue;
                } else if (area.includes('rear')) {
                    clearances.rear = numericValue;
                }

                // Collect notes
                if (entry.notes || area.includes('notes')) {
                    clearances.notes.push(entry.notes || value);
                }
            });

            return clearances;
        }

        // Flue Clearance CSV Functions
        async function loadFlueClearances() {
            try {
                const response = await fetch('data/flue-clearances.csv');
                const csvText = await response.text();
                parseFlueClearancesCSV(csvText);
            } catch (error) {
                console.error('Failed to load flue clearances CSV:', error);
            }
        }

        function parseFlueClearancesCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            FLUE_CLEARANCES_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    type: fields[0],
                    brand: fields[1],
                    model: fields[2],
                    position: fields[3],
                    clearanceMM: parseInt(fields[4]) || 0,
                    specialRules: fields[5] || ''
                };

                FLUE_CLEARANCES_DATA.push(entry);

                // Track unique brands
                if (entry.brand && entry.brand !== 'Any') {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model) {
                        modelsMap[entry.brand].add(entry.model);
                    }
                }
            }

            FLUE_AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            FLUE_AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                FLUE_AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded flue clearances:', {
                entries: FLUE_CLEARANCES_DATA.length,
                brands: FLUE_AVAILABLE_BRANDS,
                models: FLUE_AVAILABLE_MODELS
            });
        }

        function getFlueClearancesForModel(brand, model) {
            const normalizedBrand = brand.toLowerCase();
            const normalizedModel = model.toLowerCase();

            const entries = FLUE_CLEARANCES_DATA.filter(entry => {
                const entryBrand = entry.brand.toLowerCase();
                const entryModel = entry.model.toLowerCase();

                return (entry.brand === 'Any' || entryBrand === normalizedBrand) &&
                       (entryModel === normalizedModel || entryModel.includes(normalizedModel));
            });

            // Group by position/scenario
            const clearances = {};
            entries.forEach(entry => {
                if (!clearances[entry.position]) {
                    clearances[entry.position] = {
                        clearanceMM: entry.clearanceMM,
                        specialRules: entry.specialRules
                    };
                }
            });

            return clearances;
        }

        // Vertical Flue Clearance CSV Functions
        async function loadVerticalFlueClearances() {
            try {
                const response = await fetch('data/vertical-flue-clearances.csv');
                const csvText = await response.text();
                parseVerticalFlueClearancesCSV(csvText);
            } catch (error) {
                console.error('Failed to load vertical flue clearances CSV:', error);
            }
        }

        function parseVerticalFlueClearancesCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            VERTICAL_FLUE_CLEARANCES_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    type: fields[0],
                    brand: fields[1],
                    model: fields[2],
                    position: fields[3],
                    clearanceMM: parseInt(fields[4]) || 0,
                    specialRules: fields[5] || ''
                };

                VERTICAL_FLUE_CLEARANCES_DATA.push(entry);

                // Track unique brands
                if (entry.brand && entry.brand !== 'Any') {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model) {
                        modelsMap[entry.brand].add(entry.model);
                    }
                }
            }

            VERTICAL_FLUE_AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            VERTICAL_FLUE_AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                VERTICAL_FLUE_AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded vertical flue clearances:', {
                entries: VERTICAL_FLUE_CLEARANCES_DATA.length,
                brands: VERTICAL_FLUE_AVAILABLE_BRANDS,
                models: VERTICAL_FLUE_AVAILABLE_MODELS
            });
        }

        function getVerticalFlueClearancesForModel(brand, model) {
            const normalizedBrand = brand.toLowerCase();
            const normalizedModel = model.toLowerCase();

            const entries = VERTICAL_FLUE_CLEARANCES_DATA.filter(entry => {
                const entryBrand = entry.brand.toLowerCase();
                const entryModel = entry.model.toLowerCase();

                return (entry.brand === 'Any' || entryBrand === normalizedBrand) &&
                       (entryModel === normalizedModel || entryModel.includes(normalizedModel));
            });

            // Group by position/scenario
            const clearances = {};
            entries.forEach(entry => {
                if (!clearances[entry.position]) {
                    clearances[entry.position] = {
                        clearanceMM: entry.clearanceMM,
                        specialRules: entry.specialRules
                    };
                }
            });

            return clearances;
        }

        // Cylinder loading functions
        async function loadCylinders() {
            try {
                const response = await fetch('data/cylinders.csv');
                const csvText = await response.text();
                parseCylindersCSV(csvText);
            } catch (error) {
                console.error('Failed to load cylinders CSV:', error);
            }
        }

        function parseCylindersCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());

            CYLINDERS_DATA = [];
            const brandsSet = new Set();
            const modelsMap = {};

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const fields = parseCSVLine(line);
                if (fields.length < 5) continue;

                const entry = {
                    brand: fields[0],
                    type: fields[1],
                    model: fields[2],
                    volume: fields[3],
                    dimensions: fields[4],
                    price: fields[5] || '',
                    code: fields[6] || ''
                };

                CYLINDERS_DATA.push(entry);

                // Track unique brands
                if (entry.brand) {
                    brandsSet.add(entry.brand);

                    // Track models per brand
                    if (!modelsMap[entry.brand]) {
                        modelsMap[entry.brand] = new Set();
                    }
                    if (entry.model) {
                        const key = `${entry.type} - ${entry.model} - ${entry.volume}`;
                        modelsMap[entry.brand].add(key);
                    }
                }
            }

            CYLINDER_AVAILABLE_BRANDS = Array.from(brandsSet).sort();
            CYLINDER_AVAILABLE_MODELS = {};
            for (const brand in modelsMap) {
                CYLINDER_AVAILABLE_MODELS[brand] = Array.from(modelsMap[brand]).sort();
            }

            console.log('Loaded cylinders:', {
                entries: CYLINDERS_DATA.length,
                brands: CYLINDER_AVAILABLE_BRANDS,
                models: CYLINDER_AVAILABLE_MODELS
            });
        }

        function getCylinderByKey(brand, modelKey) {
            return CYLINDERS_DATA.find(entry => {
                const key = `${entry.type} - ${entry.model} - ${entry.volume}`;
                return entry.brand === brand && key === modelKey;
            });
        }

        // Parse dimensions from format like "1200h x 520dia"
        function parseCylinderDimensions(dimStr) {
            if (!dimStr) return null;

            const heightMatch = dimStr.match(/(\d+)h/);
            const diameterMatch = dimStr.match(/(\d+)dia/);

            if (heightMatch && diameterMatch) {
                return {
                    height: parseInt(heightMatch[1]),
                    diameter: parseInt(diameterMatch[1])
                };
            }
            return null;
        }

        // Initialize - Load CSV data on page load
        loadBoilerClearances();
        loadFlueClearances();
        loadVerticalFlueClearances();
        loadCylinders();

        document.getElementById('photoInput').addEventListener('change', handlePhotoUpload);

        function openCamera() {
            const input = document.getElementById('photoInput');
            input.setAttribute('capture', 'environment');
            input.click();
            setTimeout(() => input.removeAttribute('capture'), 100);
        }

        function handlePhotoUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                state.photoBase64 = event.target.result;
                const img = new Image();
                img.onload = function() {
                    setupCanvas(img);
                    document.getElementById('canvasContainer').classList.add('active');
                    document.getElementById('calibrationCard').style.display = 'block';
                };
                img.src = event.target.result;
                state.photo = img;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            const canvas = document.getElementById('photoCanvas');

            canvas.width = img.width;
            canvas.height = img.height;

            state.canvas = canvas;
            state.ctx = canvas.getContext('2d');

            state.ctx.drawImage(img, 0, 0);

            const rect = canvas.getBoundingClientRect();
            state.canvasScale = canvas.width / rect.width;

            // Setup pan controls, long press move, and show zoom controls
            setupPanControls();
            setupLongPressMove();
            document.getElementById('zoomControls').style.display = 'block';
        }

        function startManualCalibration() {
            state.isCalibrating = true;
            state.calibrationPoints = [];
            updatePointsDisplay();
            
            document.getElementById('pointsDisplay').style.display = 'block';
            
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.classList.remove('warning');
            status.textContent = 'Tap corner 1/4: Top-Left corner of card';
            
            state.canvas.addEventListener('click', handleCalibrationClick);
        }

        function autoDetectCard() {
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.textContent = 'üîç Searching for blue card...';
            
            const imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            const data = imageData.data;
            
            const bluePixels = [];
            
            for (let y = 0; y < state.canvas.height; y += 2) {
                for (let x = 0; x < state.canvas.width; x += 2) {
                    const i = (y * state.canvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (b > r + 30 && b > g + 30 && b > 100) {
                        bluePixels.push({x, y});
                    }
                }
            }
            
            if (bluePixels.length < 100) {
                status.classList.add('warning');
                status.textContent = '‚ùå Could not find blue card. Try manual calibration or adjust lighting.';
                return;
            }
            
            const minX = Math.min(...bluePixels.map(p => p.x));
            const maxX = Math.max(...bluePixels.map(p => p.x));
            const minY = Math.min(...bluePixels.map(p => p.y));
            const maxY = Math.max(...bluePixels.map(p => p.y));
            
            const width = maxX - minX;
            const height = maxY - minY;
            const aspectRatio = width / height;
            const expectedRatio = CARD_WIDTH_MM / CARD_HEIGHT_MM;
            
            if (Math.abs(aspectRatio - expectedRatio) > 0.3) {
                status.classList.add('warning');
                status.textContent = `‚ö†Ô∏è Found blue region but shape doesn't match card (ratio: ${aspectRatio.toFixed(2)}). Try manual calibration.`;
                
                state.ctx.strokeStyle = '#f56565';
                state.ctx.lineWidth = 3;
                state.ctx.strokeRect(minX, minY, width, height);
                return;
            }
            
            state.calibrationPoints = [
                {x: minX, y: minY},
                {x: maxX, y: minY},
                {x: maxX, y: maxY},
                {x: minX, y: maxY}
            ];
            
            status.textContent = '‚úÖ Card detected! Calculating scale...';
            
            setTimeout(() => calculateCalibration(), 500);
        }

        function handleCalibrationClick(e) {
            if (!state.isCalibrating) return;
            
            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;
            
            state.calibrationPoints.push({x, y});
            
            state.ctx.fillStyle = '#f56565';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();
            
            state.ctx.fillStyle = 'white';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.textAlign = 'center';
            state.ctx.textBaseline = 'middle';
            state.ctx.fillText(state.calibrationPoints.length, x, y);
            
            updatePointsDisplay();
            
            const status = document.getElementById('tapStatus');
            const corners = ['Top-Left', 'Top-Right', 'Bottom-Right', 'Bottom-Left'];
            
            if (state.calibrationPoints.length < 4) {
                status.textContent = `Tap corner ${state.calibrationPoints.length + 1}/4: ${corners[state.calibrationPoints.length]} corner of card`;
            } else {
                calculateCalibration();
            }
        }

        function calculateCalibration() {
            const points = state.calibrationPoints;
            
            const topWidth = distance(points[0], points[1]);
            const bottomWidth = distance(points[3], points[2]);
            const leftHeight = distance(points[0], points[3]);
            const rightHeight = distance(points[1], points[2]);
            
            const avgWidthPx = (topWidth + bottomWidth) / 2;
            const avgHeightPx = (leftHeight + rightHeight) / 2;
            
            const pxPerMMWidth = avgWidthPx / CARD_WIDTH_MM;
            const pxPerMMHeight = avgHeightPx / CARD_HEIGHT_MM;
            
            state.pxPerMM = (pxPerMMWidth + pxPerMMHeight) / 2;

            const skew = Math.abs(pxPerMMWidth - pxPerMMHeight) / state.pxPerMM * 100;

            // Calculate plumb line accuracy (check if card is level/vertical)
            const topAngle = Math.abs(Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x) * 180 / Math.PI);
            const bottomAngle = Math.abs(Math.atan2(points[2].y - points[3].y, points[2].x - points[3].x) * 180 / Math.PI);
            const leftAngle = Math.abs(Math.atan2(points[3].y - points[0].y, points[3].x - points[0].x) * 180 / Math.PI - 90);
            const rightAngle = Math.abs(Math.atan2(points[2].y - points[1].y, points[2].x - points[1].x) * 180 / Math.PI - 90);

            const avgHorizontalAngle = (topAngle + bottomAngle) / 2;
            const avgVerticalAngle = (leftAngle + rightAngle) / 2;

            let plumbRating = '';
            let plumbAccurate = true;

            if (avgHorizontalAngle < 3 && avgVerticalAngle < 3) {
                plumbRating = '‚úÖ Excellent - Card is level and plumb';
            } else if (avgHorizontalAngle < 5 && avgVerticalAngle < 5) {
                plumbRating = '‚ö†Ô∏è Good - Slight tilt detected';
            } else {
                plumbRating = '‚ùå Card not level - Use plumb line for accuracy';
                plumbAccurate = false;
            }

            let accuracyRating = '';

            if (skew < 5) {
                accuracyRating = '‚úÖ Excellent (< 5% skew)';
            } else if (skew < 10) {
                accuracyRating = '‚ö†Ô∏è Good (< 10% skew)';
            } else {
                accuracyRating = '‚ùå Poor - Consider retaking photo more straight-on';
            }
            
            state.ctx.strokeStyle = skew < 10 ? '#48bb78' : '#f56565';
            state.ctx.lineWidth = 4;
            state.ctx.beginPath();
            state.ctx.moveTo(points[0].x, points[0].y);
            state.ctx.lineTo(points[1].x, points[1].y);
            state.ctx.lineTo(points[2].x, points[2].y);
            state.ctx.lineTo(points[3].x, points[3].y);
            state.ctx.closePath();
            state.ctx.stroke();
            
            points.forEach((point, i) => {
                state.ctx.fillStyle = skew < 10 ? '#48bb78' : '#f56565';
                state.ctx.beginPath();
                state.ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                state.ctx.fill();
                
                state.ctx.fillStyle = 'white';
                state.ctx.font = 'bold 14px Arial';
                state.ctx.textAlign = 'center';
                state.ctx.textBaseline = 'middle';
                state.ctx.fillText(i + 1, point.x, point.y);
            });
            
            state.isCalibrating = false;
            state.canvas.removeEventListener('click', handleCalibrationClick);
            
            const status = document.getElementById('tapStatus');
            status.classList.remove('active');
            
            const info = document.getElementById('calibrationInfo');
            info.classList.add('active');
            document.getElementById('scaleDisplay').textContent = state.pxPerMM.toFixed(2);
            document.getElementById('cardWidthDisplay').textContent = avgWidthPx.toFixed(1);
            document.getElementById('cardHeightDisplay').textContent = avgHeightPx.toFixed(1);
            document.getElementById('accuracyDisplay').textContent = accuracyRating;
            document.getElementById('plumbDisplay').textContent = plumbRating;

            document.getElementById('analysisCard').style.display = 'block';

            // FIX: Clone canvas to remove ALL event listeners
            const oldCanvas = state.canvas;
            const newCanvas = oldCanvas.cloneNode(false);
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);

            // Update state references
            state.canvas = newCanvas;
            state.ctx = newCanvas.getContext('2d');

            // Redraw photo and calibration overlay
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Recalculate canvas scale
            const rect = newCanvas.getBoundingClientRect();
            state.canvasScale = newCanvas.width / rect.width;
        }

        function startFlueMode() {
            console.log('=== START FLUE MODE CALLED ===');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'flue';
            state.flueType = 'horizontal';
            state.position = null;
            state.flueBrand = null;
            state.flueModel = null;
            state.flueClearances = null;

            // Hide other mode sections
            document.getElementById('boilerEditingSection').style.display = 'none';
            document.getElementById('radiatorEditingSection').style.display = 'none';
            document.getElementById('verticalFlueEditingSection').style.display = 'none';

            // Show flue editing section
            document.getElementById('flueEditingSection').style.display = 'block';

            // Populate brand selector
            const brandSelect = document.getElementById('flueBrandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';
            FLUE_AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üî• Select brand/model, then tap to mark horizontal flue terminal position';

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Add fresh listener
            state.canvas.addEventListener('click', handlePositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Horizontal flue mode started');
        }

        function startVerticalFlueMode() {
            console.log('=== START VERTICAL FLUE MODE CALLED ===');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'flue';
            state.flueType = 'vertical';
            state.position = null;
            state.flueBrand = null;
            state.flueModel = null;
            state.flueClearances = null;

            // Hide other mode sections
            document.getElementById('boilerEditingSection').style.display = 'none';
            document.getElementById('radiatorEditingSection').style.display = 'none';
            document.getElementById('flueEditingSection').style.display = 'none';

            // Show vertical flue editing section
            document.getElementById('verticalFlueEditingSection').style.display = 'block';

            // Populate brand selector
            const brandSelect = document.getElementById('verticalFlueBrandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';
            VERTICAL_FLUE_AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = '‚¨ÜÔ∏è Select brand/model, then tap to mark vertical flue terminal position';

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Add fresh listener
            state.canvas.addEventListener('click', handlePositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Vertical flue mode started');
        }

        function updateFlueModelSelector() {
            const brand = document.getElementById('flueBrandSelect').value;
            const modelSelect = document.getElementById('flueModelSelect');
            const modelLabel = document.getElementById('flueModelSelectorLabel');

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            // Get models for this brand
            if (FLUE_AVAILABLE_MODELS[brand]) {
                const models = FLUE_AVAILABLE_MODELS[brand];

                // Populate model dropdown
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });

                modelLabel.style.display = 'block';
            } else {
                modelLabel.style.display = 'none';
            }
        }

        function displayFlueClearances() {
            const brand = document.getElementById('flueBrandSelect').value;
            const model = document.getElementById('flueModelSelect').value;

            if (!brand || !model) return;

            state.flueBrand = brand;
            state.flueModel = model;

            // Get clearances for this model
            const clearances = getFlueClearancesForModel(brand, model);
            state.flueClearances = clearances;

            // Display clearances
            const displayDiv = document.getElementById('flueClearancesDisplay');
            const listDiv = document.getElementById('flueClearancesList');
            const rulesSection = document.getElementById('flueSpecialRulesSection');
            const rulesContent = document.getElementById('flueSpecialRulesContent');

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #667eea;"><th style="padding: 8px; text-align: left;">Position/Scenario</th><th style="padding: 8px; text-align: right;">Clearance</th></tr>';

            let specialRules = [];

            for (const [position, data] of Object.entries(clearances)) {
                html += `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px;">${position}</td>
                    <td style="padding: 8px; text-align: right; font-weight: bold;">${data.clearanceMM}mm</td>
                </tr>`;

                if (data.specialRules) {
                    specialRules.push(`<strong>${position}:</strong> ${data.specialRules}`);
                }
            }

            html += '</table>';
            listDiv.innerHTML = html;
            displayDiv.style.display = 'block';

            // Show special rules if any
            if (specialRules.length > 0) {
                rulesContent.innerHTML = '‚Ä¢ ' + specialRules.join('<br>‚Ä¢ ');
                rulesSection.style.display = 'block';
            } else {
                rulesSection.style.display = 'none';
            }

            // Update status
            document.getElementById('positionStatus').textContent = 'üî• Tap on the image to mark the flue terminal position';
        }

        function updateVerticalFlueModelSelector() {
            const brand = document.getElementById('verticalFlueBrandSelect').value;
            const modelSelect = document.getElementById('verticalFlueModelSelect');
            const modelLabel = document.getElementById('verticalFlueModelSelectorLabel');

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            // Get models for this brand
            if (VERTICAL_FLUE_AVAILABLE_MODELS[brand]) {
                const models = VERTICAL_FLUE_AVAILABLE_MODELS[brand];

                // Populate model dropdown
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });

                modelLabel.style.display = 'block';
            } else {
                modelLabel.style.display = 'none';
            }
        }

        function displayVerticalFlueClearances() {
            const brand = document.getElementById('verticalFlueBrandSelect').value;
            const model = document.getElementById('verticalFlueModelSelect').value;

            if (!brand || !model) return;

            state.flueBrand = brand;
            state.flueModel = model;

            // Get clearances for this model
            const clearances = getVerticalFlueClearancesForModel(brand, model);
            state.flueClearances = clearances;

            // Display clearances
            const displayDiv = document.getElementById('verticalFlueClearancesDisplay');
            const listDiv = document.getElementById('verticalFlueClearancesList');
            const rulesSection = document.getElementById('verticalFlueSpecialRulesSection');
            const rulesContent = document.getElementById('verticalFlueSpecialRulesContent');

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 2px solid #667eea;"><th style="padding: 8px; text-align: left;">Position/Scenario</th><th style="padding: 8px; text-align: right;">Clearance</th></tr>';

            let specialRules = [];

            for (const [position, data] of Object.entries(clearances)) {
                html += `<tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px;">${position}</td>
                    <td style="padding: 8px; text-align: right; font-weight: bold;">${data.clearanceMM}mm</td>
                </tr>`;

                if (data.specialRules) {
                    specialRules.push(`<strong>${position}:</strong> ${data.specialRules}`);
                }
            }

            html += '</table>';
            listDiv.innerHTML = html;
            displayDiv.style.display = 'block';

            // Show special rules if any
            if (specialRules.length > 0) {
                rulesContent.innerHTML = '‚Ä¢ ' + specialRules.join('<br>‚Ä¢ ');
                rulesSection.style.display = 'block';
            } else {
                rulesSection.style.display = 'none';
            }

            // Update status
            document.getElementById('positionStatus').textContent = '‚¨ÜÔ∏è Tap on the image to mark the vertical flue terminal position';
        }

        function updateModelSelector() {
            const brand = document.getElementById('brandSelect').value;
            const modelSelect = document.getElementById('modelSelect');
            const modelLabel = document.getElementById('modelSelectorLabel');

            // Show model selector only in boiler mode
            if (state.mode !== 'boiler') return;

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            if (AVAILABLE_MODELS[brand]) {
                const models = AVAILABLE_MODELS[brand];

                // Populate model dropdown
                modelSelect.innerHTML = '<option value="">Select a model...</option>';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });

                modelLabel.style.display = 'block';
            } else {
                modelLabel.style.display = 'none';
            }
        }

        function updateBoilerClearancesFromCSV() {
            const brand = document.getElementById('brandSelect').value;
            const model = document.getElementById('modelSelect').value;

            if (!model) return;

            // Get clearances from CSV
            const clearances = getBoilerClearancesForModel(brand, model);

            console.log('Loaded clearances for', brand, model, ':', clearances);

            // Update the input fields with CSV values
            if (clearances.top !== null) {
                document.getElementById('clearanceTop').value = clearances.top;
                state.boilerClearances.top = clearances.top;
            }
            if (clearances.bottom !== null) {
                document.getElementById('clearanceBottom').value = clearances.bottom;
                state.boilerClearances.bottom = clearances.bottom;
            }
            if (clearances.left !== null) {
                document.getElementById('clearanceLeft').value = clearances.left;
                state.boilerClearances.left = clearances.left;
            }
            if (clearances.right !== null) {
                document.getElementById('clearanceRight').value = clearances.right;
                state.boilerClearances.right = clearances.right;
            }

            // Show notes if available
            const notesSection = document.getElementById('clearanceNotesSection');
            const notesContent = document.getElementById('clearanceNotesContent');

            if (clearances.notes.length > 0) {
                const notesText = clearances.notes.filter(n => n).join('<br>‚Ä¢ ');
                console.log('Notes:', notesText);

                notesContent.innerHTML = '‚Ä¢ ' + notesText;
                notesSection.style.display = 'block';
            } else {
                notesSection.style.display = 'none';
            }

            // Redraw if position already set
            if (state.position) {
                drawBoilerWithClearances();
            }
        }

        function startBoilerMode() {
            console.log('startBoilerMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'boiler';
            state.position = null; // Clear any previous position

            // Initialize default boiler dimensions
            state.boilerDimensions = {
                height: 600,  // mm
                width: 390,   // mm
                depth: 280    // mm (not used in 2D view)
            };

            // Initialize default clearances
            state.boilerClearances = {
                top: 170,     // mm
                bottom: 200,  // mm
                left: 5,      // mm
                right: 5      // mm
            };

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üîß Select brand/model, then tap where the boiler center will be located';

            // Populate brand selector from CSV data
            const brandSelect = document.getElementById('brandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';
            AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });

            // Show model selector
            updateModelSelector();

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);

            // Add boiler-specific listener
            state.canvas.addEventListener('click', handleBoilerPositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Boiler mode started - canvas ready for position click');
        }

        function startRadiatorMode() {
            console.log('startRadiatorMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'radiator';
            state.position = null; // Clear any previous position

            // Initialize default radiator dimensions
            state.radiatorDimensions = {
                height: 600,  // mm (options: 300, 450, 600, 700)
                width: 400    // mm (400-3000 in 200mm steps)
            };

            // Initialize default clearances (150mm sides/bottom, 0mm top)
            state.radiatorClearances = {
                top: 0,       // mm
                bottom: 150,  // mm
                left: 150,    // mm
                right: 150    // mm
            };

            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üå°Ô∏è Tap where the radiator center will be located';

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);

            // Add radiator-specific listener
            state.canvas.addEventListener('click', handleRadiatorPositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Radiator mode started - canvas ready for position click');
        }

        function startCylinderMode() {
            console.log('startCylinderMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'cylinder';
            state.position = null; // Clear any previous position

            // Show cylinder selection UI
            document.getElementById('cylinderEditingSection').style.display = 'block';
            document.getElementById('boilerEditingSection').style.display = 'none';
            document.getElementById('radiatorEditingSection').style.display = 'none';
            document.getElementById('flueEditingSection').style.display = 'none';
            document.getElementById('verticalFlueEditingSection').style.display = 'none';

            // Populate brand selector
            updateCylinderBrandSelector();

            console.log('Cylinder mode started');
        }

        function updateCylinderBrandSelector() {
            const brandSelect = document.getElementById('cylinderBrandSelect');
            brandSelect.innerHTML = '<option value="">Select a brand...</option>';

            CYLINDER_AVAILABLE_BRANDS.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand;
                option.textContent = brand;
                brandSelect.appendChild(option);
            });
        }

        function updateCylinderModelSelector() {
            const brand = document.getElementById('cylinderBrandSelect').value;
            const modelSelect = document.getElementById('cylinderModelSelect');
            const modelLabel = document.getElementById('cylinderModelSelectorLabel');

            if (!brand) {
                modelLabel.style.display = 'none';
                return;
            }

            modelSelect.innerHTML = '<option value="">Select a model...</option>';

            const models = CYLINDER_AVAILABLE_MODELS[brand] || [];
            models.forEach(modelKey => {
                const option = document.createElement('option');
                option.value = modelKey;
                option.textContent = modelKey;
                modelSelect.appendChild(option);
            });

            modelLabel.style.display = 'block';
        }

        function displayCylinderDetails() {
            const brand = document.getElementById('cylinderBrandSelect').value;
            const modelKey = document.getElementById('cylinderModelSelect').value;

            if (!brand || !modelKey) {
                document.getElementById('cylinderDetailsDisplay').style.display = 'none';
                document.getElementById('placeCylinderBtn').style.display = 'none';
                return;
            }

            const cylinder = getCylinderByKey(brand, modelKey);
            if (!cylinder) {
                console.error('Cylinder not found:', brand, modelKey);
                return;
            }

            // Parse dimensions
            const dims = parseCylinderDimensions(cylinder.dimensions);

            // Store in state
            state.cylinderDimensions = dims || { height: 1200, diameter: 520 };
            state.cylinderInfo = cylinder;

            // Display details
            const detailsList = document.getElementById('cylinderDetailsList');
            detailsList.innerHTML = `
                <p><strong>Type:</strong> ${cylinder.type}</p>
                <p><strong>Model:</strong> ${cylinder.model}</p>
                <p><strong>Volume:</strong> ${cylinder.volume}</p>
                ${cylinder.dimensions ? `<p><strong>Dimensions:</strong> ${cylinder.dimensions}</p>` : ''}
                ${cylinder.price ? `<p><strong>Price:</strong> ¬£${cylinder.price}</p>` : ''}
                ${cylinder.code ? `<p><strong>Code:</strong> ${cylinder.code}</p>` : ''}
            `;

            document.getElementById('cylinderDetailsDisplay').style.display = 'block';
            document.getElementById('placeCylinderBtn').style.display = 'block';
        }

        function enableCylinderPlacement() {
            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handleBoilerPositionClick);
            state.canvas.removeEventListener('click', handleRadiatorPositionClick);
            state.canvas.removeEventListener('click', handleCylinderPositionClick);

            // Add cylinder-specific listener
            state.canvas.addEventListener('click', handleCylinderPositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            // Update status
            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üóúÔ∏è Tap where the cylinder center will be located';

            console.log('Cylinder placement enabled - canvas ready for position click');
        }

        function handleCylinderPositionClick(e) {
            if (state.isCalibrating || state.isMovingObject) return;

            // Use proper coordinate transformation for zoom/pan
            const {x, y} = getCanvasCoordinates(e);

            // Add cylinder to placed objects array
            state.placedObjects.push({
                type: 'cylinder',
                position: {x, y},
                dimensions: {...state.cylinderDimensions},
                info: state.cylinderInfo ? {...state.cylinderInfo} : null
            });

            // Keep for backwards compatibility
            state.position = {x, y};

            // Redraw all objects
            redrawAllPlacedObjects();

            console.log('Cylinder placed at:', {x, y}, 'Total objects:', state.placedObjects.length);
        }

        function redrawAllPlacedObjects() {
            // Redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw all placed objects
            state.placedObjects.forEach((obj, index) => {
                if (obj.type === 'boiler') {
                    drawBoilerObject(obj);
                } else if (obj.type === 'cylinder') {
                    drawCylinderObject(obj);
                } else if (obj.type === 'radiator') {
                    drawRadiatorObject(obj);
                }
            });
        }

        function drawBoilerObject(obj) {
            const boilerWidthPx = obj.dimensions.width * state.pxPerMM;
            const boilerHeightPx = obj.dimensions.height * state.pxPerMM;

            const clearanceTopPx = obj.clearances.top * state.pxPerMM;
            const clearanceBottomPx = obj.clearances.bottom * state.pxPerMM;
            const clearanceLeftPx = obj.clearances.left * state.pxPerMM;
            const clearanceRightPx = obj.clearances.right * state.pxPerMM;

            const boilerX = obj.position.x - boilerWidthPx / 2;
            const boilerY = obj.position.y - boilerHeightPx / 2;

            // Draw clearance zone (red transparent)
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
            state.ctx.fillRect(
                boilerX - clearanceLeftPx,
                boilerY - clearanceTopPx,
                boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                boilerHeightPx + clearanceTopPx + clearanceBottomPx
            );

            // Draw clearance outline (red dashed)
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.strokeRect(
                boilerX - clearanceLeftPx,
                boilerY - clearanceTopPx,
                boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                boilerHeightPx + clearanceTopPx + clearanceBottomPx
            );
            state.ctx.setLineDash([]);

            // Draw boiler box (green solid)
            state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
            state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

            state.ctx.strokeStyle = '#48bb78';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(obj.position.x, obj.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw labels
            state.ctx.fillStyle = '#333';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.fillText(`Boiler ${obj.dimensions.width}√ó${obj.dimensions.height}mm`, boilerX + 10, boilerY + 25);
        }

        function drawCylinderObject(obj) {
            const diameterPx = obj.dimensions.diameter * state.pxPerMM;
            const heightPx = obj.dimensions.height * state.pxPerMM;

            const cylinderX = obj.position.x - diameterPx / 2;
            const cylinderY = obj.position.y - heightPx / 2;

            // Draw cylinder outline (rectangle with rounded ends for side view)
            state.ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            state.ctx.fillRect(cylinderX, cylinderY, diameterPx, heightPx);

            state.ctx.strokeStyle = '#4a90e2';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(cylinderX, cylinderY, diameterPx, heightPx);

            // Draw rounded top and bottom
            state.ctx.beginPath();
            state.ctx.ellipse(obj.position.x, cylinderY, diameterPx / 2, diameterPx / 8, 0, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            state.ctx.beginPath();
            state.ctx.ellipse(obj.position.x, cylinderY + heightPx, diameterPx / 2, diameterPx / 8, 0, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(obj.position.x, obj.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Label
            state.ctx.fillStyle = '#4a90e2';
            state.ctx.font = 'bold 16px Arial';
            const label = `Cylinder ${obj.dimensions.height}√ó${obj.dimensions.diameter}mm`;
            state.ctx.fillText(label, cylinderX + 10, cylinderY + 25);
        }

        function drawRadiatorObject(obj) {
            const radiatorWidthPx = obj.dimensions.width * state.pxPerMM;
            const radiatorHeightPx = obj.dimensions.height * state.pxPerMM;

            const clearanceTopPx = obj.clearances.top * state.pxPerMM;
            const clearanceBottomPx = obj.clearances.bottom * state.pxPerMM;
            const clearanceLeftPx = obj.clearances.left * state.pxPerMM;
            const clearanceRightPx = obj.clearances.right * state.pxPerMM;

            const radiatorX = obj.position.x - radiatorWidthPx / 2;
            const radiatorY = obj.position.y - radiatorHeightPx / 2;

            // Draw clearance zone (red transparent)
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
            state.ctx.fillRect(
                radiatorX - clearanceLeftPx,
                radiatorY - clearanceTopPx,
                radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                radiatorHeightPx + clearanceTopPx + clearanceBottomPx
            );

            // Draw clearance outline (red dashed)
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.strokeRect(
                radiatorX - clearanceLeftPx,
                radiatorY - clearanceTopPx,
                radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                radiatorHeightPx + clearanceTopPx + clearanceBottomPx
            );
            state.ctx.setLineDash([]);

            // Draw radiator box (orange solid for visibility)
            state.ctx.fillStyle = 'rgba(237, 137, 54, 0.3)';
            state.ctx.fillRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

            state.ctx.strokeStyle = '#ed8936';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(obj.position.x, obj.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw labels
            state.ctx.fillStyle = '#333';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.fillText(`Radiator ${obj.dimensions.width}√ó${obj.dimensions.height}mm`, radiatorX + 10, radiatorY + 25);
        }

        function drawCylinderOnCanvas() {
            if (!state.cylinderDimensions || !state.position) return;

            // Redraw base
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            const diameterPx = state.cylinderDimensions.diameter * state.pxPerMM;
            const heightPx = state.cylinderDimensions.height * state.pxPerMM;

            const cylinderX = state.position.x - diameterPx / 2;
            const cylinderY = state.position.y - heightPx / 2;

            // Draw cylinder outline (rectangle with rounded ends for side view)
            state.ctx.fillStyle = 'rgba(100, 150, 255, 0.3)';
            state.ctx.fillRect(cylinderX, cylinderY, diameterPx, heightPx);

            state.ctx.strokeStyle = '#4a90e2';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(cylinderX, cylinderY, diameterPx, heightPx);

            // Draw rounded top and bottom
            state.ctx.beginPath();
            state.ctx.ellipse(state.position.x, cylinderY, diameterPx / 2, diameterPx / 8, 0, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            state.ctx.beginPath();
            state.ctx.ellipse(state.position.x, cylinderY + heightPx, diameterPx / 2, diameterPx / 8, 0, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Label
            state.ctx.fillStyle = '#4a90e2';
            state.ctx.font = 'bold 16px Arial';
            const label = `Cylinder ${state.cylinderDimensions.height}√ó${state.cylinderDimensions.diameter}mm`;
            state.ctx.fillText(label, cylinderX + 10, cylinderY + 25);

            // Show download button
            document.getElementById('downloadCylinderMarkupBtn').style.display = 'block';
        }

        function handleBoilerPositionClick(e) {
            if (state.isCalibrating || state.isMovingObject) return;

            // Use proper coordinate transformation for zoom/pan
            const {x, y} = getCanvasCoordinates(e);

            // Add boiler to placed objects array
            state.placedObjects.push({
                type: 'boiler',
                position: {x, y},
                dimensions: {...state.boilerDimensions},
                clearances: {...state.boilerClearances}
            });

            // Keep for backwards compatibility
            state.position = {x, y};

            // Redraw all objects
            redrawAllPlacedObjects();

            document.getElementById('positionStatus').textContent = `‚úÖ Boiler ${state.placedObjects.filter(o => o.type === 'boiler').length} placed! Click to add more or switch modes.`;

            // Don't remove click listener - allow multiple placements
            // Show boiler editing controls
            if (document.getElementById('boilerEditingSection').style.display !== 'block') {
                document.getElementById('boilerEditingSection').style.display = 'block';
                // Show obstacle marking UI
                document.getElementById('obstacleMarkingSection').style.display = 'block';
            }
        }

        function handleRadiatorPositionClick(e) {
            if (state.isCalibrating || state.isMovingObject) return;

            // Use proper coordinate transformation for zoom/pan
            const {x, y} = getCanvasCoordinates(e);

            // Add radiator to placed objects array
            state.placedObjects.push({
                type: 'radiator',
                position: {x, y},
                dimensions: {...state.radiatorDimensions},
                clearances: {...state.radiatorClearances}
            });

            // Keep for backwards compatibility
            state.position = {x, y};

            // Redraw all objects
            redrawAllPlacedObjects();

            document.getElementById('positionStatus').textContent = `‚úÖ Radiator ${state.placedObjects.filter(o => o.type === 'radiator').length} placed! Click to add more or switch modes.`;

            // Don't remove click listener - allow multiple placements
            // Show radiator editing controls
            if (document.getElementById('radiatorEditingSection').style.display !== 'block') {
                document.getElementById('radiatorEditingSection').style.display = 'block';
                // Show obstacle marking UI
                document.getElementById('obstacleMarkingSection').style.display = 'block';
            }
        }

        function populateObstacleButtons() {
            const container = document.getElementById('obstacleButtonsContainer');
            container.innerHTML = '';

            let buttons = [];

            if (state.mode === 'flue' && state.flueType === 'vertical') {
                // Vertical flue obstacles
                buttons = [
                    { type: 'boundary', icon: 'üî≤', label: 'Add Boundary' },
                    { type: 'window-vent-vertical', icon: 'ü™ü', label: 'Add Window/Vent (Vertical)' },
                    { type: 'pitched-roof', icon: 'üè†', label: 'Add Pitched Roof' },
                    { type: 'velux-below', icon: 'üîª', label: 'Add Velux (Below)' },
                    { type: 'velux-above-sides', icon: 'üî∫', label: 'Add Velux (Above/Sides)' },
                    { type: 'skylight', icon: '‚òÄÔ∏è', label: 'Add Skylight' },
                    { type: 'combustible-material', icon: 'üî•', label: 'Add Combustible Material' },
                    { type: 'vertical-terminal', icon: '‚¨ÜÔ∏è', label: 'Add Other Vertical Terminal' }
                ];
            } else {
                // Horizontal flue obstacles (default)
                buttons = [
                    { type: 'window-openable', icon: 'ü™ü', label: 'Add Openable Window' },
                    { type: 'window-fixed', icon: 'ü™ü', label: 'Add Fixed Window' },
                    { type: 'vent', icon: 'üåÄ', label: 'Add Vent' },
                    { type: 'corner', icon: 'üìê', label: 'Add Corner' },
                    { type: 'soffit', icon: 'üè†', label: 'Add Soffit/Eaves' },
                    { type: 'downpipe', icon: 'üíß', label: 'Add Downpipe' }
                ];
            }

            // Add buttons to container
            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = 'btn btn-secondary';
                button.onclick = () => startMarkingObstacle(btn.type);
                button.textContent = `${btn.icon} ${btn.label}`;
                container.appendChild(button);
            });

            // Add cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn btn-danger';
            cancelBtn.onclick = cancelMarking;
            cancelBtn.textContent = '‚ùå Cancel Marking';
            container.appendChild(cancelBtn);
        }

        function handlePositionClick(e) {
            if (state.isCalibrating) return;

            console.log('Position click detected!'); // Debug

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            console.log('Clicked at:', x, y); // Debug

            state.position = {x, y};

            // Clear and redraw EVERYTHING
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw BIG obvious marker
            state.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            state.ctx.strokeStyle = '#ff0000';
            state.ctx.lineWidth = 5;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 30, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            // Draw crosshair
            state.ctx.strokeStyle = '#ff0000';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 50, y);
            state.ctx.lineTo(x + 50, y);
            state.ctx.moveTo(x, y - 50);
            state.ctx.lineTo(x, y + 50);
            state.ctx.stroke();

            console.log('Marker drawn'); // Debug

            document.getElementById('positionStatus').textContent = '‚úÖ Flue terminal position marked! Now mark obstacles below.';

            // Remove position click listener
            state.canvas.removeEventListener('click', handlePositionClick);

            // Show manual obstacle marking UI immediately and populate buttons
            populateObstacleButtons();
            document.getElementById('obstacleMarkingSection').style.display = 'block';
        }

        function updateBoilerDisplay() {
            // Read values from inputs
            state.boilerDimensions.height = parseInt(document.getElementById('boilerHeight').value) || 600;
            state.boilerDimensions.width = parseInt(document.getElementById('boilerWidth').value) || 390;
            state.boilerClearances.top = parseInt(document.getElementById('clearanceTop').value) || 170;
            state.boilerClearances.bottom = parseInt(document.getElementById('clearanceBottom').value) || 200;
            state.boilerClearances.left = parseInt(document.getElementById('clearanceLeft').value) || 5;
            state.boilerClearances.right = parseInt(document.getElementById('clearanceRight').value) || 5;

            // Redraw
            drawBoilerWithClearances();
        }

        function updateRadiatorDisplay() {
            // Read values from inputs
            state.radiatorDimensions.height = parseInt(document.getElementById('radiatorHeight').value) || 600;
            state.radiatorDimensions.width = parseInt(document.getElementById('radiatorWidth').value) || 400;
            state.radiatorClearances.top = parseInt(document.getElementById('radiatorClearanceTop').value) || 0;
            state.radiatorClearances.bottom = parseInt(document.getElementById('radiatorClearanceBottom').value) || 150;
            state.radiatorClearances.left = parseInt(document.getElementById('radiatorClearanceLeft').value) || 150;
            state.radiatorClearances.right = parseInt(document.getElementById('radiatorClearanceRight').value) || 150;

            // Redraw
            drawRadiatorWithClearances();
        }

        function adjustRadiatorWidth(delta) {
            const currentWidth = parseInt(document.getElementById('radiatorWidth').value) || 400;
            let newWidth = currentWidth + delta;

            // Clamp to valid range (400 to 3000mm in 200mm steps)
            newWidth = Math.max(400, Math.min(3000, newWidth));

            document.getElementById('radiatorWidth').value = newWidth;
            updateRadiatorDisplay();
        }

        function adjustBoilerWidth(delta) {
            const currentWidth = parseInt(document.getElementById('boilerWidth').value) || 390;
            let newWidth = currentWidth + delta;

            // Keep reasonable bounds (minimum 100mm, maximum 1000mm)
            newWidth = Math.max(100, Math.min(1000, newWidth));

            document.getElementById('boilerWidth').value = newWidth;
            updateBoilerDisplay();
        }

        function drawBoilerWithClearances() {
            // Clear and redraw
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            const boilerWidthPx = state.boilerDimensions.width * state.pxPerMM;
            const boilerHeightPx = state.boilerDimensions.height * state.pxPerMM;

            const clearanceTopPx = state.boilerClearances.top * state.pxPerMM;
            const clearanceBottomPx = state.boilerClearances.bottom * state.pxPerMM;
            const clearanceLeftPx = state.boilerClearances.left * state.pxPerMM;
            const clearanceRightPx = state.boilerClearances.right * state.pxPerMM;

            // Calculate boiler box position (centered on click)
            const boilerX = state.position.x - boilerWidthPx / 2;
            const boilerY = state.position.y - boilerHeightPx / 2;

            // Draw clearance zone (red transparent)
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
            state.ctx.fillRect(
                boilerX - clearanceLeftPx,
                boilerY - clearanceTopPx,
                boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                boilerHeightPx + clearanceTopPx + clearanceBottomPx
            );

            // Draw clearance outline (red dashed)
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.strokeRect(
                boilerX - clearanceLeftPx,
                boilerY - clearanceTopPx,
                boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                boilerHeightPx + clearanceTopPx + clearanceBottomPx
            );
            state.ctx.setLineDash([]);

            // Draw boiler box (green solid)
            state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
            state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

            state.ctx.strokeStyle = '#48bb78';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw labels
            state.ctx.fillStyle = '#333';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.fillText(`Boiler ${state.boilerDimensions.width}√ó${state.boilerDimensions.height}mm`, boilerX + 10, boilerY + 25);
            state.ctx.fillText(`Clearances: ${state.boilerClearances.top}mm ‚Üë`, boilerX + 10, boilerY - clearanceTopPx + 20);
            state.ctx.fillText(`${state.boilerClearances.bottom}mm ‚Üì`, boilerX + 10, boilerY + boilerHeightPx + clearanceBottomPx - 10);

            // Show download button
            document.getElementById('downloadBoilerMarkupBtn').style.display = 'block';
        }

        function drawRadiatorWithClearances() {
            // Clear and redraw
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            const radiatorWidthPx = state.radiatorDimensions.width * state.pxPerMM;
            const radiatorHeightPx = state.radiatorDimensions.height * state.pxPerMM;

            const clearanceTopPx = state.radiatorClearances.top * state.pxPerMM;
            const clearanceBottomPx = state.radiatorClearances.bottom * state.pxPerMM;
            const clearanceLeftPx = state.radiatorClearances.left * state.pxPerMM;
            const clearanceRightPx = state.radiatorClearances.right * state.pxPerMM;

            // Calculate radiator box position (centered on click)
            const radiatorX = state.position.x - radiatorWidthPx / 2;
            const radiatorY = state.position.y - radiatorHeightPx / 2;

            // Draw clearance zone (red transparent)
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
            state.ctx.fillRect(
                radiatorX - clearanceLeftPx,
                radiatorY - clearanceTopPx,
                radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                radiatorHeightPx + clearanceTopPx + clearanceBottomPx
            );

            // Draw clearance outline (red dashed)
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.strokeRect(
                radiatorX - clearanceLeftPx,
                radiatorY - clearanceTopPx,
                radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                radiatorHeightPx + clearanceTopPx + clearanceBottomPx
            );
            state.ctx.setLineDash([]);

            // Draw radiator box (orange solid for visibility)
            state.ctx.fillStyle = 'rgba(237, 137, 54, 0.3)';
            state.ctx.fillRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

            state.ctx.strokeStyle = '#ed8936';
            state.ctx.lineWidth = 4;
            state.ctx.strokeRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

            // Draw center marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw labels
            state.ctx.fillStyle = '#333';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.fillText(`Radiator ${state.radiatorDimensions.width}√ó${state.radiatorDimensions.height}mm`, radiatorX + 10, radiatorY + 25);
            if (clearanceTopPx > 0) {
                state.ctx.fillText(`Clearances: ${state.radiatorClearances.top}mm ‚Üë`, radiatorX + 10, radiatorY - clearanceTopPx + 20);
            }
            state.ctx.fillText(`${state.radiatorClearances.bottom}mm ‚Üì`, radiatorX + 10, radiatorY + radiatorHeightPx + clearanceBottomPx - 10);

            // Show download button
            document.getElementById('downloadRadiatorMarkupBtn').style.display = 'block';
        }

        function drawPositionMarker(x, y) {
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 20, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();
            
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 2;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 30, y);
            state.ctx.lineTo(x + 30, y);
            state.ctx.moveTo(x, y - 30);
            state.ctx.lineTo(x, y + 30);
            state.ctx.stroke();
        }

        function startMarkingObstacle(type) {
            state.markingMode = type;
            state.markingPoints = [];

            let needsPoints;
            let firstMessage;

            // Point obstacles (single tap)
            if (type === 'corner' || type === 'downpipe' || type === 'boundary' || type === 'vertical-terminal') {
                needsPoints = 1;
                const displayName = type.replace(/-/g, ' ');
                firstMessage = `üëÜ Tap location of ${displayName}`;
            }
            // 4-point obstacles (windows)
            else if (type === 'window-openable' || type === 'window-fixed') {
                needsPoints = 4;
                const windowType = type === 'window-openable' ? 'openable window' : 'fixed window';
                firstMessage = `üëÜ Tap top-left corner of ${windowType}`;
            }
            // 2-point rectangular obstacles
            else {
                needsPoints = 2;
                const displayName = type.replace(/-/g, ' ');
                firstMessage = `üëÜ Tap top-left corner of ${displayName}`;
            }

            const status = document.getElementById('markingStatus');
            status.classList.add('active');
            status.textContent = firstMessage;

            // Add marking click listener
            state.canvas.removeEventListener('click', handleMarkingClick);
            state.canvas.addEventListener('click', handleMarkingClick);
        }

        // Helper function to convert click coordinates to canvas coordinates with zoom/pan
        function getCanvasCoordinates(e) {
            const rect = state.canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left) * state.canvasScale;
            let y = (e.clientY - rect.top) * state.canvasScale;

            // Reverse zoom and pan transformation to match drawClearanceZones
            // The canvas transform applies (in order):
            // 1. translate(panX / canvasScale, panY / canvasScale)
            // 2. scale(zoomLevel, zoomLevel)
            // 3. translate((centerX - centerX * zoomLevel) / canvasScale, (centerY - centerY * zoomLevel) / canvasScale)
            // To reverse: undo in reverse order (3, 2, 1)

            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            // Undo translate for center offset (T2)
            x = x - (centerX - centerX * state.zoomLevel) / state.canvasScale;
            y = y - (centerY - centerY * state.zoomLevel) / state.canvasScale;

            // Undo scale (S)
            x = x / state.zoomLevel;
            y = y / state.zoomLevel;

            // Undo translate for pan (T1)
            x = x - state.panX / state.canvasScale;
            y = y - state.panY / state.canvasScale;

            return {x, y};
        }

        function handleMarkingClick(e) {
            if (!state.markingMode) return;

            const {x, y} = getCanvasCoordinates(e);

            state.markingPoints.push({x, y});

            let needsPoints;
            if (state.markingMode === 'corner' || state.markingMode === 'downpipe') {
                needsPoints = 1;
            } else if (state.markingMode === 'window-openable' || state.markingMode === 'window-fixed') {
                needsPoints = 4;
            } else {
                needsPoints = 2;
            }

            // Draw temporary marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            // Draw connecting lines for windows (4-point marking)
            if ((state.markingMode === 'window-openable' || state.markingMode === 'window-fixed') && state.markingPoints.length > 1) {
                state.ctx.strokeStyle = '#667eea';
                state.ctx.lineWidth = 2;
                state.ctx.beginPath();
                const prevPoint = state.markingPoints[state.markingPoints.length - 2];
                state.ctx.moveTo(prevPoint.x, prevPoint.y);
                state.ctx.lineTo(x, y);
                state.ctx.stroke();
            }

            if (state.markingPoints.length < needsPoints) {
                // Need more points
                const status = document.getElementById('markingStatus');
                const windowType = state.markingMode === 'window-openable' ? 'openable window' :
                                 state.markingMode === 'window-fixed' ? 'fixed window' : state.markingMode;

                if (state.markingMode === 'window-openable' || state.markingMode === 'window-fixed') {
                    const messages = ['top-right corner', 'bottom-right corner', 'bottom-left corner'];
                    status.textContent = `üëÜ Tap ${messages[state.markingPoints.length - 1]} of ${windowType}`;
                } else {
                    status.textContent = `üëÜ Tap bottom-right corner of ${state.markingMode}`;
                }
            } else {
                // Complete the obstacle
                completeObstacleMarking();
            }
        }

        function completeObstacleMarking() {
            const type = state.markingMode;
            const points = state.markingPoints;

            let obstacle;

            if (type === 'corner' || type === 'downpipe') {
                // Point obstacle - use a small fixed size
                const pointSize = 20;
                obstacle = {
                    type: type,
                    x: points[0].x - pointSize / 2,
                    y: points[0].y - pointSize / 2,
                    width: pointSize,
                    height: pointSize
                };
            } else if (type === 'window-openable' || type === 'window-fixed') {
                // 4-point window (quadrilateral)
                // Calculate bounding box for quick operations
                const xs = points.map(p => p.x);
                const ys = points.map(p => p.y);
                const x1 = Math.min(...xs);
                const y1 = Math.min(...ys);
                const x2 = Math.max(...xs);
                const y2 = Math.max(...ys);

                obstacle = {
                    type: 'window',
                    windowType: type === 'window-openable' ? 'openable' : 'fixed',
                    points: points, // Store all 4 points for precise rendering
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: y2 - y1
                };
            } else {
                // Rectangle obstacle
                const x1 = Math.min(points[0].x, points[1].x);
                const y1 = Math.min(points[0].y, points[1].y);
                const x2 = Math.max(points[0].x, points[1].x);
                const y2 = Math.max(points[0].y, points[1].y);

                obstacle = {
                    type: type,
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: y2 - y1
                };
            }

            state.obstacles.push(obstacle);

            // Redraw canvas with all obstacles
            redrawCanvasWithObstacles();

            // Update obstacle list
            updateObstaclesList();

            // Reset marking mode
            cancelMarking();

            // Show calculate button
            document.getElementById('calculateBtn').style.display = 'block';

            const status = document.getElementById('markingStatus');
            status.classList.add('active');
            const displayType = type === 'window-openable' ? 'openable window' :
                              type === 'window-fixed' ? 'fixed window' : type;
            status.textContent = `‚úÖ ${displayType} marked! Add more obstacles or click Calculate.`;
        }

        function cancelMarking() {
            state.markingMode = null;
            state.markingPoints = [];
            state.canvas.removeEventListener('click', handleMarkingClick);

            const status = document.getElementById('markingStatus');
            status.classList.remove('active');
            status.textContent = 'Select an obstacle type below to start marking';
        }

        function updateObstaclesList() {
            const list = document.getElementById('obstaclesListContent');
            const container = document.getElementById('obstaclesList');

            if (state.obstacles.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            list.innerHTML = state.obstacles.map((obs, index) => `
                <div class="obstacle-item">
                    <div>
                        <strong>${index + 1}. ${obs.type}</strong> -
                        Position: (${Math.round(obs.x)}, ${Math.round(obs.y)})
                        Size: ${Math.round(obs.width)}√ó${Math.round(obs.height)}px
                    </div>
                    <button class="obstacle-delete-btn" onclick="deleteObstacle(${index})">
                        Delete
                    </button>
                </div>
            `).join('');
        }

        function deleteObstacle(index) {
            state.obstacles.splice(index, 1);
            updateObstaclesList();
            redrawCanvasWithObstacles();

            if (state.obstacles.length === 0) {
                document.getElementById('calculateBtn').style.display = 'none';
            }
        }

        // Zoom and Pan Functions
        function zoomIn() {
            state.zoomLevel = Math.min(state.zoomLevel * 1.2, 5);
            applyZoomAndPan();
        }

        function zoomOut() {
            state.zoomLevel = Math.max(state.zoomLevel / 1.2, 0.5);
            applyZoomAndPan();
        }

        function resetZoom() {
            state.zoomLevel = 1;
            state.panX = 0;
            state.panY = 0;
            applyZoomAndPan();
        }

        function panUp() {
            state.panY += 300;
            applyZoomAndPan();
        }

        function panDown() {
            state.panY -= 300;
            applyZoomAndPan();
        }

        function panLeft() {
            state.panX += 300;
            applyZoomAndPan();
        }

        function panRight() {
            state.panX -= 300;
            applyZoomAndPan();
        }

        function applyZoomAndPan() {
            // Redraw with current zoom and pan
            if (state.zones) {
                drawClearanceZones();
            } else {
                redrawCanvasWithObstacles();
            }
        }

        // Long press object moving functionality
        function setupLongPressMove() {
            const canvas = state.canvas;

            canvas.addEventListener('mousedown', handleLongPressStart);
            canvas.addEventListener('touchstart', handleLongPressTouchStart);
            canvas.addEventListener('mousemove', handleObjectMove);
            canvas.addEventListener('touchmove', handleObjectMoveTouch);
            canvas.addEventListener('mouseup', handleLongPressEnd);
            canvas.addEventListener('touchend', handleLongPressEnd);
        }

        function handleLongPressStart(e) {
            if (!canMoveObject()) return;

            // Use proper coordinate transformation for zoom/pan
            const {x, y} = getCanvasCoordinates(e);

            // Check if click is on placed object
            const objectIndex = isClickOnObject(x, y);
            if (objectIndex >= 0) {
                state.movingObjectIndex = objectIndex;
                // Start long press timer
                state.longPressTimer = setTimeout(() => {
                    state.isMovingObject = true;
                    state.canvas.style.cursor = 'move';
                    const objType = state.placedObjects[objectIndex].type;
                    showMessage(`Moving ${objType} - drag to new position`);
                }, 500); // 500ms for long press
            }
        }

        function handleLongPressTouchStart(e) {
            if (!canMoveObject() || e.touches.length !== 1) return;

            e.preventDefault();
            // Create fake event for getCanvasCoordinates
            const fakeEvent = {
                clientX: e.touches[0].clientX,
                clientY: e.touches[0].clientY
            };
            const {x, y} = getCanvasCoordinates(fakeEvent);

            const objectIndex = isClickOnObject(x, y);
            if (objectIndex >= 0) {
                state.movingObjectIndex = objectIndex;
                state.longPressTimer = setTimeout(() => {
                    state.isMovingObject = true;
                    const objType = state.placedObjects[objectIndex].type;
                    showMessage(`Moving ${objType} - drag to new position`);
                }, 500);
            }
        }

        function handleObjectMove(e) {
            if (!state.isMovingObject) {
                // Cancel long press if mouse moves before timeout
                if (state.longPressTimer) {
                    clearTimeout(state.longPressTimer);
                    state.longPressTimer = null;
                }
                return;
            }

            // Use proper coordinate transformation for zoom/pan
            const {x, y} = getCanvasCoordinates(e);

            // Update position of the object being moved
            if (state.movingObjectIndex !== null && state.placedObjects[state.movingObjectIndex]) {
                state.placedObjects[state.movingObjectIndex].position = {x, y};
                // Also update state.position for backwards compatibility
                state.position = {x, y};
                // Redraw all objects
                redrawObjectAtNewPosition();
            }
        }

        function handleObjectMoveTouch(e) {
            if (!state.isMovingObject || e.touches.length !== 1) {
                if (state.longPressTimer) {
                    clearTimeout(state.longPressTimer);
                    state.longPressTimer = null;
                }
                return;
            }

            e.preventDefault();
            // Create fake event for getCanvasCoordinates
            const fakeEvent = {
                clientX: e.touches[0].clientX,
                clientY: e.touches[0].clientY
            };
            const {x, y} = getCanvasCoordinates(fakeEvent);

            // Update position of the object being moved
            if (state.movingObjectIndex !== null && state.placedObjects[state.movingObjectIndex]) {
                state.placedObjects[state.movingObjectIndex].position = {x, y};
                state.position = {x, y};
                redrawObjectAtNewPosition();
            }
        }

        function handleLongPressEnd() {
            if (state.longPressTimer) {
                clearTimeout(state.longPressTimer);
                state.longPressTimer = null;
            }

            if (state.isMovingObject) {
                state.isMovingObject = false;
                state.movingObjectIndex = null;
                state.canvas.style.cursor = 'crosshair';
                showMessage('Object moved successfully');
            }
        }

        function canMoveObject() {
            return state.placedObjects.length > 0;
        }

        function isClickOnObject(x, y) {
            // Check all placed objects, return index if found
            for (let i = state.placedObjects.length - 1; i >= 0; i--) {
                const obj = state.placedObjects[i];
                let width, height;

                if (obj.type === 'boiler' || obj.type === 'radiator') {
                    width = obj.dimensions.width * state.pxPerMM;
                    height = obj.dimensions.height * state.pxPerMM;
                } else if (obj.type === 'cylinder') {
                    width = obj.dimensions.diameter * state.pxPerMM;
                    height = obj.dimensions.height * state.pxPerMM;
                } else {
                    continue;
                }

                const objX = obj.position.x - width / 2;
                const objY = obj.position.y - height / 2;

                if (x >= objX && x <= objX + width && y >= objY && y <= objY + height) {
                    return i; // Return index of clicked object
                }
            }

            return -1; // Not found
        }

        function redrawObjectAtNewPosition() {
            redrawAllPlacedObjects();
        }

        function showMessage(msg) {
            const statusDiv = document.getElementById('positionStatus');
            if (statusDiv) {
                const originalText = statusDiv.textContent;
                statusDiv.textContent = msg;
                setTimeout(() => {
                    statusDiv.textContent = originalText;
                }, 2000);
            }
        }

        function setupPanControls() {
            const canvas = state.canvas;

            canvas.addEventListener('mousedown', startPan);
            canvas.addEventListener('mousemove', doPan);
            canvas.addEventListener('mouseup', endPan);
            canvas.addEventListener('mouseleave', endPan);

            // Touch events for mobile
            canvas.addEventListener('touchstart', startPanTouch);
            canvas.addEventListener('touchmove', doPanTouch);
            canvas.addEventListener('touchend', endPan);
        }

        function startPan(e) {
            // Only pan if not in marking mode and zoom is active
            if (!state.markingMode && state.zoomLevel !== 1) {
                state.isPanning = true;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;
                state.canvas.style.cursor = 'grabbing';
            }
        }

        function doPan(e) {
            if (state.isPanning) {
                const deltaX = e.clientX - state.lastPanX;
                const deltaY = e.clientY - state.lastPanY;

                state.panX += deltaX;
                state.panY += deltaY;
                state.lastPanX = e.clientX;
                state.lastPanY = e.clientY;

                applyZoomAndPan();
            }
        }

        function endPan() {
            if (state.isPanning) {
                state.isPanning = false;
                state.canvas.style.cursor = state.zoomLevel === 1 ? 'crosshair' : 'grab';
            }
        }

        function startPanTouch(e) {
            if (!state.markingMode && state.zoomLevel !== 1 && e.touches.length === 1) {
                e.preventDefault();
                state.isPanning = true;
                state.lastPanX = e.touches[0].clientX;
                state.lastPanY = e.touches[0].clientY;
            }
        }

        function doPanTouch(e) {
            if (state.isPanning && e.touches.length === 1) {
                e.preventDefault();
                const deltaX = e.touches[0].clientX - state.lastPanX;
                const deltaY = e.touches[0].clientY - state.lastPanY;

                state.panX += deltaX;
                state.panY += deltaY;
                state.lastPanX = e.touches[0].clientX;
                state.lastPanY = e.touches[0].clientY;

                applyZoomAndPan();
            }
        }

        function redrawCanvasWithObstacles() {
            // Clear and redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);

            // Apply zoom and pan transformation
            state.ctx.save();
            const rect = state.canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            state.ctx.translate(state.panX / state.canvasScale, state.panY / state.canvasScale);
            state.ctx.scale(state.zoomLevel, state.zoomLevel);
            state.ctx.translate((centerX - centerX * state.zoomLevel) / state.canvasScale, (centerY - centerY * state.zoomLevel) / state.canvasScale);

            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw position marker based on mode
            if (state.position) {
                if (state.mode === 'boiler' && state.boilerDimensions) {
                    // Draw boiler box with clearances
                    const boilerWidthPx = state.boilerDimensions.width * state.pxPerMM;
                    const boilerHeightPx = state.boilerDimensions.height * state.pxPerMM;

                    const clearanceTopPx = state.boilerClearances.top * state.pxPerMM;
                    const clearanceBottomPx = state.boilerClearances.bottom * state.pxPerMM;
                    const clearanceLeftPx = state.boilerClearances.left * state.pxPerMM;
                    const clearanceRightPx = state.boilerClearances.right * state.pxPerMM;

                    const boilerX = state.position.x - boilerWidthPx / 2;
                    const boilerY = state.position.y - boilerHeightPx / 2;

                    // Draw clearance zone (red transparent)
                    state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
                    state.ctx.fillRect(
                        boilerX - clearanceLeftPx,
                        boilerY - clearanceTopPx,
                        boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                        boilerHeightPx + clearanceTopPx + clearanceBottomPx
                    );

                    // Draw clearance outline (red dashed)
                    state.ctx.strokeStyle = '#f56565';
                    state.ctx.lineWidth = 3;
                    state.ctx.setLineDash([10, 5]);
                    state.ctx.strokeRect(
                        boilerX - clearanceLeftPx,
                        boilerY - clearanceTopPx,
                        boilerWidthPx + clearanceLeftPx + clearanceRightPx,
                        boilerHeightPx + clearanceTopPx + clearanceBottomPx
                    );
                    state.ctx.setLineDash([]);

                    // Draw boiler box (green solid)
                    state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
                    state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    state.ctx.strokeStyle = '#48bb78';
                    state.ctx.lineWidth = 4;
                    state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    // Draw center marker
                    state.ctx.fillStyle = '#667eea';
                    state.ctx.beginPath();
                    state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                } else if (state.mode === 'radiator' && state.radiatorDimensions) {
                    // Draw radiator box with clearances
                    const radiatorWidthPx = state.radiatorDimensions.width * state.pxPerMM;
                    const radiatorHeightPx = state.radiatorDimensions.height * state.pxPerMM;

                    const clearanceTopPx = state.radiatorClearances.top * state.pxPerMM;
                    const clearanceBottomPx = state.radiatorClearances.bottom * state.pxPerMM;
                    const clearanceLeftPx = state.radiatorClearances.left * state.pxPerMM;
                    const clearanceRightPx = state.radiatorClearances.right * state.pxPerMM;

                    const radiatorX = state.position.x - radiatorWidthPx / 2;
                    const radiatorY = state.position.y - radiatorHeightPx / 2;

                    // Draw clearance zone (red transparent)
                    state.ctx.fillStyle = 'rgba(245, 101, 101, 0.2)';
                    state.ctx.fillRect(
                        radiatorX - clearanceLeftPx,
                        radiatorY - clearanceTopPx,
                        radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                        radiatorHeightPx + clearanceTopPx + clearanceBottomPx
                    );

                    // Draw clearance outline (red dashed)
                    state.ctx.strokeStyle = '#f56565';
                    state.ctx.lineWidth = 3;
                    state.ctx.setLineDash([10, 5]);
                    state.ctx.strokeRect(
                        radiatorX - clearanceLeftPx,
                        radiatorY - clearanceTopPx,
                        radiatorWidthPx + clearanceLeftPx + clearanceRightPx,
                        radiatorHeightPx + clearanceTopPx + clearanceBottomPx
                    );
                    state.ctx.setLineDash([]);

                    // Draw radiator box (orange solid)
                    state.ctx.fillStyle = 'rgba(237, 137, 54, 0.3)';
                    state.ctx.fillRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

                    state.ctx.strokeStyle = '#ed8936';
                    state.ctx.lineWidth = 4;
                    state.ctx.strokeRect(radiatorX, radiatorY, radiatorWidthPx, radiatorHeightPx);

                    // Draw center marker
                    state.ctx.fillStyle = '#667eea';
                    state.ctx.beginPath();
                    state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                } else {
                    // Draw flue position marker
                    drawPositionMarker(state.position.x, state.position.y);
                }
            }

            // Draw all obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];

                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 4;

                // Draw window as polygon if it has 4 points
                if (obs.type === 'window' && obs.points && obs.points.length === 4) {
                    state.ctx.beginPath();
                    state.ctx.moveTo(obs.points[0].x, obs.points[0].y);
                    for (let i = 1; i < obs.points.length; i++) {
                        state.ctx.lineTo(obs.points[i].x, obs.points[i].y);
                    }
                    state.ctx.closePath();
                    state.ctx.stroke();
                } else {
                    state.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
                }

                // Label
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 20px Arial';
                const displayType = obs.type === 'window' ? `${obs.windowType || ''} window`.trim() : obs.type;
                state.ctx.fillText(`${index + 1}: ${displayType}`, obs.x + 5, obs.y + 25);
            });

            // Restore context state
            state.ctx.restore();
        }

        function calculateClearances() {
            if (!state.position || !state.pxPerMM) {
                alert('Missing position or calibration data');
                return;
            }

            let rules;
            if (state.mode === 'flue') {
                // Use CSV-based clearances for flue mode
                if (!state.flueClearances) {
                    alert('Please select a brand and model first');
                    return;
                }
                rules = state.flueClearances;
            } else {
                // Use hardcoded rules for boiler/radiator modes
                const brand = document.getElementById('brandSelect').value;
                rules = CLEARANCE_RULES[brand][state.mode];
            }

            // Calculate clearance zones for each obstacle
            state.zones = {
                prohibited: [],
                safe: []
            };

            state.obstacles.forEach(obs => {
                const clearanceMM = state.mode === 'flue' ?
                    getClearanceForObjectFlue(obs, rules) :
                    getClearanceForObject(obs.type, rules);
                if (clearanceMM === null) return;

                const clearancePx = clearanceMM * state.pxPerMM;

                // Calculate zone based on obstacle type
                let zoneX, zoneY, zoneMaxX, zoneMaxY;

                // Point obstacles get circular zones
                const pointObstacles = ['corner', 'downpipe', 'boundary', 'vertical-terminal'];
                if (pointObstacles.includes(obs.type)) {
                    // Circular zone for point obstacles
                    const centerX = obs.x + obs.width / 2;
                    const centerY = obs.y + obs.height / 2;

                    zoneX = centerX - clearancePx;
                    zoneY = centerY - clearancePx;
                    zoneMaxX = centerX + clearancePx;
                    zoneMaxY = centerY + clearancePx;
                } else {
                    // Directional zone for rectangular obstacles
                    const flueLeft = state.position.x < obs.x;
                    const flueRight = state.position.x > obs.x + obs.width;
                    const flueAbove = state.position.y < obs.y;
                    const flueBelow = state.position.y > obs.y + obs.height;

                    zoneX = flueLeft ? obs.x - clearancePx : obs.x - clearancePx * 0.3;
                    zoneY = flueAbove ? obs.y - clearancePx : obs.y - clearancePx * 0.3;
                    zoneMaxX = flueRight ? obs.x + obs.width + clearancePx : obs.x + obs.width + clearancePx * 0.3;
                    zoneMaxY = flueBelow ? obs.y + obs.height + clearancePx : obs.y + obs.height + clearancePx * 0.3;
                }

                // Clamp to image boundaries
                const clampedX = Math.max(0, zoneX);
                const clampedY = Math.max(0, zoneY);
                const clampedMaxX = Math.min(state.canvas.width, zoneMaxX);
                const clampedMaxY = Math.min(state.canvas.height, zoneMaxY);

                const finalWidth = clampedMaxX - clampedX;
                const finalHeight = clampedMaxY - clampedY;

                if (finalWidth > 0 && finalHeight > 0) {
                    state.zones.prohibited.push({
                        x: clampedX,
                        y: clampedY,
                        width: finalWidth,
                        height: finalHeight,
                        reason: `${clearanceMM}mm clearance from ${obs.type}`,
                        objectType: obs.type
                    });
                }
            });

            // Draw zones and check compliance
            drawClearanceZones();
            checkCompliance();

            // Show results panel
            document.getElementById('resultsPanel').classList.add('active');

            // Show flue output section if in flue mode
            if (state.mode === 'flue') {
                document.getElementById('flueOutputSection').style.display = 'block';
            }
        }

        function getClearanceForObject(objectType, rules) {
            const mapping = {
                window: "window",
                door: "door",
                corner: "corner",
                soffit: "soffit",
                vent: "vent",
                downpipe: "downpipe"
            };

            const ruleKey = mapping[objectType];
            return ruleKey ? (rules[ruleKey] ?? null) : null;
        }

        function getClearanceForObjectFlue(obstacle, flueClearances) {
            const objectType = obstacle.type;

            // Map obstacle type to CSV position/scenario
            let mapping;

            if (state.flueType === 'vertical') {
                // Vertical flue obstacle mappings
                mapping = {
                    'boundary': ['Boundary vertical', 'Boundary', 'Adjacent to boundary'],
                    'window-vent-vertical': ['To window/door/vent vertically', 'To opening (window/vent) horizontally', 'Openings'],
                    'pitched-roof': ['To pitched roof', 'Diagonal from pitched roof'],
                    'velux-below': ['To Velux below'],
                    'velux-above-sides': ['To Velux above/sides'],
                    'skylight': ['To skylight/opening vertically', 'To skylight other vertical flue'],
                    'combustible-material': ['To combustible material'],
                    'vertical-terminal': ['Between vertical terminals', 'Separation vertical ‚Üî horizontal', 'To skylight other vertical flue']
                };
            } else {
                // Horizontal flue obstacle mappings
                mapping = {
                    window: obstacle.windowType === 'fixed' ?
                        ['Change of fabric', 'Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'] :
                        ['Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'],
                    door: ['Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'],
                    vent: ['Opening (window/door/vent) below/side/above', 'Window/door/vent (side/above/below)', 'Window/door'],
                    corner: ['Internal/external corner', 'Corner', 'Outside corner'],
                    soffit: ['Below eaves/gutters/pipes', 'Eaves/gutters', 'Eaves/gutter'],
                    downpipe: ['Drainpipes/soil pipes', 'Below eaves/gutters/pipes']
                };
            }

            const positions = mapping[objectType];
            if (!positions) return null;

            // Try to find matching clearance from CSV
            for (const pos of positions) {
                if (flueClearances[pos]) {
                    return flueClearances[pos].clearanceMM;
                }
            }

            // Check if "Outside corner" rule exists (260mm) for horizontal flues
            if (objectType === 'corner' && flueClearances['Outside corner']) {
                return flueClearances['Outside corner'].clearanceMM;
            }

            return null;
        }

        function togglePlumeKitMode() {
            state.plumeKitMode = document.getElementById('plumeKitToggle').checked;
            // Redraw clearance zones with updated mode
            if (state.zones) {
                drawClearanceZones();
                checkCompliance();
            }
        }

        function checkCompliance() {
            if (!state.position || !state.zones) return;

            let hasConflict = false;

            // Check if position is inside any prohibited zone
            const pointObstacles = ['corner', 'downpipe', 'boundary', 'vertical-terminal'];
            for (const zone of state.zones.prohibited) {
                if (pointObstacles.includes(zone.objectType)) {
                    // Check circular zone
                    const centerX = zone.x + zone.width / 2;
                    const centerY = zone.y + zone.height / 2;
                    let radius = zone.width / 2;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        radius = radius * 0.5;
                    }

                    const distance = Math.sqrt(
                        Math.pow(state.position.x - centerX, 2) +
                        Math.pow(state.position.y - centerY, 2)
                    );
                    if (distance < radius) {
                        hasConflict = true;
                        break;
                    }
                } else {
                    // Check rectangular zone
                    let zoneX = zone.x;
                    let zoneY = zone.y;
                    let zoneWidth = zone.width;
                    let zoneHeight = zone.height;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        zoneWidth = zone.width * 0.5;
                        zoneHeight = zone.height * 0.5;
                        zoneX = zone.x + (zone.width - zoneWidth) / 2;
                        zoneY = zone.y + (zone.height - zoneHeight) / 2;
                    }

                    if (state.position.x >= zoneX &&
                        state.position.x <= zoneX + zoneWidth &&
                        state.position.y >= zoneY &&
                        state.position.y <= zoneY + zoneHeight) {
                        hasConflict = true;
                        break;
                    }
                }
            }

            const resultDiv = document.getElementById('complianceResult');
            if (hasConflict) {
                resultDiv.className = 'compliance-fail';
                resultDiv.innerHTML = '‚ùå FAIL - Position conflicts with clearance zones!<br><br>The flue/boiler position violates minimum clearance requirements.';
            } else {
                resultDiv.className = 'compliance-pass';
                resultDiv.innerHTML = '‚úÖ PASS - Position complies with clearance requirements!<br><br>The flue/boiler can be safely installed at this location.';
            }
        }

        function drawCircularClearance(x, y, radiusPx, color, dashPattern) {
            state.ctx.fillStyle = color;
            state.ctx.strokeStyle = color.replace('0.3', '0.8'); // More opaque stroke
            state.ctx.lineWidth = 3;
            if (dashPattern) state.ctx.setLineDash(dashPattern);

            state.ctx.beginPath();
            state.ctx.arc(x, y, radiusPx, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            if (dashPattern) state.ctx.setLineDash([]);
        }

        // Helper function to draw rounded rectangle
        function drawRoundedRect(ctx, x, y, width, height, radius, fill = false, stroke = true) {
            // Draw clearance zone with straight lines offset from rectangle and arcs at corners
            // The rectangle passed in already has the clearance offset applied
            // We need to draw straight lines for most of each side, with arcs at the corners

            ctx.beginPath();

            // Top side: start after left arc, draw to before right arc
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);

            // Top-right arc (90 degrees, clockwise from top to right)
            ctx.arc(x + width - radius, y + radius, radius, -Math.PI/2, 0);

            // Right side: draw from after top arc to before bottom arc
            ctx.lineTo(x + width, y + height - radius);

            // Bottom-right arc (90 degrees, clockwise from right to bottom)
            ctx.arc(x + width - radius, y + height - radius, radius, 0, Math.PI/2);

            // Bottom side: draw from after right arc to before left arc
            ctx.lineTo(x + radius, y + height);

            // Bottom-left arc (90 degrees, clockwise from bottom to left)
            ctx.arc(x + radius, y + height - radius, radius, Math.PI/2, Math.PI);

            // Left side: draw from after bottom arc to before top arc
            ctx.lineTo(x, y + radius);

            // Top-left arc (90 degrees, clockwise from left to top)
            ctx.arc(x + radius, y + radius, radius, Math.PI, Math.PI*3/2);

            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }

        function drawClearanceZones() {
            // Redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);

            // Apply zoom and pan transformation
            state.ctx.save();
            const rect = state.canvas.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            state.ctx.translate(state.panX / state.canvasScale, state.panY / state.canvasScale);
            state.ctx.scale(state.zoomLevel, state.zoomLevel);
            state.ctx.translate((centerX - centerX * state.zoomLevel) / state.canvasScale, (centerY - centerY * state.zoomLevel) / state.canvasScale);

            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            if (!state.zones) {
                state.ctx.restore();
                return;
            }

            // Draw obstacles first
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 3;

                // Draw window as polygon if it has 4 points
                if (obs.type === 'window' && obs.points && obs.points.length === 4) {
                    state.ctx.beginPath();
                    state.ctx.moveTo(obs.points[0].x, obs.points[0].y);
                    for (let i = 1; i < obs.points.length; i++) {
                        state.ctx.lineTo(obs.points[i].x, obs.points[i].y);
                    }
                    state.ctx.closePath();
                    state.ctx.stroke();
                } else {
                    state.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
                }

                // Label the object
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 16px Arial';
                const displayType = obs.type === 'window' ? `${obs.windowType || ''} window`.trim() : obs.type;
                state.ctx.fillText(`${index + 1}: ${displayType}`, obs.x + 5, obs.y + 22);
            });
            
            const prohibitedFill = 'rgba(245, 101, 101, 0.3)';
            const prohibitedStroke = '#f56565';
            const prohibitedDash = [10, 5];

            const applyProhibitedStyles = () => {
                state.ctx.fillStyle = prohibitedFill;
                state.ctx.strokeStyle = prohibitedStroke;
                state.ctx.lineWidth = 3;
                state.ctx.setLineDash(prohibitedDash);
            };

            // Draw prohibited zones (red)
            applyProhibitedStyles();
            state.zones.prohibited.forEach(zone => {
                if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                    const centerX = zone.x + zone.width / 2;
                    const centerY = zone.y + zone.height / 2;
                    let radiusPx = Math.min(zone.width, zone.height) / 2;

                    if (state.pxPerMM && zone.reason) {
                        const match = zone.reason.match(/([\d.]+)\s*mm/i);
                        if (match) {
                            radiusPx = parseFloat(match[1]) * state.pxPerMM;
                        }
                    }

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        radiusPx = radiusPx * 0.5;
                    }

                    drawCircularClearance(centerX, centerY, radiusPx, prohibitedFill, prohibitedDash);
                    applyProhibitedStyles();
                } else {
                    // Use rounded rectangles for clearance zones (300mm corner radius)
                    const cornerRadius = state.pxPerMM ? 300 * state.pxPerMM : 15;

                    // Apply 50% reduction for plume kit mode
                    if (state.plumeKitMode) {
                        const reducedWidth = zone.width * 0.5;
                        const reducedHeight = zone.height * 0.5;
                        const offsetX = (zone.width - reducedWidth) / 2;
                        const offsetY = (zone.height - reducedHeight) / 2;
                        drawRoundedRect(state.ctx, zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight, cornerRadius, true, true);
                    } else {
                        drawRoundedRect(state.ctx, zone.x, zone.y, zone.width, zone.height, cornerRadius, true, true);
                    }
                }
            });

            state.ctx.setLineDash([]);
            
            // Draw restricted zones (blue)
            state.ctx.fillStyle = 'rgba(66, 153, 225, 0.2)';
            state.ctx.strokeStyle = '#4299e1';
            state.ctx.lineWidth = 2;
            state.ctx.setLineDash([5, 5]);

            state.zones.restricted.forEach(zone => {
                const cornerRadius = state.pxPerMM ? 300 * state.pxPerMM : 15;

                // Apply 50% reduction for plume kit mode
                if (state.plumeKitMode) {
                    const reducedWidth = zone.width * 0.5;
                    const reducedHeight = zone.height * 0.5;
                    const offsetX = (zone.width - reducedWidth) / 2;
                    const offsetY = (zone.height - reducedHeight) / 2;
                    drawRoundedRect(state.ctx, zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight, cornerRadius, true, true);
                } else {
                    drawRoundedRect(state.ctx, zone.x, zone.y, zone.width, zone.height, cornerRadius, true, true);
                }
            });
            
            state.ctx.setLineDash([]);

            // Redraw position marker on top based on mode
            if (state.position) {
                if (state.mode === 'boiler' && state.boilerDimensions) {
                    // Draw boiler box with clearances
                    const boilerWidthPx = state.boilerDimensions.width * state.pxPerMM;
                    const boilerHeightPx = state.boilerDimensions.height * state.pxPerMM;

                    const boilerX = state.position.x - boilerWidthPx / 2;
                    const boilerY = state.position.y - boilerHeightPx / 2;

                    // Draw boiler box (green solid)
                    state.ctx.fillStyle = 'rgba(72, 187, 120, 0.3)';
                    state.ctx.fillRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    state.ctx.strokeStyle = '#48bb78';
                    state.ctx.lineWidth = 4;
                    state.ctx.strokeRect(boilerX, boilerY, boilerWidthPx, boilerHeightPx);

                    // Draw center marker
                    state.ctx.fillStyle = '#667eea';
                    state.ctx.beginPath();
                    state.ctx.arc(state.position.x, state.position.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                } else {
                    drawPositionMarker(state.position.x, state.position.y);
                }
            }
        }

        function redrawCanvas() {
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Restore context state
            state.ctx.restore();
        }

        function drawCalibrationOverlay() {
            if (state.calibrationPoints.length === 4) {
                const points = state.calibrationPoints;
                
                state.ctx.strokeStyle = '#48bb78';
                state.ctx.lineWidth = 3;
                state.ctx.beginPath();
                state.ctx.moveTo(points[0].x, points[0].y);
                state.ctx.lineTo(points[1].x, points[1].y);
                state.ctx.lineTo(points[2].x, points[2].y);
                state.ctx.lineTo(points[3].x, points[3].y);
                state.ctx.closePath();
                state.ctx.stroke();
                
                points.forEach((point, i) => {
                    state.ctx.fillStyle = '#f56565';
                    state.ctx.beginPath();
                    state.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                    
                    state.ctx.fillStyle = 'white';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.textAlign = 'center';
                    state.ctx.textBaseline = 'middle';
                    state.ctx.fillText(i + 1, point.x, point.y);
                });
            }
        }

        function resetCalibration() {
            state.calibrationPoints = [];
            state.isCalibrating = false;
            state.pxPerMM = null;
            state.position = null;
            state.mode = null;
            state.obstacles = [];
            state.markingMode = null;
            state.markingPoints = [];
            state.zones = null;
            state.plumeKitMode = false;
            document.getElementById('plumeKitToggle').checked = false;

            if (state.photo) {
                state.ctx.drawImage(state.photo, 0, 0);
            }

            updatePointsDisplay();

            document.getElementById('tapStatus').classList.remove('active');
            document.getElementById('tapStatus').classList.remove('warning');
            document.getElementById('tapStatus').textContent = 'Choose calibration method below';
            document.getElementById('calibrationInfo').classList.remove('active');
            document.getElementById('pointsDisplay').style.display = 'none';
            document.getElementById('analysisCard').style.display = 'none';
            document.getElementById('positionInstructions').style.display = 'none';
            document.getElementById('obstacleMarkingSection').style.display = 'none';
            document.getElementById('resultsPanel').classList.remove('active');

            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleMarkingClick);
        }

        function updatePointsDisplay() {
            document.getElementById('pointCount').textContent = state.calibrationPoints.length;
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        function testClick() {
            alert('Button works! Mode: ' + state.mode + ', Canvas: ' + !!state.canvas);

            console.log('=== TEST CLICK DEBUG ===');
            console.log('State mode:', state.mode);
            console.log('Canvas exists:', !!state.canvas);
            console.log('Canvas:', state.canvas);

            if (!state.canvas) {
                alert('ERROR: Canvas is null!');
                return;
            }

            // Try adding listener directly
            state.canvas.onclick = function(e) {
                alert('Canvas clicked!');
                const rect = state.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * state.canvasScale;
                const y = (e.clientY - rect.top) * state.canvasScale;
                alert('Position: ' + Math.round(x) + ', ' + Math.round(y));
            };

            alert('Direct onclick handler added! Try clicking the canvas now.');
        }

        // Flue Output Generation Functions
        function generateStandardFlueOutput() {
            const canvas = document.getElementById('standardFlueCanvas');
            canvas.width = state.canvas.width;
            canvas.height = state.canvas.height;
            const ctx = canvas.getContext('2d');

            // Draw base image
            ctx.drawImage(state.photo, 0, 0);

            // Draw calibration overlay
            drawCalibrationOverlayOnCanvas(ctx);

            // Draw obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                ctx.fillStyle = color;
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`${index + 1}: ${obs.type}`, obs.x + 5, obs.y + 22);
            });

            // Draw prohibited zones (RED)
            ctx.fillStyle = 'rgba(245, 101, 101, 0.4)';
            ctx.strokeStyle = '#f56565';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);

            if (state.zones && state.zones.prohibited) {
                state.zones.prohibited.forEach(zone => {
                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = zone.width / 2;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
                    }
                });
            }

            ctx.setLineDash([]);

            // Draw acceptable zones (GREEN) - areas outside prohibited zones
            ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Re-draw prohibited zones to overlap green
            ctx.fillStyle = 'rgba(245, 101, 101, 0.4)';
            ctx.strokeStyle = '#f56565';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);

            if (state.zones && state.zones.prohibited) {
                state.zones.prohibited.forEach(zone => {
                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = zone.width / 2;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
                    }
                });
            }

            ctx.setLineDash([]);

            // Draw flue position marker
            if (state.position) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(state.position.x, state.position.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Add legend
            drawLegendOnCanvas(ctx, canvas.width, canvas.height, 'Standard Flue');

            document.getElementById('outputImagesSection').style.display = 'block';
        }

        function generatePlumeManagementOutput() {
            const canvas = document.getElementById('plumeCanvas');
            canvas.width = state.canvas.width;
            canvas.height = state.canvas.height;
            const ctx = canvas.getContext('2d');

            // Draw base image
            ctx.drawImage(state.photo, 0, 0);

            // Draw calibration overlay
            drawCalibrationOverlayOnCanvas(ctx);

            // Draw obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                ctx.fillStyle = color;
                ctx.font = 'bold 16px Arial';
                ctx.fillText(`${index + 1}: ${obs.type}`, obs.x + 5, obs.y + 22);
            });

            // For plume management, reduce clearances by 50% (plume kits reduce clearance requirements)
            ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
            ctx.strokeStyle = '#f56565';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);

            if (state.zones && state.zones.prohibited) {
                state.zones.prohibited.forEach(zone => {
                    // Reduce zone size by 50% for plume management
                    const reducedWidth = zone.width * 0.5;
                    const reducedHeight = zone.height * 0.5;
                    const offsetX = (zone.width - reducedWidth) / 2;
                    const offsetY = (zone.height - reducedHeight) / 2;

                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = (zone.width / 2) * 0.5;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        ctx.fillRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                        ctx.strokeRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                    }
                });
            }

            ctx.setLineDash([]);

            // Draw acceptable zones (GREEN)
            ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Re-draw reduced prohibited zones
            ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
            ctx.strokeStyle = '#f56565';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);

            if (state.zones && state.zones.prohibited) {
                state.zones.prohibited.forEach(zone => {
                    const reducedWidth = zone.width * 0.5;
                    const reducedHeight = zone.height * 0.5;
                    const offsetX = (zone.width - reducedWidth) / 2;
                    const offsetY = (zone.height - reducedHeight) / 2;

                    if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                        const centerX = zone.x + zone.width / 2;
                        const centerY = zone.y + zone.height / 2;
                        const radiusPx = (zone.width / 2) * 0.5;

                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radiusPx, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        ctx.fillRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                        ctx.strokeRect(zone.x + offsetX, zone.y + offsetY, reducedWidth, reducedHeight);
                    }
                });
            }

            ctx.setLineDash([]);

            // Draw flue position marker
            if (state.position) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(state.position.x, state.position.y, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            // Add legend
            drawLegendOnCanvas(ctx, canvas.width, canvas.height, 'Plume Management');

            document.getElementById('outputImagesSection').style.display = 'block';
        }

        function drawCalibrationOverlayOnCanvas(ctx) {
            if (state.calibrationPoints.length === 4) {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                state.calibrationPoints.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function drawLegendOnCanvas(ctx, width, height, title) {
            const legendX = width - 250;
            const legendY = 20;

            // Background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(legendX, legendY, 230, 120);
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX, legendY, 230, 120);

            // Title
            ctx.fillStyle = '#667eea';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(title, legendX + 10, legendY + 25);

            // Legend items
            ctx.font = '14px Arial';

            // Red box
            ctx.fillStyle = 'rgba(245, 101, 101, 0.4)';
            ctx.fillRect(legendX + 10, legendY + 40, 30, 20);
            ctx.strokeStyle = '#f56565';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX + 10, legendY + 40, 30, 20);
            ctx.fillStyle = '#333';
            ctx.fillText('Prohibited Zone', legendX + 50, legendY + 55);

            // Green box
            ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            ctx.fillRect(legendX + 10, legendY + 70, 30, 20);
            ctx.strokeStyle = '#48bb78';
            ctx.lineWidth = 2;
            ctx.strokeRect(legendX + 10, legendY + 70, 30, 20);
            ctx.fillStyle = '#333';
            ctx.fillText('Acceptable Zone', legendX + 50, legendY + 85);

            // Flue marker
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(legendX + 25, legendY + 108, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#333';
            ctx.fillText('Flue Terminal', legendX + 50, legendY + 113);
        }

        function downloadCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function downloadCurrentCanvas(filename) {
            if (!state.canvas) {
                console.error('No canvas available to download');
                return;
            }

            const link = document.createElement('a');
            link.download = filename;
            link.href = state.canvas.toDataURL('image/png');
            link.click();
        }

        async function generateWrittenGuidance() {
            const section = document.getElementById('writtenGuidanceSection');
            const content = document.getElementById('writtenGuidanceContent');

            content.textContent = 'Generating guidance...';
            section.style.display = 'block';

            try {
                // Prepare data for OpenAI
                const prompt = `Generate professional installation guidance for a flue terminal installation with the following details:

Boiler: ${state.flueBrand || 'Unknown'} ${state.flueModel || 'Unknown'}

Marked Obstacles:
${state.obstacles.map((obs, i) => `${i + 1}. ${obs.type} at position (${Math.round(obs.x)}, ${Math.round(obs.y)})`).join('\n')}

Clearance Requirements:
${state.flueClearances ? Object.entries(state.flueClearances).map(([pos, data]) =>
    `- ${pos}: ${data.clearanceMM}mm${data.specialRules ? ' (' + data.specialRules + ')' : ''}`
).join('\n') : 'Not specified'}

Flue Terminal Position: (${Math.round(state.position.x)}, ${Math.round(state.position.y)})

Scale: ${state.pxPerMM ? state.pxPerMM.toFixed(2) : 'Unknown'} pixels/mm

Please provide:
1. A summary of the installation requirements
2. Key clearance distances that must be maintained
3. Any special considerations or rules
4. Compliance status (whether the marked position meets requirements)
5. Recommendations for the installer

Format the response in clear, professional language suitable for a gas engineer.`;

                // Call OpenAI API
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + (localStorage.getItem('openai_api_key') || prompt('Please enter your OpenAI API key:'))
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: [{
                            role: 'user',
                            content: prompt
                        }],
                        temperature: 0.7,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) {
                    throw new Error('API request failed: ' + response.statusText);
                }

                const data = await response.json();
                const guidance = data.choices[0].message.content;

                content.textContent = guidance;

                // Save API key for future use
                if (localStorage.getItem('openai_api_key') === null) {
                    const key = prompt('Save this API key for future use?');
                    if (key) {
                        localStorage.setItem('openai_api_key', key);
                    }
                }

            } catch (error) {
                console.error('Error generating guidance:', error);
                content.textContent = `Error generating guidance: ${error.message}\n\nPlease check your API key and try again.`;
            }
        }

        async function detectObjectsWithGemini() {
            const status = document.getElementById('positionStatus');
            status.textContent = 'üîç Detecting objects with AI...';

            try {
                // Call the Cloudflare Worker (which calls Gemini)
                const response = await fetch('https://clearancegenie.martinbibb.workers.dev', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image: state.photoBase64,
                        pxPerMM: state.pxPerMM,
                        mode: 'flue',
                        position: state.position,
                        imageWidth: state.canvas.width,
                        imageHeight: state.canvas.height
                    })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.statusText}`);
                }

                const result = await response.json();

                if (!result.success || !result.detections) {
                    throw new Error('Invalid API response');
                }

                state.detectedObjects = result.detections;
                state.zones = result.zones;

                // Draw detected objects
                drawDetectedObjects();

                // Show object key
                showObjectKey();

                status.textContent = `‚úÖ Detected ${result.detections.length} objects!`;

                // Show results panel
                document.getElementById('resultsPanel').classList.add('active');

            } catch (error) {
                console.error('Detection error:', error);
                status.textContent = '‚ùå Object detection failed. Please try manual marking.';
                status.classList.add('warning');

                // Fall back to manual marking
                document.getElementById('obstacleMarkingSection').style.display = 'block';
            }
        }

        function drawDetectedObjects() {
            // Clear and redraw
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw position marker
            drawPositionMarker(state.position.x, state.position.y);

            // Draw detected objects with different colors
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800', '#0088ff'];

            state.detectedObjects.forEach((obj, index) => {
                const color = colors[index % colors.length];

                // Draw bounding box
                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 4;
                state.ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);

                // Draw label
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 20px Arial';
                const label = obj.label || obj.type;
                state.ctx.fillText(`${index + 1}: ${label}`, obj.x + 5, obj.y + 25);
            });

            // Draw clearance zones if available
            if (state.zones) {
                drawClearanceZones();
            }
        }

        function showObjectKey() {
            const keyDiv = document.getElementById('objectKey');
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800', '#0088ff'];

            let keyHTML = '<h4 style="color: #667eea; margin-bottom: 15px;">Detected Objects Key:</h4>';

            state.detectedObjects.forEach((obj, index) => {
                const color = colors[index % colors.length];
                const label = obj.label || obj.type;

                keyHTML += `
                    <div class="detection-item" style="border-left-color: ${color};">
                        <strong style="color: ${color};">${index + 1}. ${label}</strong><br>
                        Type: ${obj.type}<br>
                        Position: (${Math.round(obj.x)}, ${Math.round(obj.y)})<br>
                        Size: ${Math.round(obj.width)}√ó${Math.round(obj.height)}px
                    </div>
                `;
            });

            keyDiv.innerHTML = keyHTML;
            keyDiv.style.display = 'block';
        }
    </script>

</body>
</html>
