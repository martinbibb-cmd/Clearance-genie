<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
        }

        input[type="file"] {
            display: none;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            background: #f7fafc;
            display: none;
        }

        .canvas-container.active {
            display: block;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: crosshair;
        }

        .instructions {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .calibration-points {
            background: #fff5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f56565;
        }

        .calibration-points p {
            margin: 5px 0;
            font-weight: 600;
        }

        .status {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.warning {
            background: #feebc8;
            color: #7c2d12;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
        }

        .calibration-info {
            background: #e6fffa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #38b2ac;
            display: none;
        }

        .calibration-info.active {
            display: block;
        }

        .calibration-info h4 {
            color: #38b2ac;
            margin-bottom: 10px;
        }

        .calibration-info p {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-panel {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
        }

        .results-panel.active {
            display: block;
        }

        .results-panel h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .detection-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
        }

        .detection-item strong {
            color: #667eea;
        }

        .zone-legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .zone-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zone-color-box {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #333;
        }

        .zone-red {
            background: rgba(245, 101, 101, 0.5);
        }

        .zone-green {
            background: rgba(72, 187, 120, 0.5);
        }

        .zone-blue {
            background: rgba(66, 153, 225, 0.5);
        }

        .obstacle-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
            border-left: 3px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .obstacle-item strong {
            color: #667eea;
        }

        .obstacle-delete-btn {
            background: #f56565;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .obstacle-delete-btn:hover {
            background: #e53e3e;
        }

        .compliance-pass {
            background: #c6f6d5;
            color: #22543d;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 18px;
            text-align: center;
        }

        .compliance-fail {
            background: #fed7d7;
            color: #742a2a;
            padding: 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 18px;
            text-align: center;
        }
    </style>

</head>
<body>
    <div class="container">
        <h1>üî• Clearance Genie</h1>

        <div class="card">
            <h2>Step 1: Load Photo</h2>
            <p style="margin: 10px 0; color: #666;">Take or upload a photo with your blue calibration card visible</p>
            
            <input type="file" id="photoInput" accept="image/*">
            <div class="button-group">
                <button class="btn" onclick="document.getElementById('photoInput').click()">
                    üìÅ Choose Photo
                </button>
                <button class="btn" onclick="openCamera()">
                    üì∑ Take Photo
                </button>
            </div>

            <div class="instructions">
                <h3>üìã How to take the photo:</h3>
                <ol>
                    <li>Place your blue calibration card on the wall at the proposed flue/boiler height</li>
                    <li>Stand back and take a clear photo that includes the card and surrounding area</li>
                    <li>Make sure the card is visible and not blurry</li>
                    <li>Include any windows, vents, corners, or obstacles in the frame</li>
                </ol>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="photoCanvas"></canvas>
        </div>

        <div class="card" id="calibrationCard" style="display: none;">
            <h2>Step 2: Calibrate Scale</h2>
            
            <div class="status" id="tapStatus">
                Choose calibration method below
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="autoDetectCard()">
                    ü§ñ Auto-Detect Card
                </button>
                <button class="btn" onclick="startManualCalibration()">
                    üëÜ Manual 4-Point
                </button>
            </div>

            <div class="calibration-points" id="pointsDisplay" style="display: none;">
                <p>Points tapped: <span id="pointCount">0</span>/4</p>
                <button class="btn btn-danger" onclick="resetCalibration()" style="margin-top: 10px;">
                    ‚Ü∫ Reset Points
                </button>
            </div>

            <div class="calibration-info" id="calibrationInfo">
                <h4>‚úÖ Calibration Complete!</h4>
                <p>Scale: <span id="scaleDisplay">-</span> pixels/mm</p>
                <p>Card Width: <span id="cardWidthDisplay">-</span> pixels (should be ~85.6mm)</p>
                <p>Card Height: <span id="cardHeightDisplay">-</span> pixels (should be ~53.98mm)</p>
                <p>Accuracy: <span id="accuracyDisplay">-</span></p>
                <button class="btn" onclick="resetCalibration()" style="margin-top: 10px;">
                    üîÑ Recalibrate
                </button>
            </div>
        </div>

        <div class="card" id="analysisCard" style="display: none;">
            <h2>Step 3: Choose Analysis Type</h2>
            
            <div class="instructions">
                <h3>What do you want to check?</h3>
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="startFlueMode()">
                    üî• Flue Clearances
                </button>
                <button class="btn btn-secondary" onclick="startBoilerMode()">
                    üîß Boiler Clearances
                </button>
            </div>

            <div id="positionInstructions" style="display: none;">
                <div class="status active" id="positionStatus">
                    üëÜ Tap on the image to mark the position
                </div>

                <label style="display: block; margin: 15px 0;">
                    <strong>Brand:</strong>
                    <select id="brandSelect" style="width: 100%; padding: 10px; border-radius: 5px; margin-top: 5px;">
                        <option value="worcester">Worcester Bosch</option>
                        <option value="vaillant">Vaillant</option>
                        <option value="ideal">Ideal</option>
                    </select>
                </label>
            </div>

            <div id="obstacleMarkingSection" style="display: none;">
                <div class="instructions">
                    <h3>Step 4: Mark Obstacles</h3>
                    <p>Click a button below, then tap on the image to mark obstacles:</p>
                </div>

                <div class="status" id="markingStatus">
                    Select an obstacle type below to start marking
                </div>

                <div class="button-group">
                    <button class="btn btn-secondary" onclick="startMarkingObstacle('window')">
                        ü™ü Add Window
                    </button>
                    <button class="btn btn-secondary" onclick="startMarkingObstacle('vent')">
                        üåÄ Add Vent
                    </button>
                    <button class="btn btn-secondary" onclick="startMarkingObstacle('corner')">
                        üìê Add Corner
                    </button>
                    <button class="btn btn-secondary" onclick="startMarkingObstacle('soffit')">
                        üè† Add Soffit/Eaves
                    </button>
                    <button class="btn btn-secondary" onclick="startMarkingObstacle('downpipe')">
                        üíß Add Downpipe
                    </button>
                    <button class="btn btn-danger" onclick="cancelMarking()">
                        ‚ùå Cancel Marking
                    </button>
                </div>

                <div id="obstaclesList" style="display: none;">
                    <h4 style="margin-top: 20px; color: #667eea;">Marked Obstacles:</h4>
                    <div id="obstaclesListContent"></div>
                </div>

                <button class="btn" id="calculateBtn" onclick="calculateClearances()" style="margin-top: 20px; display: none;">
                    üîç Calculate Clearance Zones
                </button>
            </div>

            <div class="status" id="analysisStatus"></div>

            <div class="results-panel" id="resultsPanel">
                <div class="zone-legend">
                    <div class="zone-legend-item">
                        <div class="zone-color-box zone-red"></div>
                        <span>Prohibited Zone</span>
                    </div>
                    <div class="zone-legend-item">
                        <div class="zone-color-box zone-green"></div>
                        <span>Safe Zone</span>
                    </div>
                </div>
                <div id="complianceResult" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CARD_WIDTH_MM = 85.6;
        const CARD_HEIGHT_MM = 53.98;

        // Brand-specific clearance rules (in mm from obstruction edge to flue/boiler center)
        const CLEARANCE_RULES = {
            worcester: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                }
            },
            vaillant: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                }
            },
            ideal: {
                flue: {
                    window: 300,
                    door: 300,
                    corner: 300,
                    soffit: 300,
                    vent: 300,
                    boundary: 600,
                    ground: 2000,
                    downpipe: 75
                },
                boiler: {
                    wall_side: 50,
                    wall_front: 300,
                    ceiling: 50,
                    floor: 500
                }
            }
        };

        // Core state
        const state = {
            photo: null,
            photoBase64: null,
            canvas: null,
            ctx: null,
            calibrationPoints: [],
            isCalibrating: false,
            pxPerMM: null,
            position: null,
            canvasScale: 1,
            mode: null,
            obstacles: [], // Manual obstacles marked by user
            markingMode: null, // Current obstacle type being marked
            markingPoints: [], // Points collected during marking
            zones: null
        };

        // Initialize
        document.getElementById('photoInput').addEventListener('change', handlePhotoUpload);

        function openCamera() {
            const input = document.getElementById('photoInput');
            input.setAttribute('capture', 'environment');
            input.click();
            setTimeout(() => input.removeAttribute('capture'), 100);
        }

        function handlePhotoUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                state.photoBase64 = event.target.result;
                const img = new Image();
                img.onload = function() {
                    setupCanvas(img);
                    document.getElementById('canvasContainer').classList.add('active');
                    document.getElementById('calibrationCard').style.display = 'block';
                };
                img.src = event.target.result;
                state.photo = img;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            const canvas = document.getElementById('photoCanvas');
            
            canvas.width = img.width;
            canvas.height = img.height;
            
            state.canvas = canvas;
            state.ctx = canvas.getContext('2d');
            
            state.ctx.drawImage(img, 0, 0);
            
            const rect = canvas.getBoundingClientRect();
            state.canvasScale = canvas.width / rect.width;
        }

        function startManualCalibration() {
            state.isCalibrating = true;
            state.calibrationPoints = [];
            updatePointsDisplay();
            
            document.getElementById('pointsDisplay').style.display = 'block';
            
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.classList.remove('warning');
            status.textContent = 'Tap corner 1/4: Top-Left corner of card';
            
            state.canvas.addEventListener('click', handleCalibrationClick);
        }

        function autoDetectCard() {
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.textContent = 'üîç Searching for blue card...';
            
            const imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            const data = imageData.data;
            
            const bluePixels = [];
            
            for (let y = 0; y < state.canvas.height; y += 2) {
                for (let x = 0; x < state.canvas.width; x += 2) {
                    const i = (y * state.canvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (b > r + 30 && b > g + 30 && b > 100) {
                        bluePixels.push({x, y});
                    }
                }
            }
            
            if (bluePixels.length < 100) {
                status.classList.add('warning');
                status.textContent = '‚ùå Could not find blue card. Try manual calibration or adjust lighting.';
                return;
            }
            
            const minX = Math.min(...bluePixels.map(p => p.x));
            const maxX = Math.max(...bluePixels.map(p => p.x));
            const minY = Math.min(...bluePixels.map(p => p.y));
            const maxY = Math.max(...bluePixels.map(p => p.y));
            
            const width = maxX - minX;
            const height = maxY - minY;
            const aspectRatio = width / height;
            const expectedRatio = CARD_WIDTH_MM / CARD_HEIGHT_MM;
            
            if (Math.abs(aspectRatio - expectedRatio) > 0.3) {
                status.classList.add('warning');
                status.textContent = `‚ö†Ô∏è Found blue region but shape doesn't match card (ratio: ${aspectRatio.toFixed(2)}). Try manual calibration.`;
                
                state.ctx.strokeStyle = '#f56565';
                state.ctx.lineWidth = 3;
                state.ctx.strokeRect(minX, minY, width, height);
                return;
            }
            
            state.calibrationPoints = [
                {x: minX, y: minY},
                {x: maxX, y: minY},
                {x: maxX, y: maxY},
                {x: minX, y: maxY}
            ];
            
            status.textContent = '‚úÖ Card detected! Calculating scale...';
            
            setTimeout(() => calculateCalibration(), 500);
        }

        function handleCalibrationClick(e) {
            if (!state.isCalibrating) return;
            
            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;
            
            state.calibrationPoints.push({x, y});
            
            state.ctx.fillStyle = '#f56565';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();
            
            state.ctx.fillStyle = 'white';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.textAlign = 'center';
            state.ctx.textBaseline = 'middle';
            state.ctx.fillText(state.calibrationPoints.length, x, y);
            
            updatePointsDisplay();
            
            const status = document.getElementById('tapStatus');
            const corners = ['Top-Left', 'Top-Right', 'Bottom-Right', 'Bottom-Left'];
            
            if (state.calibrationPoints.length < 4) {
                status.textContent = `Tap corner ${state.calibrationPoints.length + 1}/4: ${corners[state.calibrationPoints.length]} corner of card`;
            } else {
                calculateCalibration();
            }
        }

        function calculateCalibration() {
            const points = state.calibrationPoints;
            
            const topWidth = distance(points[0], points[1]);
            const bottomWidth = distance(points[3], points[2]);
            const leftHeight = distance(points[0], points[3]);
            const rightHeight = distance(points[1], points[2]);
            
            const avgWidthPx = (topWidth + bottomWidth) / 2;
            const avgHeightPx = (leftHeight + rightHeight) / 2;
            
            const pxPerMMWidth = avgWidthPx / CARD_WIDTH_MM;
            const pxPerMMHeight = avgHeightPx / CARD_HEIGHT_MM;
            
            state.pxPerMM = (pxPerMMWidth + pxPerMMHeight) / 2;
            
            const skew = Math.abs(pxPerMMWidth - pxPerMMHeight) / state.pxPerMM * 100;
            let accuracyRating = '';
            
            if (skew < 5) {
                accuracyRating = '‚úÖ Excellent (< 5% skew)';
            } else if (skew < 10) {
                accuracyRating = '‚ö†Ô∏è Good (< 10% skew)';
            } else {
                accuracyRating = '‚ùå Poor - Consider retaking photo more straight-on';
            }
            
            state.ctx.strokeStyle = skew < 10 ? '#48bb78' : '#f56565';
            state.ctx.lineWidth = 4;
            state.ctx.beginPath();
            state.ctx.moveTo(points[0].x, points[0].y);
            state.ctx.lineTo(points[1].x, points[1].y);
            state.ctx.lineTo(points[2].x, points[2].y);
            state.ctx.lineTo(points[3].x, points[3].y);
            state.ctx.closePath();
            state.ctx.stroke();
            
            points.forEach((point, i) => {
                state.ctx.fillStyle = skew < 10 ? '#48bb78' : '#f56565';
                state.ctx.beginPath();
                state.ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                state.ctx.fill();
                
                state.ctx.fillStyle = 'white';
                state.ctx.font = 'bold 14px Arial';
                state.ctx.textAlign = 'center';
                state.ctx.textBaseline = 'middle';
                state.ctx.fillText(i + 1, point.x, point.y);
            });
            
            state.isCalibrating = false;
            state.canvas.removeEventListener('click', handleCalibrationClick);
            
            const status = document.getElementById('tapStatus');
            status.classList.remove('active');
            
            const info = document.getElementById('calibrationInfo');
            info.classList.add('active');
            document.getElementById('scaleDisplay').textContent = state.pxPerMM.toFixed(2);
            document.getElementById('cardWidthDisplay').textContent = avgWidthPx.toFixed(1);
            document.getElementById('cardHeightDisplay').textContent = avgHeightPx.toFixed(1);
            document.getElementById('accuracyDisplay').textContent = accuracyRating;

            document.getElementById('analysisCard').style.display = 'block';

            // FIX: Clone canvas to remove ALL event listeners
            const oldCanvas = state.canvas;
            const newCanvas = oldCanvas.cloneNode(false);
            oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);

            // Update state references
            state.canvas = newCanvas;
            state.ctx = newCanvas.getContext('2d');

            // Redraw photo and calibration overlay
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Recalculate canvas scale
            const rect = newCanvas.getBoundingClientRect();
            state.canvasScale = newCanvas.width / rect.width;
        }

        function startFlueMode() {
            console.log('startFlueMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'flue';
            state.position = null; // Clear any previous position
            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üî• Tap where you want the flue terminal';
            document.getElementById('analyzeBtn').disabled = true;

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);

            // Add fresh listener
            state.canvas.addEventListener('click', handlePositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Flue mode started - canvas ready for position click');
        }

        function startBoilerMode() {
            console.log('startBoilerMode() called');

            // Check if canvas exists
            if (!state.canvas) {
                console.error('Canvas not available');
                return;
            }

            state.mode = 'boiler';
            state.position = null; // Clear any previous position
            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üîß Tap where the boiler will be located';
            document.getElementById('analyzeBtn').disabled = true;

            // Remove ALL existing listeners first (cleanup)
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleCalibrationClick);

            // Add fresh listener
            state.canvas.addEventListener('click', handlePositionClick);

            // Make sure canvas is clickable
            state.canvas.style.cursor = 'crosshair';
            state.canvas.style.pointerEvents = 'auto';

            console.log('Boiler mode started - canvas ready for position click');
        }

        function handlePositionClick(e) {
            if (state.isCalibrating) return;

            console.log('Position click detected!'); // Debug

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            console.log('Clicked at:', x, y); // Debug

            state.position = {x, y};

            // Clear and redraw EVERYTHING
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw BIG obvious marker
            state.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            state.ctx.strokeStyle = '#ff0000';
            state.ctx.lineWidth = 5;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 30, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            // Draw crosshair
            state.ctx.strokeStyle = '#ff0000';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 50, y);
            state.ctx.lineTo(x + 50, y);
            state.ctx.moveTo(x, y - 50);
            state.ctx.lineTo(x, y + 50);
            state.ctx.stroke();

            console.log('Marker drawn'); // Debug

            const modeText = state.mode === 'flue' ? 'flue terminal' : 'boiler';
            document.getElementById('positionStatus').textContent = `‚úÖ ${modeText} position marked! Now mark obstacles below.`;

            // Remove position click listener
            state.canvas.removeEventListener('click', handlePositionClick);

            // Show obstacle marking section
            document.getElementById('obstacleMarkingSection').style.display = 'block';
        }

        function drawPositionMarker(x, y) {
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 20, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();
            
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 2;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 30, y);
            state.ctx.lineTo(x + 30, y);
            state.ctx.moveTo(x, y - 30);
            state.ctx.lineTo(x, y + 30);
            state.ctx.stroke();
        }

        function startMarkingObstacle(type) {
            state.markingMode = type;
            state.markingPoints = [];

            const needsPoints = (type === 'corner' || type === 'downpipe') ? 1 : 2;

            const status = document.getElementById('markingStatus');
            status.classList.add('active');
            status.textContent = `üëÜ Tap ${needsPoints === 1 ? 'location' : 'top-left corner'} of ${type}`;

            // Add marking click listener
            state.canvas.removeEventListener('click', handleMarkingClick);
            state.canvas.addEventListener('click', handleMarkingClick);
        }

        function handleMarkingClick(e) {
            if (!state.markingMode) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            state.markingPoints.push({x, y});

            const needsPoints = (state.markingMode === 'corner' || state.markingMode === 'downpipe') ? 1 : 2;

            // Draw temporary marker
            state.ctx.fillStyle = '#667eea';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            if (state.markingPoints.length < needsPoints) {
                // Need more points
                const status = document.getElementById('markingStatus');
                status.textContent = `üëÜ Tap bottom-right corner of ${state.markingMode}`;
            } else {
                // Complete the obstacle
                completeObstacleMarking();
            }
        }

        function completeObstacleMarking() {
            const type = state.markingMode;
            const points = state.markingPoints;

            let obstacle;

            if (type === 'corner' || type === 'downpipe') {
                // Point obstacle - use a small fixed size
                const pointSize = 20;
                obstacle = {
                    type: type,
                    x: points[0].x - pointSize / 2,
                    y: points[0].y - pointSize / 2,
                    width: pointSize,
                    height: pointSize
                };
            } else {
                // Rectangle obstacle
                const x1 = Math.min(points[0].x, points[1].x);
                const y1 = Math.min(points[0].y, points[1].y);
                const x2 = Math.max(points[0].x, points[1].x);
                const y2 = Math.max(points[0].y, points[1].y);

                obstacle = {
                    type: type,
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: y2 - y1
                };
            }

            state.obstacles.push(obstacle);

            // Redraw canvas with all obstacles
            redrawCanvasWithObstacles();

            // Update obstacle list
            updateObstaclesList();

            // Reset marking mode
            cancelMarking();

            // Show calculate button
            document.getElementById('calculateBtn').style.display = 'block';

            const status = document.getElementById('markingStatus');
            status.classList.add('active');
            status.textContent = `‚úÖ ${type} marked! Add more obstacles or click Calculate.`;
        }

        function cancelMarking() {
            state.markingMode = null;
            state.markingPoints = [];
            state.canvas.removeEventListener('click', handleMarkingClick);

            const status = document.getElementById('markingStatus');
            status.classList.remove('active');
            status.textContent = 'Select an obstacle type below to start marking';
        }

        function updateObstaclesList() {
            const list = document.getElementById('obstaclesListContent');
            const container = document.getElementById('obstaclesList');

            if (state.obstacles.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            list.innerHTML = state.obstacles.map((obs, index) => `
                <div class="obstacle-item">
                    <div>
                        <strong>${index + 1}. ${obs.type}</strong> -
                        Position: (${Math.round(obs.x)}, ${Math.round(obs.y)})
                        Size: ${Math.round(obs.width)}√ó${Math.round(obs.height)}px
                    </div>
                    <button class="obstacle-delete-btn" onclick="deleteObstacle(${index})">
                        Delete
                    </button>
                </div>
            `).join('');
        }

        function deleteObstacle(index) {
            state.obstacles.splice(index, 1);
            updateObstaclesList();
            redrawCanvasWithObstacles();

            if (state.obstacles.length === 0) {
                document.getElementById('calculateBtn').style.display = 'none';
            }
        }

        function redrawCanvasWithObstacles() {
            // Clear and redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            // Draw position marker
            if (state.position) {
                drawPositionMarker(state.position.x, state.position.y);
            }

            // Draw all obstacles
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];

                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 4;
                state.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                // Label
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 20px Arial';
                state.ctx.fillText(`${index + 1}: ${obs.type}`, obs.x + 5, obs.y + 25);
            });
        }

        function calculateClearances() {
            if (!state.position || !state.pxPerMM) {
                alert('Missing position or calibration data');
                return;
            }

            const brand = document.getElementById('brandSelect').value;
            const rules = CLEARANCE_RULES[brand][state.mode];

            // Calculate clearance zones for each obstacle
            state.zones = {
                prohibited: [],
                safe: []
            };

            state.obstacles.forEach(obs => {
                const clearanceMM = getClearanceForObject(obs.type, rules);
                if (clearanceMM === null) return;

                const clearancePx = clearanceMM * state.pxPerMM;

                // Calculate zone based on obstacle type
                let zoneX, zoneY, zoneMaxX, zoneMaxY;

                if (obs.type === 'corner' || obs.type === 'downpipe') {
                    // Circular zone for point obstacles
                    const centerX = obs.x + obs.width / 2;
                    const centerY = obs.y + obs.height / 2;

                    zoneX = centerX - clearancePx;
                    zoneY = centerY - clearancePx;
                    zoneMaxX = centerX + clearancePx;
                    zoneMaxY = centerY + clearancePx;
                } else {
                    // Directional zone for rectangular obstacles
                    const flueLeft = state.position.x < obs.x;
                    const flueRight = state.position.x > obs.x + obs.width;
                    const flueAbove = state.position.y < obs.y;
                    const flueBelow = state.position.y > obs.y + obs.height;

                    zoneX = flueLeft ? obs.x - clearancePx : obs.x - clearancePx * 0.3;
                    zoneY = flueAbove ? obs.y - clearancePx : obs.y - clearancePx * 0.3;
                    zoneMaxX = flueRight ? obs.x + obs.width + clearancePx : obs.x + obs.width + clearancePx * 0.3;
                    zoneMaxY = flueBelow ? obs.y + obs.height + clearancePx : obs.y + obs.height + clearancePx * 0.3;
                }

                // Clamp to image boundaries
                const clampedX = Math.max(0, zoneX);
                const clampedY = Math.max(0, zoneY);
                const clampedMaxX = Math.min(state.canvas.width, zoneMaxX);
                const clampedMaxY = Math.min(state.canvas.height, zoneMaxY);

                const finalWidth = clampedMaxX - clampedX;
                const finalHeight = clampedMaxY - clampedY;

                if (finalWidth > 0 && finalHeight > 0) {
                    state.zones.prohibited.push({
                        x: clampedX,
                        y: clampedY,
                        width: finalWidth,
                        height: finalHeight,
                        reason: `${clearanceMM}mm clearance from ${obs.type}`,
                        objectType: obs.type
                    });
                }
            });

            // Draw zones and check compliance
            drawClearanceZones();
            checkCompliance();

            // Show results panel
            document.getElementById('resultsPanel').classList.add('active');
        }

        function getClearanceForObject(objectType, rules) {
            const mapping = {
                window: "window",
                door: "door",
                corner: "corner",
                soffit: "soffit",
                vent: "vent",
                downpipe: "downpipe"
            };

            const ruleKey = mapping[objectType];
            return ruleKey ? (rules[ruleKey] ?? null) : null;
        }

        function checkCompliance() {
            if (!state.position || !state.zones) return;

            let hasConflict = false;

            // Check if position is inside any prohibited zone
            for (const zone of state.zones.prohibited) {
                if (zone.objectType === 'corner' || zone.objectType === 'downpipe') {
                    // Check circular zone
                    const centerX = zone.x + zone.width / 2;
                    const centerY = zone.y + zone.height / 2;
                    const radius = zone.width / 2;
                    const distance = Math.sqrt(
                        Math.pow(state.position.x - centerX, 2) +
                        Math.pow(state.position.y - centerY, 2)
                    );
                    if (distance < radius) {
                        hasConflict = true;
                        break;
                    }
                } else {
                    // Check rectangular zone
                    if (state.position.x >= zone.x &&
                        state.position.x <= zone.x + zone.width &&
                        state.position.y >= zone.y &&
                        state.position.y <= zone.y + zone.height) {
                        hasConflict = true;
                        break;
                    }
                }
            }

            const resultDiv = document.getElementById('complianceResult');
            if (hasConflict) {
                resultDiv.className = 'compliance-fail';
                resultDiv.innerHTML = '‚ùå FAIL - Position conflicts with clearance zones!<br><br>The flue/boiler position violates minimum clearance requirements.';
            } else {
                resultDiv.className = 'compliance-pass';
                resultDiv.innerHTML = '‚úÖ PASS - Position complies with clearance requirements!<br><br>The flue/boiler can be safely installed at this location.';
            }
        }

        function drawCircularClearance(x, y, radiusPx, color, dashPattern) {
            state.ctx.fillStyle = color;
            state.ctx.strokeStyle = color.replace('0.3', '0.8'); // More opaque stroke
            state.ctx.lineWidth = 3;
            if (dashPattern) state.ctx.setLineDash(dashPattern);

            state.ctx.beginPath();
            state.ctx.arc(x, y, radiusPx, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            if (dashPattern) state.ctx.setLineDash([]);
        }

        function drawClearanceZones() {
            // Redraw base
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();

            if (!state.zones) return;

            // Draw obstacles first
            const colors = ['#00ff00', '#ff00ff', '#00ffff', '#ffff00', '#ff8800'];
            state.obstacles.forEach((obs, index) => {
                const color = colors[index % colors.length];
                state.ctx.strokeStyle = color;
                state.ctx.lineWidth = 3;
                state.ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                // Label the object
                state.ctx.fillStyle = color;
                state.ctx.font = 'bold 16px Arial';
                state.ctx.fillText(`${index + 1}: ${obs.type}`, obs.x + 5, obs.y + 22);
            });
            
            const prohibitedFill = 'rgba(245, 101, 101, 0.3)';
            const prohibitedStroke = '#f56565';
            const prohibitedDash = [10, 5];

            const applyProhibitedStyles = () => {
                state.ctx.fillStyle = prohibitedFill;
                state.ctx.strokeStyle = prohibitedStroke;
                state.ctx.lineWidth = 3;
                state.ctx.setLineDash(prohibitedDash);
            };

            // Draw prohibited zones (red)
            applyProhibitedStyles();
            state.zones.prohibited.forEach(zone => {
                if (zone.objectType === 'corner') {
                    const centerX = zone.x + zone.width / 2;
                    const centerY = zone.y + zone.height / 2;
                    let radiusPx = Math.min(zone.width, zone.height) / 2;

                    if (state.pxPerMM && zone.reason) {
                        const match = zone.reason.match(/([\d.]+)\s*mm/i);
                        if (match) {
                            radiusPx = parseFloat(match[1]) * state.pxPerMM;
                        }
                    }

                    drawCircularClearance(centerX, centerY, radiusPx, prohibitedFill, prohibitedDash);
                    applyProhibitedStyles();
                } else {
                    state.ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                    state.ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
                }
            });

            state.ctx.setLineDash([]);
            
            // Draw restricted zones (blue)
            state.ctx.fillStyle = 'rgba(66, 153, 225, 0.2)';
            state.ctx.strokeStyle = '#4299e1';
            state.ctx.lineWidth = 2;
            state.ctx.setLineDash([5, 5]);
            
            state.zones.restricted.forEach(zone => {
                state.ctx.fillRect(zone.x, zone.y, zone.width, zone.height);
                state.ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
            });
            
            state.ctx.setLineDash([]);
            
            // Redraw position marker on top
            if (state.position) {
                drawPositionMarker(state.position.x, state.position.y);
            }
        }

        function redrawCanvas() {
            state.ctx.drawImage(state.photo, 0, 0);
            drawCalibrationOverlay();
        }

        function drawCalibrationOverlay() {
            if (state.calibrationPoints.length === 4) {
                const points = state.calibrationPoints;
                
                state.ctx.strokeStyle = '#48bb78';
                state.ctx.lineWidth = 3;
                state.ctx.beginPath();
                state.ctx.moveTo(points[0].x, points[0].y);
                state.ctx.lineTo(points[1].x, points[1].y);
                state.ctx.lineTo(points[2].x, points[2].y);
                state.ctx.lineTo(points[3].x, points[3].y);
                state.ctx.closePath();
                state.ctx.stroke();
                
                points.forEach((point, i) => {
                    state.ctx.fillStyle = '#f56565';
                    state.ctx.beginPath();
                    state.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    state.ctx.fill();
                    
                    state.ctx.fillStyle = 'white';
                    state.ctx.font = 'bold 14px Arial';
                    state.ctx.textAlign = 'center';
                    state.ctx.textBaseline = 'middle';
                    state.ctx.fillText(i + 1, point.x, point.y);
                });
            }
        }

        function resetCalibration() {
            state.calibrationPoints = [];
            state.isCalibrating = false;
            state.pxPerMM = null;
            state.position = null;
            state.mode = null;
            state.obstacles = [];
            state.markingMode = null;
            state.markingPoints = [];
            state.zones = null;

            if (state.photo) {
                state.ctx.drawImage(state.photo, 0, 0);
            }

            updatePointsDisplay();

            document.getElementById('tapStatus').classList.remove('active');
            document.getElementById('tapStatus').classList.remove('warning');
            document.getElementById('tapStatus').textContent = 'Choose calibration method below';
            document.getElementById('calibrationInfo').classList.remove('active');
            document.getElementById('pointsDisplay').style.display = 'none';
            document.getElementById('analysisCard').style.display = 'none';
            document.getElementById('positionInstructions').style.display = 'none';
            document.getElementById('obstacleMarkingSection').style.display = 'none';
            document.getElementById('resultsPanel').classList.remove('active');

            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.removeEventListener('click', handleMarkingClick);
        }

        function updatePointsDisplay() {
            document.getElementById('pointCount').textContent = state.calibrationPoints.length;
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
    </script>

</body>
</html>
