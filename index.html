<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clearance Genie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin: 10px 0;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
        }

        input[type="file"] {
            display: none;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            background: #f7fafc;
            display: none;
        }

        .canvas-container.active {
            display: block;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            cursor: crosshair;
        }

        .instructions {
            background: #edf2f7;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            line-height: 1.6;
        }

        .calibration-points {
            background: #fff5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f56565;
        }

        .calibration-points p {
            margin: 5px 0;
            font-weight: 600;
        }

        .status {
            background: #c6f6d5;
            color: #22543d;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.warning {
            background: #feebc8;
            color: #7c2d12;
        }

        .calibration-info {
            background: #e6fffa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #38b2ac;
            display: none;
        }

        .calibration-info.active {
            display: block;
        }

        .calibration-info h4 {
            color: #38b2ac;
            margin-bottom: 10px;
        }

        .calibration-info p {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .status.active + .button-group {
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .button-group {
                grid-template-columns: 1fr;
            }
        }

        .flue-marker {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 0, 0, 0.5);
            border: 3px solid #f56565;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .clearance-zone {
            position: absolute;
            border: 2px dashed;
            pointer-events: none;
            opacity: 0.6;
        }

        .zone-safe {
            border-color: #48bb78;
            background: rgba(72, 187, 120, 0.1);
        }

        .zone-danger {
            border-color: #f56565;
            background: rgba(245, 101, 101, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî• Clearance Genie</h1>

        <div class="card">
            <h2>Step 1: Load Photo</h2>
            <p style="margin: 10px 0; color: #666;">Take or upload a photo with your blue calibration card visible</p>

            <input type="file" id="photoInput" accept="image/*">
            <div class="button-group">
                <button class="btn" onclick="document.getElementById('photoInput').click()">
                    üìÅ Choose Photo
                </button>
                <button class="btn" onclick="openCamera()">
                    üì∑ Take Photo
                </button>
            </div>

            <div class="instructions">
                <h3>üìã How to take the photo:</h3>
                <ol>
                    <li>Place your blue calibration card on the wall at the proposed flue height</li>
                    <li>Stand back and take a clear photo that includes the card and surrounding area</li>
                    <li>Make sure the card is visible and not blurry</li>
                    <li>Include any windows, vents, corners, or obstacles in the frame</li>
                </ol>
            </div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="photoCanvas"></canvas>
        </div>

        <div class="card" id="calibrationCard" style="display: none;">
            <h2>Step 2: Calibrate Scale</h2>

            <div class="status" id="tapStatus">
                Choose calibration method below
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="autoDetectCard()">
                    ü§ñ Auto-Detect Card
                </button>
                <button class="btn" onclick="startManualCalibration()">
                    üëÜ Manual 4-Point
                </button>
            </div>

            <div class="calibration-points" id="pointsDisplay" style="display: none;">
                <p>Points tapped: <span id="pointCount">0</span>/4</p>
                <button class="btn btn-danger" onclick="resetCalibration()" style="margin-top: 10px;">
                    ‚Ü∫ Reset Points
                </button>
            </div>

            <div class="calibration-info" id="calibrationInfo">
                <h4>‚úÖ Calibration Complete!</h4>
                <p>Scale: <span id="scaleDisplay">-</span> pixels/mm</p>
                <p>Card Width: <span id="cardWidthDisplay">-</span> pixels (should be ~85.6mm)</p>
                <p>Card Height: <span id="cardHeightDisplay">-</span> pixels (should be ~53.98mm)</p>
                <p>Accuracy: <span id="accuracyDisplay">-</span></p>
                <button class="btn" onclick="resetCalibration()" style="margin-top: 10px;">
                    üîÑ Recalibrate
                </button>
            </div>
        </div>

        <div class="card" id="analysisCard" style="display: none;">
            <h2>Step 3: Choose Analysis Type</h2>

            <div class="instructions">
                <h3>What do you want to check?</h3>
            </div>

            <div class="button-group">
                <button class="btn btn-secondary" onclick="startFlueMode()">
                    üî• Flue Clearances
                </button>
                <button class="btn btn-secondary" onclick="startBoilerMode()">
                    üîß Boiler Clearances
                </button>
            </div>

            <div id="positionInstructions" style="display: none;">
                <div class="status active" id="positionStatus">
                    üëÜ Tap on the image to mark the position
                </div>

                <button class="btn" id="analyzeBtn" onclick="analyzeClearances()" disabled>
                    üîç Calculate Clearance Zones
                </button>
            </div>

            <div class="status" id="analysisStatus"></div>
        </div>
    </div>

    <script>
        const state = {
            photo: null,
            canvas: null,
            ctx: null,
            calibrationPoints: [],
            isCalibrating: false,
            pxPerMM: null,
            fluePosition: null,
            canvasScale: 1,
            mode: null
        };

        const CARD_WIDTH_MM = 85.6;
        const CARD_HEIGHT_MM = 53.98;

        document.getElementById('photoInput').addEventListener('change', handlePhotoUpload);

        function openCamera() {
            const input = document.getElementById('photoInput');
            input.setAttribute('capture', 'environment');
            input.click();
            setTimeout(() => input.removeAttribute('capture'), 100);
        }

        function handlePhotoUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    setupCanvas(img);
                    document.getElementById('canvasContainer').classList.add('active');
                    document.getElementById('calibrationCard').style.display = 'block';
                };
                img.src = event.target.result;
                state.photo = img;
            };
            reader.readAsDataURL(file);
        }

        function setupCanvas(img) {
            const canvas = document.getElementById('photoCanvas');
            canvas.width = img.width;
            canvas.height = img.height;

            state.canvas = canvas;
            state.ctx = canvas.getContext('2d');
            state.ctx.drawImage(img, 0, 0);

            const rect = canvas.getBoundingClientRect();
            state.canvasScale = canvas.width / rect.width;
        }

        function startManualCalibration() {
            if (!state.canvas) return;
            state.isCalibrating = true;
            state.calibrationPoints = [];
            updatePointsDisplay();

            document.getElementById('pointsDisplay').style.display = 'block';

            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.classList.remove('warning');
            status.textContent = 'Tap corner 1/4: Top-Left corner of card';

            state.canvas.removeEventListener('click', handleCalibrationClick);
            state.canvas.addEventListener('click', handleCalibrationClick);
        }

        function autoDetectCard() {
            if (!state.ctx) return;
            const status = document.getElementById('tapStatus');
            status.classList.add('active');
            status.textContent = 'üîç Searching for blue card...';

            const imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            const data = imageData.data;
            const bluePixels = [];

            for (let y = 0; y < state.canvas.height; y++) {
                for (let x = 0; x < state.canvas.width; x++) {
                    const i = (y * state.canvas.width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    if (b > r + 30 && b > g + 30 && b > 100) {
                        bluePixels.push({x, y});
                    }
                }
            }

            if (bluePixels.length < 100) {
                status.classList.add('warning');
                status.textContent = '‚ùå Could not find blue card. Try manual calibration or adjust lighting.';
                return;
            }

            const minX = Math.min(...bluePixels.map(p => p.x));
            const maxX = Math.max(...bluePixels.map(p => p.x));
            const minY = Math.min(...bluePixels.map(p => p.y));
            const maxY = Math.max(...bluePixels.map(p => p.y));

            const width = maxX - minX;
            const height = maxY - minY;
            const aspectRatio = width / height;
            const expectedRatio = CARD_WIDTH_MM / CARD_HEIGHT_MM;

            if (Math.abs(aspectRatio - expectedRatio) > 0.3) {
                status.classList.add('warning');
                status.textContent = `‚ö†Ô∏è Found blue region but shape doesn't match card (ratio: ${aspectRatio.toFixed(2)}). Try manual calibration.`;

                state.ctx.strokeStyle = '#f56565';
                state.ctx.lineWidth = 3;
                state.ctx.strokeRect(minX, minY, width, height);
                return;
            }

            state.calibrationPoints = [
                {x: minX, y: minY},
                {x: maxX, y: minY},
                {x: maxX, y: maxY},
                {x: minX, y: maxY}
            ];

            status.textContent = '‚úÖ Card detected! Calculating scale...';
            setTimeout(() => calculateCalibration(), 300);
        }

        function handleCalibrationClick(e) {
            if (!state.isCalibrating) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            state.calibrationPoints.push({x, y});

            state.ctx.fillStyle = '#f56565';
            state.ctx.beginPath();
            state.ctx.arc(x, y, 8, 0, Math.PI * 2);
            state.ctx.fill();

            state.ctx.fillStyle = 'white';
            state.ctx.font = 'bold 16px Arial';
            state.ctx.textAlign = 'center';
            state.ctx.textBaseline = 'middle';
            state.ctx.fillText(state.calibrationPoints.length, x, y);

            updatePointsDisplay();

            const status = document.getElementById('tapStatus');
            const corners = ['Top-Left', 'Top-Right', 'Bottom-Right', 'Bottom-Left'];

            if (state.calibrationPoints.length < 4) {
                status.textContent = `Tap corner ${state.calibrationPoints.length + 1}/4: ${corners[state.calibrationPoints.length]} corner of card`;
            } else {
                calculateCalibration();
            }
        }

        function calculateCalibration() {
            if (state.calibrationPoints.length !== 4) return;
            const points = state.calibrationPoints;

            const topWidth = distance(points[0], points[1]);
            const bottomWidth = distance(points[3], points[2]);
            const leftHeight = distance(points[0], points[3]);
            const rightHeight = distance(points[1], points[2]);

            const avgWidthPx = (topWidth + bottomWidth) / 2;
            const avgHeightPx = (leftHeight + rightHeight) / 2;

            const pxPerMMWidth = avgWidthPx / CARD_WIDTH_MM;
            const pxPerMMHeight = avgHeightPx / CARD_HEIGHT_MM;
            state.pxPerMM = (pxPerMMWidth + pxPerMMHeight) / 2;

            const skew = Math.abs(pxPerMMWidth - pxPerMMHeight) / state.pxPerMM * 100;
            let accuracyRating = '';

            if (skew < 5) {
                accuracyRating = '‚úÖ Excellent (< 5% skew)';
            } else if (skew < 10) {
                accuracyRating = '‚ö†Ô∏è Good (< 10% skew)';
            } else {
                accuracyRating = '‚ùå Poor - Consider retaking photo more straight-on';
            }

            redrawPhoto();
            state.ctx.strokeStyle = skew < 10 ? '#48bb78' : '#f56565';
            state.ctx.lineWidth = 4;
            state.ctx.beginPath();
            state.ctx.moveTo(points[0].x, points[0].y);
            state.ctx.lineTo(points[1].x, points[1].y);
            state.ctx.lineTo(points[2].x, points[2].y);
            state.ctx.lineTo(points[3].x, points[3].y);
            state.ctx.closePath();
            state.ctx.stroke();

            points.forEach((point, i) => {
                state.ctx.fillStyle = skew < 10 ? '#48bb78' : '#f56565';
                state.ctx.beginPath();
                state.ctx.arc(point.x, point.y, 10, 0, Math.PI * 2);
                state.ctx.fill();

                state.ctx.fillStyle = 'white';
                state.ctx.font = 'bold 14px Arial';
                state.ctx.textAlign = 'center';
                state.ctx.textBaseline = 'middle';
                state.ctx.fillText(i + 1, point.x, point.y);
            });

            state.isCalibrating = false;
            state.canvas.removeEventListener('click', handleCalibrationClick);

            const status = document.getElementById('tapStatus');
            status.classList.remove('active', 'warning');

            const info = document.getElementById('calibrationInfo');
            info.classList.add('active');
            document.getElementById('scaleDisplay').textContent = state.pxPerMM.toFixed(2);
            document.getElementById('cardWidthDisplay').textContent = avgWidthPx.toFixed(1);
            document.getElementById('cardHeightDisplay').textContent = avgHeightPx.toFixed(1);
            document.getElementById('accuracyDisplay').textContent = accuracyRating;

            document.getElementById('analysisCard').style.display = 'block';
        }

        function startFlueMode() {
            if (!state.pxPerMM) return;
            state.mode = 'flue';
            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üî• Tap where you want the flue terminal';
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.addEventListener('click', handlePositionClick);
        }

        function startBoilerMode() {
            if (!state.pxPerMM) return;
            state.mode = 'boiler';
            document.getElementById('positionInstructions').style.display = 'block';
            document.getElementById('positionStatus').textContent = 'üîß Tap where the boiler will be located';
            state.canvas.removeEventListener('click', handlePositionClick);
            state.canvas.addEventListener('click', handlePositionClick);
        }

        function handlePositionClick(e) {
            if (state.isCalibrating || !state.mode) return;

            const rect = state.canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * state.canvasScale;
            const y = (e.clientY - rect.top) * state.canvasScale;

            state.fluePosition = {x, y};

            redrawPhoto();
            drawCalibrationOverlay();
            drawFlueMarker(x, y);

            document.getElementById('analyzeBtn').disabled = false;
            const modeText = state.mode === 'flue' ? 'flue terminal' : 'boiler';
            document.getElementById('positionStatus').textContent = `‚úÖ ${modeText} position marked. Click "Calculate Clearance Zones" to analyze.`;
        }

        function drawFlueMarker(x, y) {
            state.ctx.fillStyle = 'rgba(245, 101, 101, 0.3)';
            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.arc(x, y, 20, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();

            state.ctx.strokeStyle = '#f56565';
            state.ctx.lineWidth = 2;
            state.ctx.beginPath();
            state.ctx.moveTo(x - 30, y);
            state.ctx.lineTo(x + 30, y);
            state.ctx.moveTo(x, y - 30);
            state.ctx.lineTo(x, y + 30);
            state.ctx.stroke();
        }

        function drawCalibrationOverlay() {
            if (state.calibrationPoints.length !== 4) return;
            const points = state.calibrationPoints;

            state.ctx.strokeStyle = '#48bb78';
            state.ctx.lineWidth = 3;
            state.ctx.beginPath();
            state.ctx.moveTo(points[0].x, points[0].y);
            state.ctx.lineTo(points[1].x, points[1].y);
            state.ctx.lineTo(points[2].x, points[2].y);
            state.ctx.lineTo(points[3].x, points[3].y);
            state.ctx.closePath();
            state.ctx.stroke();

            points.forEach((point, i) => {
                state.ctx.fillStyle = '#f56565';
                state.ctx.beginPath();
                state.ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                state.ctx.fill();

                state.ctx.fillStyle = 'white';
                state.ctx.font = 'bold 14px Arial';
                state.ctx.textAlign = 'center';
                state.ctx.textBaseline = 'middle';
                state.ctx.fillText(i + 1, point.x, point.y);
            });
        }

        function analyzeClearances() {
            if (!state.fluePosition || !state.pxPerMM) return;

            const flue = state.fluePosition;
            const clearanceRadius = 300 * state.pxPerMM;

            redrawPhoto();
            drawCalibrationOverlay();

            state.ctx.fillStyle = 'rgba(72, 187, 120, 0.2)';
            state.ctx.strokeStyle = '#48bb78';
            state.ctx.lineWidth = 3;
            state.ctx.setLineDash([10, 5]);
            state.ctx.beginPath();
            state.ctx.arc(flue.x, flue.y, clearanceRadius, 0, Math.PI * 2);
            state.ctx.fill();
            state.ctx.stroke();
            state.ctx.setLineDash([]);

            drawFlueMarker(flue.x, flue.y);

            const status = document.getElementById('analysisStatus');
            status.classList.add('active');
            const modeText = state.mode === 'flue' ? 'flue terminal' : 'boiler';
            status.textContent = `‚úÖ Basic clearance zone shown for ${modeText} (300mm radius). Ready for AI integration and brand-specific rules.`;
        }

        function resetCalibration() {
            state.calibrationPoints = [];
            state.isCalibrating = false;
            state.pxPerMM = null;
            state.fluePosition = null;
            state.mode = null;

            redrawPhoto();
            updatePointsDisplay();

            const tapStatus = document.getElementById('tapStatus');
            tapStatus.classList.remove('active', 'warning');
            tapStatus.textContent = 'Choose calibration method below';

            document.getElementById('calibrationInfo').classList.remove('active');
            document.getElementById('pointsDisplay').style.display = 'none';
            document.getElementById('analysisCard').style.display = 'none';
            document.getElementById('positionInstructions').style.display = 'none';
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analysisStatus').classList.remove('active');
            document.getElementById('analysisStatus').textContent = '';

            state.canvas?.removeEventListener('click', handleCalibrationClick);
            state.canvas?.removeEventListener('click', handlePositionClick);
        }

        function redrawPhoto() {
            if (state.photo && state.ctx) {
                state.ctx.drawImage(state.photo, 0, 0);
            }
        }

        function updatePointsDisplay() {
            document.getElementById('pointCount').textContent = state.calibrationPoints.length;
        }

        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
    </script>
</body>
</html>
